{"version":3,"sources":["../src/account.ts","../src/decode-account.ts","../src/parse-account.ts","../src/fetch-account.ts","../src/maybe-account.ts"],"names":["SolanaError"],"mappings":"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","sourcesContent":["import type { Address } from '@solana/addresses';\nimport type { LamportsUnsafeBeyond2Pow53Minus1 } from '@solana/rpc-types';\n\n/** The amount of bytes required to store the base account information without its data. */\nexport const BASE_ACCOUNT_SIZE = 128;\n\n/** Describe the generic account details applicable to every account. */\nexport type BaseAccount = {\n    readonly executable: boolean;\n    readonly lamports: LamportsUnsafeBeyond2Pow53Minus1;\n    readonly programAddress: Address;\n};\n\n/** Defines a Solana account with its generic details and parsed or encoded data. */\nexport type Account<TData extends Uint8Array | object, TAddress extends string = string> = BaseAccount & {\n    readonly address: Address<TAddress>;\n    readonly data: TData;\n};\n\n/** Defines a Solana account with its generic details and encoded data. */\nexport type EncodedAccount<TAddress extends string = string> = Account<Uint8Array, TAddress>;\n","import type { Decoder } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SolanaError,\n} from '@solana/errors';\n\nimport type { Account, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\n\n/** Decodes the data of a given account using the provided decoder. */\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): MaybeAccount<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    try {\n        if ('exists' in encodedAccount && !encodedAccount.exists) {\n            return encodedAccount;\n        }\n        return Object.freeze({ ...encodedAccount, data: decoder.decode(encodedAccount.data) });\n    } catch (e) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT, {\n            address: encodedAccount.address,\n        });\n    }\n}\n\nfunction accountExists<TData extends object>(account: Account<TData> | MaybeAccount<TData>): account is Account<TData> {\n    return !('exists' in account) || ('exists' in account && account.exists);\n}\n\n/** Asserts that an account has been decoded. */\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is MaybeAccount<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress> | MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    if (accountExists(account) && account.data instanceof Uint8Array) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT, {\n            address: account.address,\n        });\n    }\n}\n\n/** Asserts that all accounts have been decoded. */\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: Account<TData | Uint8Array, TAddress>[],\n): asserts accounts is Account<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: MaybeAccount<TData | Uint8Array, TAddress>[],\n): asserts accounts is MaybeAccount<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: (Account<TData | Uint8Array, TAddress> | MaybeAccount<TData | Uint8Array, TAddress>)[],\n): asserts accounts is (Account<TData, TAddress> | MaybeAccount<TData, TAddress>)[] {\n    const encoded = accounts.filter(a => accountExists(a) && a.data instanceof Uint8Array);\n    if (encoded.length > 0) {\n        const encodedAddresses = encoded.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED, {\n            addresses: encodedAddresses,\n        });\n    }\n}\n","import type { Address } from '@solana/addresses';\nimport { getBase58Encoder, getBase64Encoder } from '@solana/codecs-strings';\nimport type {\n    AccountInfoBase,\n    AccountInfoWithBase58Bytes,\n    AccountInfoWithBase58EncodedData,\n    AccountInfoWithBase64EncodedData,\n} from '@solana/rpc-types';\n\nimport type { Account, BaseAccount, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport type { JsonParsedDataResponse } from './rpc-api';\n\ntype Base64EncodedRpcAccount = AccountInfoBase & AccountInfoWithBase64EncodedData;\n\n/** Parse an account object received from a base64-encoded RPC call into an EncodedAccount or MaybeEncodedAccount type. */\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase64Encoder().encode(rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype Base58EncodedRpcAccount = AccountInfoBase & (AccountInfoWithBase58Bytes | AccountInfoWithBase58EncodedData);\n\n/** Parse an account object received from a base58-encoded RPC call into an EncodedAccount or MaybeEncodedAccount type. */\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase58Encoder().encode(typeof rpcAccount.data === 'string' ? rpcAccount.data : rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype JsonParsedRpcAccount = AccountInfoBase & { readonly data: JsonParsedDataResponse<unknown> };\n\n/** Parse an account object received from a json-parsed RPC call into an Account or MaybeAccount type. */\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount,\n): Account<TData, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): MaybeAccount<TData, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = rpcAccount.data.parsed.info as TData;\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\nfunction parseBaseAccount(rpcAccount: AccountInfoBase): BaseAccount {\n    return Object.freeze({\n        executable: rpcAccount.executable,\n        lamports: rpcAccount.lamports,\n        programAddress: rpcAccount.owner,\n    });\n}\n","import type { Address } from '@solana/addresses';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Commitment, Slot } from '@solana/rpc-types';\n\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport { parseBase64RpcAccount, parseJsonRpcAccount } from './parse-account';\nimport type { GetAccountInfoApi, GetMultipleAccountsApi } from './rpc-api';\n\n/** Optional configuration for fetching a singular account. */\nexport type FetchAccountConfig = {\n    abortSignal?: AbortSignal;\n    commitment?: Commitment;\n    minContextSlot?: Slot;\n};\n\n/** Fetch a base64-encoded account that may or may not exist using an RPC client. */\nexport async function fetchEncodedAccount<TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<MaybeEncodedAccount<TAddress>> {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc.getAccountInfo(address, { ...rpcConfig, encoding: 'base64' }).send({ abortSignal });\n    return parseBase64RpcAccount(address, response.value);\n}\n\n/** Fetch a json-parsed account that may or may not exist using an RPC client. */\nexport async function fetchJsonParsedAccount<TData extends object, TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<MaybeAccount<TData, TAddress> | MaybeEncodedAccount<TAddress>> {\n    const { abortSignal, ...rpcConfig } = config;\n    const { value: account } = await rpc\n        .getAccountInfo(address, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return !!account && typeof account === 'object' && 'parsed' in account.data\n        ? parseJsonRpcAccount<TData, TAddress>(address, account as Parameters<typeof parseJsonRpcAccount>[1])\n        : parseBase64RpcAccount<TAddress>(address, account as Parameters<typeof parseBase64RpcAccount>[1]);\n}\n\n/** Optional configuration for fetching multiple accounts. */\nexport type FetchAccountsConfig = {\n    abortSignal?: AbortSignal;\n    commitment?: Commitment;\n    minContextSlot?: Slot;\n};\n\n/** Fetch multiple base64-encoded accounts that may or may not exist using an RPC client. */\nexport async function fetchEncodedAccounts<\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'base64' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => parseBase64RpcAccount(addresses[index], account)) as {\n        [P in keyof TAddresses]: MaybeEncodedAccount<TAddresses[P]>;\n    };\n}\n\n/** Fetch multiple json-parsed accounts that may or may not exist using an RPC client. */\nexport async function fetchJsonParsedAccounts<\n    TData extends object[],\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => {\n        return !!account && typeof account === 'object' && 'parsed' in account.data\n            ? parseJsonRpcAccount(addresses[index], account as Parameters<typeof parseJsonRpcAccount>[1])\n            : parseBase64RpcAccount(addresses[index], account as Parameters<typeof parseBase64RpcAccount>[1]);\n    }) as {\n        [P in keyof TAddresses]:\n            | MaybeAccount<TData[P & keyof TData], TAddresses[P]>\n            | MaybeEncodedAccount<TAddresses[P]>;\n    } & {\n        [P in keyof TData]:\n            | MaybeAccount<TData[P], TAddresses[P & keyof TAddresses]>\n            | MaybeEncodedAccount<TAddresses[P & keyof TAddresses]>;\n    };\n}\n","import { Address } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\n\nimport { Account } from './account';\n\n/** Defines a Solana account that may or may not exist after having tried to fetch it. */\nexport type MaybeAccount<TData extends Uint8Array | object, TAddress extends string = string> =\n    | { readonly address: Address<TAddress>; readonly exists: false }\n    | (Account<TData, TAddress> & { readonly exists: true });\n\n/** Defines a Solana account with encoded data that may or may not exist after having tried to fetch it. */\nexport type MaybeEncodedAccount<TAddress extends string = string> = MaybeAccount<Uint8Array, TAddress>;\n\n/** Asserts that an account that may or may not exists, actually exists. */\nexport function assertAccountExists<TData extends Uint8Array | object, TAddress extends string = string>(\n    account: MaybeAccount<TData, TAddress>,\n): asserts account is Account<TData, TAddress> & { exists: true } {\n    if (!account.exists) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND, { address: account.address });\n    }\n}\n\n/** Asserts that all accounts that may or may not exist, actually all exist. */\nexport function assertAccountsExist<TData extends Uint8Array | object, TAddress extends string = string>(\n    accounts: MaybeAccount<TData, TAddress>[],\n): asserts accounts is (Account<TData, TAddress> & { exists: true })[] {\n    const missingAccounts = accounts.filter(a => !a.exists);\n    if (missingAccounts.length > 0) {\n        const missingAddresses = missingAccounts.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND, { addresses: missingAddresses });\n    }\n}\n"]}