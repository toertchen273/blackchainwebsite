{"version":3,"sources":["../../codecs-core/src/bytes.ts","../../codecs-core/src/codec.ts","../../codecs-core/src/combine-codec.ts","../../codecs-core/src/fix-codec.ts","../src/blockhash.ts","../src/cluster-url.ts","../src/commitment.ts","../src/lamports.ts","../src/stringified-bigint.ts","../src/stringified-number.ts","../src/unix-timestamp.ts"],"names":["SolanaError"],"mappings":"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","sourcesContent":["/**\n * Concatenates an array of `Uint8Array`s into a single `Uint8Array`.\n * Reuses the original byte array when applicable.\n */\nexport const mergeBytes = (byteArrays: Uint8Array[]): Uint8Array => {\n    const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n\n    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach(arr => {\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\n\n/**\n * Pads a `Uint8Array` with zeroes to the specified length.\n * If the array is longer than the specified length, it is returned as-is.\n */\nexport const padBytes = (bytes: Uint8Array, length: number): Uint8Array => {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\n\n/**\n * Fixes a `Uint8Array` to the specified length.\n * If the array is longer than the specified length, it is truncated.\n * If the array is shorter than the specified length, it is padded with zeroes.\n */\nexport const fixBytes = (bytes: Uint8Array, length: number): Uint8Array =>\n    padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\n","import {\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\n/**\n * Defines an offset in bytes.\n */\nexport type Offset = number;\n\ntype BaseEncoder<TFrom> = {\n    /** Encode the provided value and return the encoded bytes directly. */\n    readonly encode: (value: TFrom) => Uint8Array;\n    /**\n     * Writes the encoded value into the provided byte array at the given offset.\n     * Returns the offset of the next byte after the encoded value.\n     */\n    readonly write: (value: TFrom, bytes: Uint8Array, offset: Offset) => Offset;\n};\n\nexport type FixedSizeEncoder<TFrom, TSize extends number = number> = BaseEncoder<TFrom> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\nexport type VariableSizeEncoder<TFrom> = BaseEncoder<TFrom> & {\n    /** The total size of the encoded value in bytes. */\n    readonly getSizeFromValue: (value: TFrom) => number;\n    /** The maximum size an encoded value can be in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can encode a value to a `Uint8Array`.\n */\nexport type Encoder<TFrom> = FixedSizeEncoder<TFrom> | VariableSizeEncoder<TFrom>;\n\ntype BaseDecoder<TTo> = {\n    /** Decodes the provided byte array at the given offset (or zero) and returns the value directly. */\n    readonly decode: (bytes: Uint8Array, offset?: Offset) => TTo;\n    /**\n     * Reads the encoded value from the provided byte array at the given offset.\n     * Returns the decoded value and the offset of the next byte after the encoded value.\n     */\n    readonly read: (bytes: Uint8Array, offset: Offset) => [TTo, Offset];\n};\n\nexport type FixedSizeDecoder<TTo, TSize extends number = number> = BaseDecoder<TTo> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\nexport type VariableSizeDecoder<TTo> = BaseDecoder<TTo> & {\n    /** The maximum size an encoded value can be in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can decode a value from a `Uint8Array`.\n */\nexport type Decoder<TTo> = FixedSizeDecoder<TTo> | VariableSizeDecoder<TTo>;\n\nexport type FixedSizeCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number> = FixedSizeDecoder<\n    TTo,\n    TSize\n> &\n    FixedSizeEncoder<TFrom, TSize>;\n\nexport type VariableSizeCodec<TFrom, TTo extends TFrom = TFrom> = VariableSizeDecoder<TTo> & VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can encode and decode a value to and from a `Uint8Array`.\n * It supports encoding looser types than it decodes for convenience.\n * For example, a `bigint` encoder will always decode to a `bigint`\n * but can be used to encode a `number`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value. Defaults to `TFrom`.\n */\nexport type Codec<TFrom, TTo extends TFrom = TFrom> = FixedSizeCodec<TFrom, TTo> | VariableSizeCodec<TFrom, TTo>;\n\n/**\n * Get the encoded size of a given value in bytes.\n */\nexport function getEncodedSize<TFrom>(\n    value: TFrom,\n    encoder: { fixedSize: number } | { getSizeFromValue: (value: TFrom) => number },\n): number {\n    return 'fixedSize' in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\n\n/** Fills the missing `encode` function using the existing `write` function. */\nexport function createEncoder<TFrom, TSize extends number>(\n    encoder: Omit<FixedSizeEncoder<TFrom, TSize>, 'encode'>,\n): FixedSizeEncoder<TFrom, TSize>;\nexport function createEncoder<TFrom>(encoder: Omit<VariableSizeEncoder<TFrom>, 'encode'>): VariableSizeEncoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom> {\n    return Object.freeze({\n        ...encoder,\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/** Fills the missing `decode` function using the existing `read` function. */\nexport function createDecoder<TTo, TSize extends number>(\n    decoder: Omit<FixedSizeDecoder<TTo, TSize>, 'decode'>,\n): FixedSizeDecoder<TTo, TSize>;\nexport function createDecoder<TTo>(decoder: Omit<VariableSizeDecoder<TTo>, 'decode'>): VariableSizeDecoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo> {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0],\n    });\n}\n\n/** Fills the missing `encode` and `decode` function using the existing `write` and `read` functions. */\nexport function createCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number>(\n    codec: Omit<FixedSizeCodec<TFrom, TTo, TSize>, 'decode' | 'encode'>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec: Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo> {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\nexport function isFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function isFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): decoder is FixedSizeDecoder<TTo, TSize>;\nexport function isFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function isFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): codec is { fixedSize: TSize };\nexport function isFixedSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { fixedSize: number } {\n    return 'fixedSize' in codec && typeof codec.fixedSize === 'number';\n}\n\nexport function assertIsFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): asserts encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function assertIsFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): asserts decoder is FixedSizeDecoder<TTo, TSize>;\nexport function assertIsFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): asserts codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function assertIsFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): asserts codec is { fixedSize: TSize };\nexport function assertIsFixedSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { fixedSize: number } {\n    if (!isFixedSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\n\nexport function isVariableSize<TFrom>(encoder: Encoder<TFrom>): encoder is VariableSizeEncoder<TFrom>;\nexport function isVariableSize<TTo>(decoder: Decoder<TTo>): decoder is VariableSizeDecoder<TTo>;\nexport function isVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): codec is VariableSizeCodec<TFrom, TTo>;\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number };\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number } {\n    return !isFixedSize(codec);\n}\n\nexport function assertIsVariableSize<T>(encoder: Encoder<T>): asserts encoder is VariableSizeEncoder<T>;\nexport function assertIsVariableSize<T>(decoder: Decoder<T>): asserts decoder is VariableSizeDecoder<T>;\nexport function assertIsVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): asserts codec is VariableSizeCodec<TFrom, TTo>;\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number };\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number } {\n    if (!isVariableSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    Codec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\n\n/**\n * Combines an encoder and a decoder into a codec.\n * The encoder and decoder must have the same fixed size, max size and description.\n * If a description is provided, it will override the encoder and decoder descriptions.\n */\nexport function combineCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: VariableSizeEncoder<TFrom>,\n    decoder: VariableSizeDecoder<TTo>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo> {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize,\n        });\n    }\n\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize,\n        });\n    }\n\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write,\n    };\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport { fixBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    Offset,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Creates a fixed-size encoder from a given encoder.\n *\n * @param encoder - The encoder to wrap into a fixed-size encoder.\n * @param fixedBytes - The fixed number of bytes to write.\n */\nexport function fixEncoder<TFrom, TSize extends number>(\n    encoder: Encoder<TFrom>,\n    fixedBytes: TSize,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value: TFrom, bytes: Uint8Array, offset: Offset) => {\n            // Here we exceptionally use the `encode` function instead of the `write`\n            // function as using the nested `write` function on a fixed-sized byte\n            // array may result in a out-of-bounds error on the nested encoder.\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray =\n                variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        },\n    });\n}\n\n/**\n * Creates a fixed-size decoder from a given decoder.\n *\n * @param decoder - The decoder to wrap into a fixed-size decoder.\n * @param fixedBytes - The fixed number of bytes to read.\n */\nexport function fixDecoder<TTo, TSize extends number>(\n    decoder: Decoder<TTo>,\n    fixedBytes: TSize,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes: Uint8Array, offset: Offset) => {\n            assertByteArrayHasEnoughBytesForCodec('fixCodec', fixedBytes, bytes, offset);\n            // Slice the byte array to the fixed size if necessary.\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            // If the nested decoder is fixed-size, pad and truncate the byte array accordingly.\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            // Decode the value using the nested decoder.\n            const [value] = decoder.read(bytes, 0);\n            return [value, offset + fixedBytes];\n        },\n    });\n}\n\n/**\n * Creates a fixed-size codec from a given codec.\n *\n * @param codec - The codec to wrap into a fixed-size codec.\n * @param fixedBytes - The fixed number of bytes to read/write.\n */\nexport function fixCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: Codec<TFrom, TTo>,\n    fixedBytes: TSize,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(fixEncoder(codec, fixedBytes), fixDecoder(codec, fixedBytes));\n}\n","import {\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    mapEncoder,\n} from '@solana/codecs-core';\nimport { getBase58Decoder, getBase58Encoder, getStringDecoder, getStringEncoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\nexport type Blockhash = string & { readonly __brand: unique symbol };\n\nlet memoizedBase58Encoder: Encoder<string> | undefined;\nlet memoizedBase58Decoder: Decoder<string> | undefined;\n\nfunction getMemoizedBase58Encoder(): Encoder<string> {\n    if (!memoizedBase58Encoder) memoizedBase58Encoder = getBase58Encoder();\n    return memoizedBase58Encoder;\n}\n\nfunction getMemoizedBase58Decoder(): Decoder<string> {\n    if (!memoizedBase58Decoder) memoizedBase58Decoder = getBase58Decoder();\n    return memoizedBase58Decoder;\n}\n\nexport function isBlockhash(putativeBlockhash: string): putativeBlockhash is Blockhash {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (32 bytes of zeroes)\n        putativeBlockhash.length < 32 ||\n        // Highest value (32 bytes of 255)\n        putativeBlockhash.length > 44\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeBlockhash);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        return false;\n    }\n    return true;\n}\n\nexport function assertIsBlockhash(putativeBlockhash: string): asserts putativeBlockhash is Blockhash {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (32 bytes of zeroes)\n        putativeBlockhash.length < 32 ||\n        // Highest value (32 bytes of 255)\n        putativeBlockhash.length > 44\n    ) {\n        throw new SolanaError(SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeBlockhash.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeBlockhash);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        throw new SolanaError(SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\nexport function blockhash(putativeBlockhash: string): Blockhash {\n    assertIsBlockhash(putativeBlockhash);\n    return putativeBlockhash as Blockhash;\n}\n\nexport function getBlockhashEncoder(): FixedSizeEncoder<Blockhash, 32> {\n    return mapEncoder(getStringEncoder({ encoding: getMemoizedBase58Encoder(), size: 32 }), putativeBlockhash =>\n        blockhash(putativeBlockhash),\n    );\n}\n\nexport function getBlockhashDecoder(): FixedSizeDecoder<Blockhash, 32> {\n    return getStringDecoder({ encoding: getMemoizedBase58Decoder(), size: 32 }) as FixedSizeDecoder<Blockhash, 32>;\n}\n\nexport function getBlockhashCodec(): FixedSizeCodec<Blockhash, Blockhash, 32> {\n    return combineCodec(getBlockhashEncoder(), getBlockhashDecoder());\n}\n\nexport function getBlockhashComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n","export type MainnetUrl = string & { '~cluster': 'mainnet' };\nexport type DevnetUrl = string & { '~cluster': 'devnet' };\nexport type TestnetUrl = string & { '~cluster': 'testnet' };\nexport type ClusterUrl = DevnetUrl | MainnetUrl | TestnetUrl | string;\n\nexport function mainnet(putativeString: string): MainnetUrl {\n    return putativeString as MainnetUrl;\n}\nexport function devnet(putativeString: string): DevnetUrl {\n    return putativeString as DevnetUrl;\n}\nexport function testnet(putativeString: string): TestnetUrl {\n    return putativeString as TestnetUrl;\n}\n","import { SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, SolanaError } from '@solana/errors';\n\nexport type Commitment = 'confirmed' | 'finalized' | 'processed';\n\nfunction getCommitmentScore(commitment: Commitment): number {\n    switch (commitment) {\n        case 'finalized':\n            return 2;\n        case 'confirmed':\n            return 1;\n        case 'processed':\n            return 0;\n        default:\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                unexpectedValue: commitment satisfies never,\n            });\n    }\n}\n\nexport function commitmentComparator(a: Commitment, b: Commitment): -1 | 0 | 1 {\n    if (a === b) {\n        return 0;\n    }\n    return getCommitmentScore(a) < getCommitmentScore(b) ? -1 : 1;\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder, mapDecoder } from '@solana/codecs-core';\nimport { getU64Decoder, getU64Encoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\n// FIXME(solana-labs/solana/issues/30341) Beware that any value above 9007199254740991 may be\n// truncated or rounded because of a downcast to JavaScript `number` between your calling code and\n// the JSON-RPC transport.\nexport type LamportsUnsafeBeyond2Pow53Minus1 = bigint & { readonly __brand: unique symbol };\n\n// Largest possible value to be represented by a u64\nconst maxU64Value = 18446744073709551615n; // 2n ** 64n - 1n\n\nlet memoizedU64Encoder: FixedSizeEncoder<bigint, 8> | undefined;\nlet memoizedU64Decoder: FixedSizeDecoder<bigint, 8> | undefined;\n\nfunction getMemoizedU64Encoder(): FixedSizeEncoder<bigint, 8> {\n    if (!memoizedU64Encoder) memoizedU64Encoder = getU64Encoder();\n    return memoizedU64Encoder;\n}\n\nfunction getMemoizedU64Decoder(): FixedSizeDecoder<bigint, 8> {\n    if (!memoizedU64Decoder) memoizedU64Decoder = getU64Decoder();\n    return memoizedU64Decoder;\n}\n\nexport function isLamports(putativeLamports: bigint): putativeLamports is LamportsUnsafeBeyond2Pow53Minus1 {\n    return putativeLamports >= 0 && putativeLamports <= maxU64Value;\n}\n\nexport function assertIsLamports(\n    putativeLamports: bigint,\n): asserts putativeLamports is LamportsUnsafeBeyond2Pow53Minus1 {\n    if (putativeLamports < 0 || putativeLamports > maxU64Value) {\n        throw new SolanaError(SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE);\n    }\n}\n\nexport function lamports(putativeLamports: bigint): LamportsUnsafeBeyond2Pow53Minus1 {\n    assertIsLamports(putativeLamports);\n    return putativeLamports;\n}\n\nexport function getLamportsEncoder(): FixedSizeEncoder<LamportsUnsafeBeyond2Pow53Minus1, 8> {\n    return getMemoizedU64Encoder();\n}\n\nexport function getLamportsDecoder(): FixedSizeDecoder<LamportsUnsafeBeyond2Pow53Minus1, 8> {\n    return mapDecoder(getMemoizedU64Decoder(), lamports);\n}\n\nexport function getLamportsCodec(): FixedSizeCodec<\n    LamportsUnsafeBeyond2Pow53Minus1,\n    LamportsUnsafeBeyond2Pow53Minus1,\n    8\n> {\n    return combineCodec(getLamportsEncoder(), getLamportsDecoder());\n}\n","import { SOLANA_ERROR__MALFORMED_BIGINT_STRING, SolanaError } from '@solana/errors';\n\nexport type StringifiedBigInt = string & { readonly __brand: unique symbol };\n\nexport function isStringifiedBigInt(putativeBigInt: string): putativeBigInt is StringifiedBigInt {\n    try {\n        BigInt(putativeBigInt);\n        return true;\n    } catch (_) {\n        return false;\n    }\n}\n\nexport function assertIsStringifiedBigInt(putativeBigInt: string): asserts putativeBigInt is StringifiedBigInt {\n    try {\n        BigInt(putativeBigInt);\n    } catch {\n        throw new SolanaError(SOLANA_ERROR__MALFORMED_BIGINT_STRING, {\n            value: putativeBigInt,\n        });\n    }\n}\n\nexport function stringifiedBigInt(putativeBigInt: string): StringifiedBigInt {\n    assertIsStringifiedBigInt(putativeBigInt);\n    return putativeBigInt;\n}\n","import { SOLANA_ERROR__MALFORMED_NUMBER_STRING, SolanaError } from '@solana/errors';\n\nexport type StringifiedNumber = string & { readonly __brand: unique symbol };\n\nexport function isStringifiedNumber(putativeNumber: string): putativeNumber is StringifiedNumber {\n    return !Number.isNaN(Number(putativeNumber));\n}\n\nexport function assertIsStringifiedNumber(putativeNumber: string): asserts putativeNumber is StringifiedNumber {\n    if (Number.isNaN(Number(putativeNumber))) {\n        throw new SolanaError(SOLANA_ERROR__MALFORMED_NUMBER_STRING, {\n            value: putativeNumber,\n        });\n    }\n}\n\nexport function stringifiedNumber(putativeNumber: string): StringifiedNumber {\n    assertIsStringifiedNumber(putativeNumber);\n    return putativeNumber;\n}\n","import { SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nexport type UnixTimestamp = number & { readonly __brand: unique symbol };\n\nexport function isUnixTimestamp(putativeTimestamp: number): putativeTimestamp is UnixTimestamp {\n    // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#the_epoch_timestamps_and_invalid_date\n    if (putativeTimestamp > 8.64e15 || putativeTimestamp < -8.64e15) {\n        return false;\n    }\n    return true;\n}\n\nexport function assertIsUnixTimestamp(putativeTimestamp: number): asserts putativeTimestamp is UnixTimestamp {\n    // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#the_epoch_timestamps_and_invalid_date\n\n    if (putativeTimestamp > 8.64e15 || putativeTimestamp < -8.64e15) {\n        throw new SolanaError(SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, {\n            value: putativeTimestamp,\n        });\n    }\n}\n\nexport function unixTimestamp(putativeTimestamp: number): UnixTimestamp {\n    assertIsUnixTimestamp(putativeTimestamp);\n    return putativeTimestamp;\n}\n"]}