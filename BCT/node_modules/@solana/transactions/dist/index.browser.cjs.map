{"version":3,"sources":["../src/blockhash.ts","../../codecs-core/src/bytes.ts","../../rpc-types/src/blockhash.ts","../src/unsigned-transaction.ts","../src/create-transaction.ts","../src/decompile-transaction.ts","../../instructions/src/instruction.ts","../../instructions/src/roles.ts","../src/durable-nonce.ts","../src/fee-payer.ts","../src/instructions.ts","../src/accounts.ts","../src/compile-address-table-lookups.ts","../src/compile-header.ts","../src/compile-instructions.ts","../src/compile-lifetime-token.ts","../src/compile-static-accounts.ts","../src/message.ts","../src/serializers/message.ts","../src/serializers/address-table-lookup.ts","../src/serializers/header.ts","../src/serializers/instruction.ts","../src/serializers/transaction-version.ts","../src/serializers/transaction.ts","../src/compile-transaction.ts","../src/signatures.ts","../src/wire-transaction.ts"],"names":["SolanaError","AccountRole","getAddressComparator","getAddressDecoder","getAddressEncoder","combineCodec","createEncoder","mapDecoder","mapEncoder","getArrayDecoder","getArrayEncoder","getStructDecoder","getStructEncoder","getShortU16Decoder","getShortU16Encoder","getBase58Decoder","getBase58Encoder","getStringDecoder","getStringEncoder","getU8Decoder","getU8Encoder","getBytesDecoder","getBytesEncoder"],"mappings":"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","sourcesContent":["import { SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME, SolanaError } from '@solana/errors';\nimport { assertIsBlockhash, type Blockhash } from '@solana/rpc-types';\n\nimport { IDurableNonceTransaction } from './durable-nonce';\nimport { ITransactionWithSignatures } from './signatures';\nimport { BaseTransaction } from './types';\nimport { getUnsignedTransaction } from './unsigned-transaction';\n\ntype BlockhashLifetimeConstraint = Readonly<{\n    blockhash: Blockhash;\n    lastValidBlockHeight: bigint;\n}>;\n\nexport interface ITransactionWithBlockhashLifetime {\n    readonly lifetimeConstraint: BlockhashLifetimeConstraint;\n}\n\nfunction isTransactionWithBlockhashLifetime(\n    transaction: BaseTransaction | (BaseTransaction & ITransactionWithBlockhashLifetime),\n): transaction is BaseTransaction & ITransactionWithBlockhashLifetime {\n    const lifetimeConstraintShapeMatches =\n        'lifetimeConstraint' in transaction &&\n        typeof transaction.lifetimeConstraint.blockhash === 'string' &&\n        typeof transaction.lifetimeConstraint.lastValidBlockHeight === 'bigint';\n    if (!lifetimeConstraintShapeMatches) return false;\n    try {\n        assertIsBlockhash(transaction.lifetimeConstraint.blockhash);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\nexport function assertIsTransactionWithBlockhashLifetime(\n    transaction: BaseTransaction | (BaseTransaction & ITransactionWithBlockhashLifetime),\n): asserts transaction is BaseTransaction & ITransactionWithBlockhashLifetime {\n    if (!isTransactionWithBlockhashLifetime(transaction)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n    }\n}\n\nexport function setTransactionLifetimeUsingBlockhash<TTransaction extends BaseTransaction & IDurableNonceTransaction>(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transaction: TTransaction | (ITransactionWithSignatures & TTransaction),\n): ITransactionWithBlockhashLifetime & Omit<TTransaction, keyof ITransactionWithSignatures | 'lifetimeConstraint'>;\n\nexport function setTransactionLifetimeUsingBlockhash<\n    TTransaction extends BaseTransaction | (BaseTransaction & ITransactionWithBlockhashLifetime),\n>(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transaction: TTransaction | (ITransactionWithSignatures & TTransaction),\n): ITransactionWithBlockhashLifetime & Omit<TTransaction, keyof ITransactionWithSignatures>;\n\nexport function setTransactionLifetimeUsingBlockhash(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transaction: BaseTransaction | (BaseTransaction & ITransactionWithBlockhashLifetime),\n) {\n    if (\n        'lifetimeConstraint' in transaction &&\n        transaction.lifetimeConstraint.blockhash === blockhashLifetimeConstraint.blockhash &&\n        transaction.lifetimeConstraint.lastValidBlockHeight === blockhashLifetimeConstraint.lastValidBlockHeight\n    ) {\n        return transaction;\n    }\n    const out = {\n        ...getUnsignedTransaction(transaction),\n        lifetimeConstraint: blockhashLifetimeConstraint,\n    };\n    Object.freeze(out);\n    return out;\n}\n","/**\n * Concatenates an array of `Uint8Array`s into a single `Uint8Array`.\n * Reuses the original byte array when applicable.\n */\nexport const mergeBytes = (byteArrays: Uint8Array[]): Uint8Array => {\n    const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n\n    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach(arr => {\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\n\n/**\n * Pads a `Uint8Array` with zeroes to the specified length.\n * If the array is longer than the specified length, it is returned as-is.\n */\nexport const padBytes = (bytes: Uint8Array, length: number): Uint8Array => {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\n\n/**\n * Fixes a `Uint8Array` to the specified length.\n * If the array is longer than the specified length, it is truncated.\n * If the array is shorter than the specified length, it is padded with zeroes.\n */\nexport const fixBytes = (bytes: Uint8Array, length: number): Uint8Array =>\n    padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\n","import {\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    mapEncoder,\n} from '@solana/codecs-core';\nimport { getBase58Decoder, getBase58Encoder, getStringDecoder, getStringEncoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\nexport type Blockhash = string & { readonly __brand: unique symbol };\n\nlet memoizedBase58Encoder: Encoder<string> | undefined;\nlet memoizedBase58Decoder: Decoder<string> | undefined;\n\nfunction getMemoizedBase58Encoder(): Encoder<string> {\n    if (!memoizedBase58Encoder) memoizedBase58Encoder = getBase58Encoder();\n    return memoizedBase58Encoder;\n}\n\nfunction getMemoizedBase58Decoder(): Decoder<string> {\n    if (!memoizedBase58Decoder) memoizedBase58Decoder = getBase58Decoder();\n    return memoizedBase58Decoder;\n}\n\nexport function isBlockhash(putativeBlockhash: string): putativeBlockhash is Blockhash {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (32 bytes of zeroes)\n        putativeBlockhash.length < 32 ||\n        // Highest value (32 bytes of 255)\n        putativeBlockhash.length > 44\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeBlockhash);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        return false;\n    }\n    return true;\n}\n\nexport function assertIsBlockhash(putativeBlockhash: string): asserts putativeBlockhash is Blockhash {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (32 bytes of zeroes)\n        putativeBlockhash.length < 32 ||\n        // Highest value (32 bytes of 255)\n        putativeBlockhash.length > 44\n    ) {\n        throw new SolanaError(SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeBlockhash.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeBlockhash);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        throw new SolanaError(SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\nexport function blockhash(putativeBlockhash: string): Blockhash {\n    assertIsBlockhash(putativeBlockhash);\n    return putativeBlockhash as Blockhash;\n}\n\nexport function getBlockhashEncoder(): FixedSizeEncoder<Blockhash, 32> {\n    return mapEncoder(getStringEncoder({ encoding: getMemoizedBase58Encoder(), size: 32 }), putativeBlockhash =>\n        blockhash(putativeBlockhash),\n    );\n}\n\nexport function getBlockhashDecoder(): FixedSizeDecoder<Blockhash, 32> {\n    return getStringDecoder({ encoding: getMemoizedBase58Decoder(), size: 32 }) as FixedSizeDecoder<Blockhash, 32>;\n}\n\nexport function getBlockhashCodec(): FixedSizeCodec<Blockhash, Blockhash, 32> {\n    return combineCodec(getBlockhashEncoder(), getBlockhashDecoder());\n}\n\nexport function getBlockhashComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n","import { ITransactionWithSignatures } from '.';\nimport { BaseTransaction } from './types';\n\nexport function getUnsignedTransaction<TTransaction extends BaseTransaction>(\n    transaction: TTransaction | (ITransactionWithSignatures & TTransaction),\n): Omit<ITransactionWithSignatures & TTransaction, keyof ITransactionWithSignatures> | TTransaction {\n    if ('signatures' in transaction) {\n        // The implication of the lifetime constraint changing is that any existing signatures are invalid.\n        const {\n            signatures: _, // eslint-disable-line @typescript-eslint/no-unused-vars\n            ...unsignedTransaction\n        } = transaction;\n        return unsignedTransaction;\n    } else {\n        return transaction;\n    }\n}\n","import { Transaction, TransactionVersion } from './types';\n\ntype TransactionConfig<TVersion extends TransactionVersion> = Readonly<{\n    version: TVersion;\n}>;\n\nexport function createTransaction<TVersion extends TransactionVersion>(\n    config: TransactionConfig<TVersion>,\n): Extract<Transaction, { version: TVersion }>;\nexport function createTransaction<TVersion extends TransactionVersion>({\n    version,\n}: TransactionConfig<TVersion>): Transaction {\n    const out: Transaction = {\n        instructions: [],\n        version,\n    };\n    Object.freeze(out);\n    return out;\n}\n","import { Address, assertIsAddress } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\nimport { pipe } from '@solana/functional';\nimport { AccountRole, IAccountLookupMeta, IAccountMeta, IInstruction } from '@solana/instructions';\nimport { SignatureBytes } from '@solana/keys';\nimport type { Blockhash } from '@solana/rpc-types';\n\nimport { setTransactionLifetimeUsingBlockhash } from './blockhash';\nimport { CompilableTransaction } from './compilable-transaction';\nimport type { getCompiledAddressTableLookups } from './compile-address-table-lookups';\nimport { CompiledTransaction } from './compile-transaction';\nimport { createTransaction } from './create-transaction';\nimport { isAdvanceNonceAccountInstruction, Nonce, setTransactionLifetimeUsingDurableNonce } from './durable-nonce';\nimport { setTransactionFeePayer } from './fee-payer';\nimport { appendTransactionInstruction } from './instructions';\nimport { CompiledMessage } from './message';\nimport { ITransactionWithSignatures } from './signatures';\nimport { TransactionVersion } from './types';\n\nfunction getAccountMetas(message: CompiledMessage): IAccountMeta[] {\n    const { header } = message;\n    const numWritableSignerAccounts = header.numSignerAccounts - header.numReadonlySignerAccounts;\n    const numWritableNonSignerAccounts =\n        message.staticAccounts.length - header.numSignerAccounts - header.numReadonlyNonSignerAccounts;\n\n    const accountMetas: IAccountMeta[] = [];\n\n    let accountIndex = 0;\n    for (let i = 0; i < numWritableSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlySignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < numWritableNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlyNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY,\n        });\n        accountIndex++;\n    }\n\n    return accountMetas;\n}\n\nexport type AddressesByLookupTableAddress = { [lookupTableAddress: Address]: Address[] };\n\nfunction getAddressLookupMetas(\n    compiledAddressTableLookups: ReturnType<typeof getCompiledAddressTableLookups>,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): IAccountLookupMeta[] {\n    // check that all message lookups are known\n    const compiledAddressTableLookupAddresses = compiledAddressTableLookups.map(l => l.lookupTableAddress);\n    const missing = compiledAddressTableLookupAddresses.filter(a => addressesByLookupTableAddress[a] === undefined);\n    if (missing.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, {\n            lookupTableAddresses: missing,\n        });\n    }\n\n    const readOnlyMetas: IAccountLookupMeta[] = [];\n    const writableMetas: IAccountLookupMeta[] = [];\n\n    // we know that for each lookup, knownLookups[lookup.lookupTableAddress] is defined\n    for (const lookup of compiledAddressTableLookups) {\n        const addresses = addressesByLookupTableAddress[lookup.lookupTableAddress];\n\n        const highestIndex = Math.max(...lookup.readableIndices, ...lookup.writableIndices);\n        if (highestIndex >= addresses.length) {\n            throw new SolanaError(\n                SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n                {\n                    highestKnownIndex: addresses.length - 1,\n                    highestRequestedIndex: highestIndex,\n                    lookupTableAddress: lookup.lookupTableAddress,\n                },\n            );\n        }\n\n        const readOnlyForLookup: IAccountLookupMeta[] = lookup.readableIndices.map(r => ({\n            address: addresses[r],\n            addressIndex: r,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.READONLY,\n        }));\n        readOnlyMetas.push(...readOnlyForLookup);\n\n        const writableForLookup: IAccountLookupMeta[] = lookup.writableIndices.map(w => ({\n            address: addresses[w],\n            addressIndex: w,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.WRITABLE,\n        }));\n        writableMetas.push(...writableForLookup);\n    }\n\n    return [...writableMetas, ...readOnlyMetas];\n}\n\nfunction convertInstruction(\n    instruction: CompiledMessage['instructions'][0],\n    accountMetas: IAccountMeta[],\n): IInstruction {\n    const programAddress = accountMetas[instruction.programAddressIndex]?.address;\n    if (!programAddress) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, {\n            index: instruction.programAddressIndex,\n        });\n    }\n\n    const accounts = instruction.accountIndices?.map(accountIndex => accountMetas[accountIndex]);\n    const { data } = instruction;\n\n    return {\n        programAddress,\n        ...(accounts && accounts.length ? { accounts } : {}),\n        ...(data && data.length ? { data } : {}),\n    };\n}\n\ntype LifetimeConstraint =\n    | {\n          blockhash: Blockhash;\n          lastValidBlockHeight: bigint;\n      }\n    | {\n          nonce: Nonce;\n          nonceAccountAddress: Address;\n          nonceAuthorityAddress: Address;\n      };\n\nfunction getLifetimeConstraint(\n    messageLifetimeToken: string,\n    firstInstruction?: IInstruction,\n    lastValidBlockHeight?: bigint,\n): LifetimeConstraint {\n    if (!firstInstruction || !isAdvanceNonceAccountInstruction(firstInstruction)) {\n        // first instruction is not advance durable nonce, so use blockhash lifetime constraint\n        return {\n            blockhash: messageLifetimeToken as Blockhash,\n            lastValidBlockHeight: lastValidBlockHeight ?? 2n ** 64n - 1n, // U64 MAX\n        };\n    } else {\n        // We know these accounts are defined because we checked `isAdvanceNonceAccountInstruction`\n        const nonceAccountAddress = firstInstruction.accounts![0].address;\n        assertIsAddress(nonceAccountAddress);\n\n        const nonceAuthorityAddress = firstInstruction.accounts![2].address;\n        assertIsAddress(nonceAuthorityAddress);\n\n        return {\n            nonce: messageLifetimeToken as Nonce,\n            nonceAccountAddress,\n            nonceAuthorityAddress,\n        };\n    }\n}\n\nfunction convertSignatures(compiledTransaction: CompiledTransaction): ITransactionWithSignatures['signatures'] {\n    const {\n        compiledMessage: { staticAccounts },\n        signatures,\n    } = compiledTransaction;\n    return signatures.reduce((acc, sig, index) => {\n        // compiled transaction includes a fake all 0 signature if it hasn't been signed\n        // we don't store those for the new tx model. So just skip if it's all 0s\n        const allZeros = sig.every(byte => byte === 0);\n        if (allZeros) return acc;\n\n        const address = staticAccounts[index];\n        return { ...acc, [address]: sig as SignatureBytes };\n    }, {});\n}\n\nexport type DecompileTransactionConfig = {\n    addressesByLookupTableAddress?: AddressesByLookupTableAddress;\n    lastValidBlockHeight?: bigint;\n};\n\nexport function decompileTransaction(\n    compiledTransaction: CompiledTransaction,\n    config?: DecompileTransactionConfig,\n): CompilableTransaction | (CompilableTransaction & ITransactionWithSignatures) {\n    const { compiledMessage } = compiledTransaction;\n\n    const feePayer = compiledMessage.staticAccounts[0];\n    if (!feePayer) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING);\n    }\n\n    const accountMetas = getAccountMetas(compiledMessage);\n    const accountLookupMetas =\n        'addressTableLookups' in compiledMessage &&\n        compiledMessage.addressTableLookups !== undefined &&\n        compiledMessage.addressTableLookups.length > 0\n            ? getAddressLookupMetas(compiledMessage.addressTableLookups, config?.addressesByLookupTableAddress ?? {})\n            : [];\n    const transactionMetas = [...accountMetas, ...accountLookupMetas];\n\n    const instructions: IInstruction[] = compiledMessage.instructions.map(compiledInstruction =>\n        convertInstruction(compiledInstruction, transactionMetas),\n    );\n\n    const firstInstruction = instructions[0];\n    const lifetimeConstraint = getLifetimeConstraint(\n        compiledMessage.lifetimeToken,\n        firstInstruction,\n        config?.lastValidBlockHeight,\n    );\n\n    const signatures = convertSignatures(compiledTransaction);\n\n    return pipe(\n        createTransaction({ version: compiledMessage.version as TransactionVersion }),\n        tx => setTransactionFeePayer(feePayer, tx),\n        tx =>\n            instructions.reduce((acc, instruction) => {\n                return appendTransactionInstruction(instruction, acc);\n            }, tx),\n        tx =>\n            'blockhash' in lifetimeConstraint\n                ? setTransactionLifetimeUsingBlockhash(lifetimeConstraint, tx)\n                : setTransactionLifetimeUsingDurableNonce(lifetimeConstraint, tx),\n        tx => (Object.keys(signatures).length > 0 ? { ...tx, signatures } : tx),\n    );\n}\n","import { Address } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { IAccountLookupMeta, IAccountMeta } from './accounts';\n\nexport interface IInstruction<\n    TProgramAddress extends string = string,\n    TAccounts extends readonly (IAccountLookupMeta | IAccountMeta)[] = readonly (IAccountLookupMeta | IAccountMeta)[],\n> {\n    readonly accounts?: TAccounts;\n    readonly data?: Uint8Array;\n    readonly programAddress: Address<TProgramAddress>;\n}\n\nexport interface IInstructionWithAccounts<TAccounts extends readonly (IAccountLookupMeta | IAccountMeta)[]>\n    extends IInstruction {\n    readonly accounts: TAccounts;\n}\n\nexport function isInstructionForProgram<TProgramAddress extends string, TInstruction extends IInstruction>(\n    instruction: TInstruction,\n    programAddress: Address<TProgramAddress>,\n): instruction is TInstruction & { programAddress: Address<TProgramAddress> } {\n    return instruction.programAddress === programAddress;\n}\n\nexport function assertIsInstructionForProgram<TProgramAddress extends string, TInstruction extends IInstruction>(\n    instruction: TInstruction,\n    programAddress: Address<TProgramAddress>,\n): asserts instruction is TInstruction & { programAddress: Address<TProgramAddress> } {\n    if (instruction.programAddress !== programAddress) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH, {\n            actualProgramAddress: instruction.programAddress,\n            expectedProgramAddress: programAddress,\n        });\n    }\n}\n\nexport function isInstructionWithAccounts<\n    TAccounts extends readonly (IAccountLookupMeta | IAccountMeta)[] = readonly (IAccountLookupMeta | IAccountMeta)[],\n    TInstruction extends IInstruction = IInstruction,\n>(instruction: TInstruction): instruction is IInstructionWithAccounts<TAccounts> & TInstruction {\n    return instruction.accounts !== undefined;\n}\n\nexport function assertIsInstructionWithAccounts<\n    TAccounts extends readonly (IAccountLookupMeta | IAccountMeta)[] = readonly (IAccountLookupMeta | IAccountMeta)[],\n    TInstruction extends IInstruction = IInstruction,\n>(instruction: TInstruction): asserts instruction is IInstructionWithAccounts<TAccounts> & TInstruction {\n    if (instruction.accounts === undefined) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS, {\n            data: instruction.data,\n            programAddress: instruction.programAddress,\n        });\n    }\n}\n\nexport interface IInstructionWithData<TData extends Uint8Array> extends IInstruction {\n    readonly data: TData;\n}\n\nexport function isInstructionWithData<\n    TData extends Uint8Array = Uint8Array,\n    TInstruction extends IInstruction = IInstruction,\n>(instruction: TInstruction): instruction is IInstructionWithData<TData> & TInstruction {\n    return instruction.data !== undefined;\n}\n\nexport function assertIsInstructionWithData<\n    TData extends Uint8Array = Uint8Array,\n    TInstruction extends IInstruction = IInstruction,\n>(instruction: TInstruction): asserts instruction is IInstructionWithData<TData> & TInstruction {\n    if (instruction.data === undefined) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA, {\n            accountAddresses: instruction.accounts?.map(a => a.address),\n            programAddress: instruction.programAddress,\n        });\n    }\n}\n","/**\n * Quick primer on bitwise operations: https://stackoverflow.com/a/1436448/802047\n */\n\nexport enum AccountRole {\n    // Bitflag guide: is signer ⌄⌄ is writable\n    WRITABLE_SIGNER = /* 3 */ 0b11, // prettier-ignore\n    READONLY_SIGNER = /* 2 */ 0b10, // prettier-ignore\n    WRITABLE =        /* 1 */ 0b01, // prettier-ignore\n    READONLY =        /* 0 */ 0b00, // prettier-ignore\n}\n\nconst IS_SIGNER_BITMASK = 0b10;\nconst IS_WRITABLE_BITMASK = 0b01;\n\nexport function downgradeRoleToNonSigner(role: AccountRole.READONLY_SIGNER): AccountRole.READONLY;\nexport function downgradeRoleToNonSigner(role: AccountRole.WRITABLE_SIGNER): AccountRole.WRITABLE;\nexport function downgradeRoleToNonSigner(role: AccountRole): AccountRole;\nexport function downgradeRoleToNonSigner(role: AccountRole): AccountRole {\n    return role & ~IS_SIGNER_BITMASK;\n}\n\nexport function downgradeRoleToReadonly(role: AccountRole.WRITABLE): AccountRole.READONLY;\nexport function downgradeRoleToReadonly(role: AccountRole.WRITABLE_SIGNER): AccountRole.READONLY_SIGNER;\nexport function downgradeRoleToReadonly(role: AccountRole): AccountRole;\nexport function downgradeRoleToReadonly(role: AccountRole): AccountRole {\n    return role & ~IS_WRITABLE_BITMASK;\n}\n\nexport function isSignerRole(role: AccountRole): role is AccountRole.READONLY_SIGNER | AccountRole.WRITABLE_SIGNER {\n    return role >= AccountRole.READONLY_SIGNER;\n}\n\nexport function isWritableRole(role: AccountRole): role is AccountRole.WRITABLE | AccountRole.WRITABLE_SIGNER {\n    return (role & IS_WRITABLE_BITMASK) !== 0;\n}\n\nexport function mergeRoles(roleA: AccountRole.WRITABLE, roleB: AccountRole.READONLY_SIGNER): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY_SIGNER, roleB: AccountRole.WRITABLE): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.WRITABLE_SIGNER): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.WRITABLE_SIGNER, roleB: AccountRole): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.READONLY_SIGNER): AccountRole.READONLY_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY_SIGNER, roleB: AccountRole): AccountRole.READONLY_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.WRITABLE): AccountRole.WRITABLE; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.WRITABLE, roleB: AccountRole): AccountRole.WRITABLE; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY, roleB: AccountRole.READONLY): AccountRole.READONLY; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole): AccountRole; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole): AccountRole {\n    return roleA | roleB;\n}\n\nexport function upgradeRoleToSigner(role: AccountRole.READONLY): AccountRole.READONLY_SIGNER;\nexport function upgradeRoleToSigner(role: AccountRole.WRITABLE): AccountRole.WRITABLE_SIGNER;\nexport function upgradeRoleToSigner(role: AccountRole): AccountRole;\nexport function upgradeRoleToSigner(role: AccountRole): AccountRole {\n    return role | IS_SIGNER_BITMASK;\n}\n\nexport function upgradeRoleToWritable(role: AccountRole.READONLY): AccountRole.WRITABLE;\nexport function upgradeRoleToWritable(role: AccountRole.READONLY_SIGNER): AccountRole.WRITABLE_SIGNER;\nexport function upgradeRoleToWritable(role: AccountRole): AccountRole;\nexport function upgradeRoleToWritable(role: AccountRole): AccountRole {\n    return role | IS_WRITABLE_BITMASK;\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME, SolanaError } from '@solana/errors';\nimport {\n    AccountRole,\n    IInstruction,\n    IInstructionWithAccounts,\n    IInstructionWithData,\n    isSignerRole,\n    ReadonlyAccount,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableSignerAccount,\n} from '@solana/instructions';\n\nimport { ITransactionWithSignatures } from './signatures';\nimport { BaseTransaction } from './types';\nimport { getUnsignedTransaction } from './unsigned-transaction';\n\ntype AdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n> = IInstruction<'11111111111111111111111111111111'> &\n    IInstructionWithAccounts<\n        readonly [\n            WritableAccount<TNonceAccountAddress>,\n            ReadonlyAccount<'SysvarRecentB1ockHashes11111111111111111111'>,\n            ReadonlySignerAccount<TNonceAuthorityAddress> | WritableSignerAccount<TNonceAuthorityAddress>,\n        ]\n    > &\n    IInstructionWithData<AdvanceNonceAccountInstructionData>;\ntype AdvanceNonceAccountInstructionData = Uint8Array & {\n    readonly __brand: unique symbol;\n};\ntype DurableNonceConfig<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = Readonly<{\n    readonly nonce: Nonce<TNonceValue>;\n    readonly nonceAccountAddress: Address<TNonceAccountAddress>;\n    readonly nonceAuthorityAddress: Address<TNonceAuthorityAddress>;\n}>;\nexport type Nonce<TNonceValue extends string = string> = TNonceValue & { readonly __brand: unique symbol };\ntype NonceLifetimeConstraint<TNonceValue extends string = string> = Readonly<{\n    nonce: Nonce<TNonceValue>;\n}>;\n\nconst RECENT_BLOCKHASHES_SYSVAR_ADDRESS =\n    'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\nconst SYSTEM_PROGRAM_ADDRESS = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n\nexport interface IDurableNonceTransaction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> {\n    readonly instructions: readonly [\n        // The first instruction *must* be the system program's `AdvanceNonceAccount` instruction.\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...IInstruction[],\n    ];\n    readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n}\n\nexport function assertIsDurableNonceTransaction(\n    transaction: BaseTransaction | (BaseTransaction & IDurableNonceTransaction),\n): asserts transaction is BaseTransaction & IDurableNonceTransaction {\n    if (!isDurableNonceTransaction(transaction)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n    }\n}\n\nfunction createAdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n>(\n    nonceAccountAddress: Address<TNonceAccountAddress>,\n    nonceAuthorityAddress: Address<TNonceAuthorityAddress>,\n): AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return {\n        accounts: [\n            { address: nonceAccountAddress, role: AccountRole.WRITABLE },\n            {\n                address: RECENT_BLOCKHASHES_SYSVAR_ADDRESS,\n                role: AccountRole.READONLY,\n            },\n            { address: nonceAuthorityAddress, role: AccountRole.READONLY_SIGNER },\n        ],\n        data: new Uint8Array([4, 0, 0, 0]) as AdvanceNonceAccountInstructionData,\n        programAddress: SYSTEM_PROGRAM_ADDRESS,\n    };\n}\n\nexport function isAdvanceNonceAccountInstruction(\n    instruction: IInstruction,\n): instruction is AdvanceNonceAccountInstruction {\n    return (\n        instruction.programAddress === SYSTEM_PROGRAM_ADDRESS &&\n        // Test for `AdvanceNonceAccount` instruction data\n        instruction.data != null &&\n        isAdvanceNonceAccountInstructionData(instruction.data) &&\n        // Test for exactly 3 accounts\n        instruction.accounts?.length === 3 &&\n        // First account is nonce account address\n        instruction.accounts[0].address != null &&\n        instruction.accounts[0].role === AccountRole.WRITABLE &&\n        // Second account is recent blockhashes sysvar\n        instruction.accounts[1].address === RECENT_BLOCKHASHES_SYSVAR_ADDRESS &&\n        instruction.accounts[1].role === AccountRole.READONLY &&\n        // Third account is nonce authority account\n        instruction.accounts[2].address != null &&\n        isSignerRole(instruction.accounts[2].role)\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionData(data: Uint8Array): data is AdvanceNonceAccountInstructionData {\n    // AdvanceNonceAccount is the fifth instruction in the System Program (index 4)\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n\nfunction isDurableNonceTransaction(\n    transaction: BaseTransaction | (BaseTransaction & IDurableNonceTransaction),\n): transaction is BaseTransaction & IDurableNonceTransaction {\n    return (\n        'lifetimeConstraint' in transaction &&\n        typeof transaction.lifetimeConstraint.nonce === 'string' &&\n        transaction.instructions[0] != null &&\n        isAdvanceNonceAccountInstruction(transaction.instructions[0])\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionForNonce<\n    TNonceAccountAddress extends Address = Address,\n    TNonceAuthorityAddress extends Address = Address,\n>(\n    instruction: AdvanceNonceAccountInstruction,\n    nonceAccountAddress: TNonceAccountAddress,\n    nonceAuthorityAddress: TNonceAuthorityAddress,\n): instruction is AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return (\n        instruction.accounts[0].address === nonceAccountAddress &&\n        instruction.accounts[2].address === nonceAuthorityAddress\n    );\n}\n\nexport function setTransactionLifetimeUsingDurableNonce<\n    TTransaction extends BaseTransaction,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n>(\n    {\n        nonce,\n        nonceAccountAddress,\n        nonceAuthorityAddress,\n    }: DurableNonceConfig<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue>,\n    transaction: TTransaction | (IDurableNonceTransaction & TTransaction),\n): IDurableNonceTransaction<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue> &\n    Omit<TTransaction, keyof ITransactionWithSignatures> {\n    let newInstructions: [\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...IInstruction[],\n    ];\n\n    const firstInstruction = transaction.instructions[0];\n    if (firstInstruction && isAdvanceNonceAccountInstruction(firstInstruction)) {\n        if (isAdvanceNonceAccountInstructionForNonce(firstInstruction, nonceAccountAddress, nonceAuthorityAddress)) {\n            if (isDurableNonceTransaction(transaction) && transaction.lifetimeConstraint.nonce === nonce) {\n                return transaction as IDurableNonceTransaction<\n                    TNonceAccountAddress,\n                    TNonceAuthorityAddress,\n                    TNonceValue\n                > &\n                    TTransaction;\n            } else {\n                // we already have the right first instruction, leave it as-is\n                newInstructions = [firstInstruction, ...transaction.instructions.slice(1)];\n            }\n        } else {\n            // we have a different advance nonce instruction as the first instruction, replace it\n            newInstructions = [\n                createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress),\n                ...transaction.instructions.slice(1),\n            ];\n        }\n    } else {\n        // we don't have an existing advance nonce instruction as the first instruction, prepend one\n        newInstructions = [\n            createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress),\n            ...transaction.instructions,\n        ];\n    }\n\n    const out = {\n        ...getUnsignedTransaction(transaction),\n        instructions: newInstructions,\n        lifetimeConstraint: {\n            nonce,\n        },\n    } as IDurableNonceTransaction<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue> & TTransaction;\n    Object.freeze(out);\n    return out;\n}\n","import { Address } from '@solana/addresses';\n\nimport { ITransactionWithSignatures } from './signatures';\nimport { BaseTransaction } from './types';\nimport { getUnsignedTransaction } from './unsigned-transaction';\n\nexport interface ITransactionWithFeePayer<TAddress extends string = string> {\n    readonly feePayer: Address<TAddress>;\n}\n\nexport function setTransactionFeePayer<TFeePayerAddress extends string, TTransaction extends BaseTransaction>(\n    feePayer: Address<TFeePayerAddress>,\n    transaction:\n        | (ITransactionWithFeePayer<string> & ITransactionWithSignatures & TTransaction)\n        | (ITransactionWithSignatures & TTransaction),\n): ITransactionWithFeePayer<TFeePayerAddress> & Omit<TTransaction, keyof ITransactionWithSignatures>;\n\nexport function setTransactionFeePayer<TFeePayerAddress extends string, TTransaction extends BaseTransaction>(\n    feePayer: Address<TFeePayerAddress>,\n    transaction: TTransaction | (ITransactionWithFeePayer<string> & TTransaction),\n): ITransactionWithFeePayer<TFeePayerAddress> & TTransaction;\n\nexport function setTransactionFeePayer<TFeePayerAddress extends string, TTransaction extends BaseTransaction>(\n    feePayer: Address<TFeePayerAddress>,\n    transaction:\n        | TTransaction\n        | (ITransactionWithFeePayer<string> & ITransactionWithSignatures & TTransaction)\n        | (ITransactionWithFeePayer<string> & TTransaction)\n        | (ITransactionWithSignatures & TTransaction),\n) {\n    if ('feePayer' in transaction && feePayer === transaction.feePayer) {\n        return transaction;\n    }\n    const out = {\n        ...getUnsignedTransaction(transaction),\n        feePayer,\n    };\n    Object.freeze(out);\n    return out;\n}\n","import { ITransactionWithSignatures } from './signatures';\nimport { BaseTransaction } from './types';\nimport { getUnsignedTransaction } from './unsigned-transaction';\n\nexport function appendTransactionInstruction<TTransaction extends BaseTransaction>(\n    instruction: TTransaction['instructions'][number],\n    transaction: TTransaction | (ITransactionWithSignatures & TTransaction),\n): Omit<TTransaction, keyof ITransactionWithSignatures> | TTransaction {\n    return appendTransactionInstructions([instruction], transaction);\n}\n\nexport function appendTransactionInstructions<TTransaction extends BaseTransaction>(\n    instructions: ReadonlyArray<TTransaction['instructions'][number]>,\n    transaction: TTransaction | (ITransactionWithSignatures & TTransaction),\n): Omit<TTransaction, keyof ITransactionWithSignatures> | TTransaction {\n    const out = {\n        ...getUnsignedTransaction(transaction),\n        instructions: [...transaction.instructions, ...instructions],\n    };\n    Object.freeze(out);\n    return out;\n}\n\nexport function prependTransactionInstruction<TTransaction extends BaseTransaction>(\n    instruction: TTransaction['instructions'][number],\n    transaction: TTransaction | (ITransactionWithSignatures & TTransaction),\n): Omit<TTransaction, keyof ITransactionWithSignatures> | TTransaction {\n    return prependTransactionInstructions([instruction], transaction);\n}\n\nexport function prependTransactionInstructions<TTransaction extends BaseTransaction>(\n    instructions: ReadonlyArray<TTransaction['instructions'][number]>,\n    transaction: TTransaction | (ITransactionWithSignatures & TTransaction),\n): Omit<TTransaction, keyof ITransactionWithSignatures> | TTransaction {\n    const out = {\n        ...getUnsignedTransaction(transaction),\n        instructions: [...instructions, ...transaction.instructions],\n    };\n    Object.freeze(out);\n    return out;\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SolanaError,\n} from '@solana/errors';\nimport {\n    AccountRole,\n    IAccountLookupMeta,\n    IAccountMeta,\n    IInstruction,\n    isSignerRole,\n    isWritableRole,\n    mergeRoles,\n    ReadonlyAccount,\n    ReadonlyAccountLookup,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableAccountLookup,\n    WritableSignerAccount,\n} from '@solana/instructions';\n\nexport const enum AddressMapEntryType {\n    FEE_PAYER,\n    LOOKUP_TABLE,\n    STATIC,\n}\n\ntype AddressMap = {\n    [address: string]: FeePayerAccountEntry | LookupTableAccountEntry | StaticAccountEntry;\n};\ntype FeePayerAccountEntry = Omit<WritableSignerAccount, 'address'> & {\n    [TYPE]: AddressMapEntryType.FEE_PAYER;\n};\ntype LookupTableAccountEntry = Omit<ReadonlyAccountLookup | WritableAccountLookup, 'address'> & {\n    [TYPE]: AddressMapEntryType.LOOKUP_TABLE;\n};\nexport type OrderedAccounts = (IAccountLookupMeta | IAccountMeta)[] & { readonly __brand: unique symbol };\ntype StaticAccountEntry = Omit<\n    ReadonlyAccount | ReadonlySignerAccount | WritableAccount | WritableSignerAccount,\n    'address'\n> & { [TYPE]: AddressMapEntryType.STATIC };\n\nfunction upsert(\n    addressMap: AddressMap,\n    address: Address,\n    update: (\n        entry: FeePayerAccountEntry | LookupTableAccountEntry | Record<never, never> | StaticAccountEntry,\n    ) => AddressMap[Address],\n) {\n    addressMap[address] = update(addressMap[address] ?? { role: AccountRole.READONLY });\n}\n\nconst TYPE = Symbol('AddressMapTypeProperty');\nexport const ADDRESS_MAP_TYPE_PROPERTY: typeof TYPE = TYPE;\n\nexport function getAddressMapFromInstructions(feePayer: Address, instructions: readonly IInstruction[]): AddressMap {\n    const addressMap: AddressMap = {\n        [feePayer]: { [TYPE]: AddressMapEntryType.FEE_PAYER, role: AccountRole.WRITABLE_SIGNER },\n    };\n    const addressesOfInvokedPrograms = new Set<Address>();\n    for (const instruction of instructions) {\n        upsert(addressMap, instruction.programAddress, entry => {\n            addressesOfInvokedPrograms.add(instruction.programAddress);\n            if (TYPE in entry) {\n                if (isWritableRole(entry.role)) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, {\n                                programAddress: instruction.programAddress,\n                            });\n                        default:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, {\n                                programAddress: instruction.programAddress,\n                            });\n                    }\n                }\n                if (entry[TYPE] === AddressMapEntryType.STATIC) {\n                    return entry;\n                }\n            }\n            return { [TYPE]: AddressMapEntryType.STATIC, role: AccountRole.READONLY };\n        });\n        let addressComparator: ReturnType<typeof getAddressComparator>;\n        if (!instruction.accounts) {\n            continue;\n        }\n        for (const account of instruction.accounts) {\n            upsert(addressMap, account.address, entry => {\n                const {\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    address: _,\n                    ...accountMeta\n                } = account;\n                if (TYPE in entry) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            // The fee payer already has the highest rank -- it is by definition\n                            // writable-signer. Return it, no matter how `account` is configured\n                            return entry as FeePayerAccountEntry;\n                        case AddressMapEntryType.LOOKUP_TABLE: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if ('lookupTableAddress' in accountMeta) {\n                                const shouldReplaceEntry =\n                                    // Consider using the new LOOKUP_TABLE if its address is different...\n                                    entry.lookupTableAddress !== accountMeta.lookupTableAddress &&\n                                    // ...and sorts before the existing one.\n                                    (addressComparator ||= getAddressComparator())(\n                                        accountMeta.lookupTableAddress,\n                                        entry.lookupTableAddress,\n                                    ) < 0;\n                                if (shouldReplaceEntry) {\n                                    return {\n                                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                        ...accountMeta,\n                                        role: nextRole,\n                                    } as LookupTableAccountEntry;\n                                }\n                            } else if (isSignerRole(accountMeta.role)) {\n                                // Upgrade this LOOKUP_TABLE entry to a static entry if it must sign.\n                                return {\n                                    [TYPE]: AddressMapEntryType.STATIC,\n                                    role: nextRole,\n                                } as StaticAccountEntry;\n                            }\n                            if (entry.role !== nextRole) {\n                                return {\n                                    ...entry,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                return entry as LookupTableAccountEntry;\n                            }\n                        }\n                        case AddressMapEntryType.STATIC: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if (\n                                // Check to see if this address represents a program that is invoked\n                                // in this transaction.\n                                addressesOfInvokedPrograms.has(account.address)\n                            ) {\n                                if (isWritableRole(accountMeta.role)) {\n                                    throw new SolanaError(\n                                        SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n                                        {\n                                            programAddress: account.address,\n                                        },\n                                    );\n                                }\n                                if (entry.role !== nextRole) {\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry as StaticAccountEntry;\n                                }\n                            } else if (\n                                'lookupTableAddress' in accountMeta &&\n                                // Static accounts can be 'upgraded' to lookup table accounts as\n                                // long as they are not require to sign the transaction.\n                                !isSignerRole(entry.role)\n                            ) {\n                                return {\n                                    ...accountMeta,\n                                    [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                if (entry.role !== nextRole) {\n                                    // The account's role ranks higher than the current entry's.\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry as StaticAccountEntry;\n                                }\n                            }\n                        }\n                    }\n                }\n                if ('lookupTableAddress' in accountMeta) {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                    };\n                } else {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.STATIC,\n                    };\n                }\n            });\n        }\n    }\n    return addressMap;\n}\n\nexport function getOrderedAccountsFromAddressMap(addressMap: AddressMap): OrderedAccounts {\n    let addressComparator: ReturnType<typeof getAddressComparator>;\n    const orderedAccounts: (IAccountLookupMeta | IAccountMeta)[] = Object.entries(addressMap)\n        .sort(([leftAddress, leftEntry], [rightAddress, rightEntry]) => {\n            // STEP 1: Rapid precedence check. Fee payer, then static addresses, then lookups.\n            if (leftEntry[TYPE] !== rightEntry[TYPE]) {\n                if (leftEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return 1;\n                } else if (leftEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return 1;\n                }\n            }\n            // STEP 2: Sort by signer-writability.\n            const leftIsSigner = isSignerRole(leftEntry.role);\n            if (leftIsSigner !== isSignerRole(rightEntry.role)) {\n                return leftIsSigner ? -1 : 1;\n            }\n            const leftIsWritable = isWritableRole(leftEntry.role);\n            if (leftIsWritable !== isWritableRole(rightEntry.role)) {\n                return leftIsWritable ? -1 : 1;\n            }\n            // STEP 3: Sort by address.\n            addressComparator ||= getAddressComparator();\n            if (\n                leftEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                rightEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                leftEntry.lookupTableAddress !== rightEntry.lookupTableAddress\n            ) {\n                return addressComparator(leftEntry.lookupTableAddress, rightEntry.lookupTableAddress);\n            } else {\n                return addressComparator(leftAddress, rightAddress);\n            }\n        })\n        .map(([address, addressMeta]) => ({\n            address: address as Address<typeof address>,\n            ...addressMeta,\n        }));\n    return orderedAccounts as unknown as OrderedAccounts;\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport { AccountRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from './accounts';\n\ntype AddressTableLookup = Readonly<{\n    lookupTableAddress: Address;\n    readableIndices: readonly number[];\n    writableIndices: readonly number[];\n}>;\n\nexport function getCompiledAddressTableLookups(orderedAccounts: OrderedAccounts): AddressTableLookup[] {\n    const index: Record<Address, { readonly readableIndices: number[]; readonly writableIndices: number[] }> = {};\n    for (const account of orderedAccounts) {\n        if (!('lookupTableAddress' in account)) {\n            continue;\n        }\n        const entry = (index[account.lookupTableAddress] ||= {\n            readableIndices: [],\n            writableIndices: [],\n        });\n        if (account.role === AccountRole.WRITABLE) {\n            entry.writableIndices.push(account.addressIndex);\n        } else {\n            entry.readableIndices.push(account.addressIndex);\n        }\n    }\n    return Object.keys(index)\n        .sort(getAddressComparator())\n        .map(lookupTableAddress => ({\n            lookupTableAddress: lookupTableAddress as Address,\n            ...index[lookupTableAddress as unknown as Address],\n        }));\n}\n","import { isSignerRole, isWritableRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from './accounts';\n\ntype MessageHeader = Readonly<{\n    numReadonlyNonSignerAccounts: number;\n    numReadonlySignerAccounts: number;\n    numSignerAccounts: number;\n}>;\n\nexport function getCompiledMessageHeader(orderedAccounts: OrderedAccounts): MessageHeader {\n    let numReadonlyNonSignerAccounts = 0;\n    let numReadonlySignerAccounts = 0;\n    let numSignerAccounts = 0;\n    for (const account of orderedAccounts) {\n        if ('lookupTableAddress' in account) {\n            break;\n        }\n        const accountIsWritable = isWritableRole(account.role);\n        if (isSignerRole(account.role)) {\n            numSignerAccounts++;\n            if (!accountIsWritable) {\n                numReadonlySignerAccounts++;\n            }\n        } else if (!accountIsWritable) {\n            numReadonlyNonSignerAccounts++;\n        }\n    }\n    return {\n        numReadonlyNonSignerAccounts,\n        numReadonlySignerAccounts,\n        numSignerAccounts,\n    };\n}\n","import { Address } from '@solana/addresses';\nimport { IInstruction } from '@solana/instructions';\n\nimport { OrderedAccounts } from './accounts';\n\ntype CompiledInstruction = Readonly<{\n    accountIndices?: number[];\n    data?: Uint8Array;\n    programAddressIndex: number;\n}>;\n\nfunction getAccountIndex(orderedAccounts: OrderedAccounts) {\n    const out: Record<Address, number> = {};\n    for (const [index, account] of orderedAccounts.entries()) {\n        out[account.address] = index;\n    }\n    return out;\n}\n\nexport function getCompiledInstructions(\n    instructions: readonly IInstruction[],\n    orderedAccounts: OrderedAccounts,\n): CompiledInstruction[] {\n    const accountIndex = getAccountIndex(orderedAccounts);\n    return instructions.map(({ accounts, data, programAddress }) => {\n        return {\n            programAddressIndex: accountIndex[programAddress],\n            ...(accounts ? { accountIndices: accounts.map(({ address }) => accountIndex[address]) } : null),\n            ...(data ? { data } : null),\n        };\n    });\n}\n","import { IDurableNonceTransaction, ITransactionWithBlockhashLifetime } from './index';\n\nexport function getCompiledLifetimeToken(\n    lifetimeConstraint: (IDurableNonceTransaction | ITransactionWithBlockhashLifetime)['lifetimeConstraint'],\n): string {\n    if ('nonce' in lifetimeConstraint) {\n        return lifetimeConstraint.nonce;\n    }\n    return lifetimeConstraint.blockhash;\n}\n","import { Address } from '@solana/addresses';\n\nimport { OrderedAccounts } from './accounts';\n\nexport function getCompiledStaticAccounts(orderedAccounts: OrderedAccounts): Address[] {\n    const firstLookupTableAccountIndex = orderedAccounts.findIndex(account => 'lookupTableAddress' in account);\n    const orderedStaticAccounts =\n        firstLookupTableAccountIndex === -1 ? orderedAccounts : orderedAccounts.slice(0, firstLookupTableAccountIndex);\n    return orderedStaticAccounts.map(({ address }) => address);\n}\n","import { getAddressMapFromInstructions, getOrderedAccountsFromAddressMap } from './accounts';\nimport { CompilableTransaction } from './compilable-transaction';\nimport { getCompiledAddressTableLookups } from './compile-address-table-lookups';\nimport { getCompiledMessageHeader } from './compile-header';\nimport { getCompiledInstructions } from './compile-instructions';\nimport { getCompiledLifetimeToken } from './compile-lifetime-token';\nimport { getCompiledStaticAccounts } from './compile-static-accounts';\n\ntype BaseCompiledMessage = Readonly<{\n    header: ReturnType<typeof getCompiledMessageHeader>;\n    instructions: ReturnType<typeof getCompiledInstructions>;\n    lifetimeToken: ReturnType<typeof getCompiledLifetimeToken>;\n    staticAccounts: ReturnType<typeof getCompiledStaticAccounts>;\n}>;\n\nexport type CompiledMessage = LegacyCompiledMessage | VersionedCompiledMessage;\n\ntype LegacyCompiledMessage = BaseCompiledMessage &\n    Readonly<{\n        version: 'legacy';\n    }>;\n\ntype VersionedCompiledMessage = BaseCompiledMessage &\n    Readonly<{\n        addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups>;\n        version: number;\n    }>;\n\nexport function compileMessage(\n    transaction: CompilableTransaction & Readonly<{ version: 'legacy' }>,\n): LegacyCompiledMessage;\nexport function compileMessage(transaction: CompilableTransaction): VersionedCompiledMessage;\nexport function compileMessage(transaction: CompilableTransaction): CompiledMessage {\n    const addressMap = getAddressMapFromInstructions(transaction.feePayer, transaction.instructions);\n    const orderedAccounts = getOrderedAccountsFromAddressMap(addressMap);\n    return {\n        ...(transaction.version !== 'legacy'\n            ? { addressTableLookups: getCompiledAddressTableLookups(orderedAccounts) }\n            : null),\n        header: getCompiledMessageHeader(orderedAccounts),\n        instructions: getCompiledInstructions(transaction.instructions, orderedAccounts),\n        lifetimeToken: getCompiledLifetimeToken(transaction.lifetimeConstraint),\n        staticAccounts: getCompiledStaticAccounts(orderedAccounts),\n        version: transaction.version,\n    };\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    createEncoder,\n    Decoder,\n    mapDecoder,\n    mapEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder } from '@solana/codecs-numbers';\nimport { getBase58Decoder, getBase58Encoder, getStringDecoder, getStringEncoder } from '@solana/codecs-strings';\n\nimport type { getCompiledAddressTableLookups } from '../compile-address-table-lookups';\nimport { CompiledMessage } from '../message';\nimport { getAddressTableLookupDecoder, getAddressTableLookupEncoder } from './address-table-lookup';\nimport { getMessageHeaderDecoder, getMessageHeaderEncoder } from './header';\nimport { getInstructionDecoder, getInstructionEncoder } from './instruction';\nimport { getTransactionVersionDecoder, getTransactionVersionEncoder } from './transaction-version';\n\nfunction getCompiledMessageLegacyEncoder(): VariableSizeEncoder<CompiledMessage> {\n    return getStructEncoder(getPreludeStructEncoderTuple()) as VariableSizeEncoder<CompiledMessage>;\n}\n\nfunction getCompiledMessageVersionedEncoder(): VariableSizeEncoder<CompiledMessage> {\n    return mapEncoder(\n        getStructEncoder([\n            ...getPreludeStructEncoderTuple(),\n            ['addressTableLookups', getAddressTableLookupArrayEncoder()],\n        ]) as VariableSizeEncoder<CompiledMessage>,\n        (value: CompiledMessage) => {\n            if (value.version === 'legacy') {\n                return value;\n            }\n            return {\n                ...value,\n                addressTableLookups: value.addressTableLookups ?? [],\n            } as Exclude<CompiledMessage, { readonly version: 'legacy' }>;\n        },\n    ) as VariableSizeEncoder<CompiledMessage>;\n}\n\nfunction getPreludeStructEncoderTuple() {\n    return [\n        ['version', getTransactionVersionEncoder()],\n        ['header', getMessageHeaderEncoder()],\n        ['staticAccounts', getArrayEncoder(getAddressEncoder(), { size: getShortU16Encoder() })],\n        ['lifetimeToken', getStringEncoder({ encoding: getBase58Encoder(), size: 32 })],\n        ['instructions', getArrayEncoder(getInstructionEncoder(), { size: getShortU16Encoder() })],\n    ] as const;\n}\n\nfunction getPreludeStructDecoderTuple() {\n    return [\n        ['version', getTransactionVersionDecoder() as Decoder<number>],\n        ['header', getMessageHeaderDecoder()],\n        ['staticAccounts', getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() })],\n        ['lifetimeToken', getStringDecoder({ encoding: getBase58Decoder(), size: 32 })],\n        ['instructions', getArrayDecoder(getInstructionDecoder(), { size: getShortU16Decoder() })],\n        ['addressTableLookups', getAddressTableLookupArrayDecoder()],\n    ] as const;\n}\n\nfunction getAddressTableLookupArrayEncoder() {\n    return getArrayEncoder(getAddressTableLookupEncoder(), { size: getShortU16Encoder() });\n}\n\nfunction getAddressTableLookupArrayDecoder() {\n    return getArrayDecoder(getAddressTableLookupDecoder(), { size: getShortU16Decoder() });\n}\n\nexport function getCompiledMessageEncoder(): VariableSizeEncoder<CompiledMessage> {\n    return createEncoder({\n        getSizeFromValue: (compiledMessage: CompiledMessage) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().getSizeFromValue(compiledMessage);\n            } else {\n                return getCompiledMessageVersionedEncoder().getSizeFromValue(compiledMessage);\n            }\n        },\n        write: (compiledMessage, bytes, offset) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().write(compiledMessage, bytes, offset);\n            } else {\n                return getCompiledMessageVersionedEncoder().write(compiledMessage, bytes, offset);\n            }\n        },\n    });\n}\n\nexport function getCompiledMessageDecoder(): VariableSizeDecoder<CompiledMessage> {\n    return mapDecoder(\n        getStructDecoder(getPreludeStructDecoderTuple()) as VariableSizeDecoder<\n            CompiledMessage & { addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups> }\n        >,\n        ({ addressTableLookups, ...restOfMessage }) => {\n            if (restOfMessage.version === 'legacy' || !addressTableLookups?.length) {\n                return restOfMessage;\n            }\n            return { ...restOfMessage, addressTableLookups } as Exclude<\n                CompiledMessage,\n                { readonly version: 'legacy' }\n            >;\n        },\n    );\n}\n\nexport function getCompiledMessageCodec(): VariableSizeCodec<CompiledMessage> {\n    return combineCodec(getCompiledMessageEncoder(), getCompiledMessageDecoder());\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    type Encoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport type { getCompiledAddressTableLookups } from '../compile-address-table-lookups';\n\ntype AddressTableLookup = ReturnType<typeof getCompiledAddressTableLookups>[number];\n\nlet memoizedAddressTableLookupEncoder: VariableSizeEncoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupEncoder(): VariableSizeEncoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupEncoder) {\n        memoizedAddressTableLookupEncoder = getStructEncoder([\n            ['lookupTableAddress', getAddressEncoder()],\n            [\n                'writableIndices',\n                getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() }) as Encoder<readonly number[]>,\n            ],\n            [\n                'readableIndices',\n                getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() }) as Encoder<readonly number[]>,\n            ],\n        ]);\n    }\n\n    return memoizedAddressTableLookupEncoder;\n}\n\nlet memoizedAddressTableLookupDecoder: VariableSizeDecoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupDecoder(): VariableSizeDecoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupDecoder) {\n        memoizedAddressTableLookupDecoder = getStructDecoder([\n            ['lookupTableAddress', getAddressDecoder()],\n            ['writableIndices', getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],\n            ['readableIndices', getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],\n        ]);\n    }\n\n    return memoizedAddressTableLookupDecoder;\n}\n\nexport function getAddressTableLookupCodec(): VariableSizeCodec<AddressTableLookup> {\n    return combineCodec(getAddressTableLookupEncoder(), getAddressTableLookupDecoder());\n}\n","import { FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport { getStructCodec, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getU8Codec, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledMessageHeader } from '../compile-header';\n\ntype MessageHeader = ReturnType<typeof getCompiledMessageHeader>;\n\nlet memoizedU8Encoder: FixedSizeEncoder<number, 1> | undefined;\nfunction getMemoizedU8Encoder(): FixedSizeEncoder<number, 1> {\n    if (!memoizedU8Encoder) memoizedU8Encoder = getU8Encoder();\n    return memoizedU8Encoder;\n}\n\nlet memoizedU8Decoder: FixedSizeDecoder<number, 1> | undefined;\nfunction getMemoizedU8Decoder(): FixedSizeDecoder<number, 1> {\n    if (!memoizedU8Decoder) memoizedU8Decoder = getU8Decoder();\n    return memoizedU8Decoder;\n}\n\nlet memoizedU8Codec: FixedSizeCodec<number, number, 1> | undefined;\nfunction getMemoizedU8Codec(): FixedSizeCodec<number, number, 1> {\n    if (!memoizedU8Codec) memoizedU8Codec = getU8Codec();\n    return memoizedU8Codec;\n}\n\nexport function getMessageHeaderEncoder(): FixedSizeEncoder<MessageHeader, 3> {\n    return getStructEncoder([\n        ['numSignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Encoder()],\n    ]) as FixedSizeEncoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderDecoder(): FixedSizeDecoder<MessageHeader, 3> {\n    return getStructDecoder([\n        ['numSignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Decoder()],\n    ]) as FixedSizeDecoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderCodec(): FixedSizeCodec<MessageHeader, MessageHeader, 3> {\n    return getStructCodec([\n        ['numSignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlySignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Codec()],\n    ]) as FixedSizeCodec<MessageHeader, MessageHeader, 3>;\n}\n","import {\n    combineCodec,\n    mapDecoder,\n    mapEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledInstructions } from '../compile-instructions';\n\ntype Instruction = ReturnType<typeof getCompiledInstructions>[number];\n\nlet memoizedGetInstructionEncoder: VariableSizeEncoder<Instruction> | undefined;\nexport function getInstructionEncoder(): VariableSizeEncoder<Instruction> {\n    if (!memoizedGetInstructionEncoder) {\n        memoizedGetInstructionEncoder = mapEncoder<Required<Instruction>, Instruction>(\n            getStructEncoder([\n                ['programAddressIndex', getU8Encoder()],\n                ['accountIndices', getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() })],\n                ['data', getBytesEncoder({ size: getShortU16Encoder() })],\n            ]),\n            // Convert an instruction to have all fields defined\n            (instruction: Instruction): Required<Instruction> => {\n                if (instruction.accountIndices !== undefined && instruction.data !== undefined) {\n                    return instruction as Required<Instruction>;\n                }\n                return {\n                    ...instruction,\n                    accountIndices: instruction.accountIndices ?? [],\n                    data: instruction.data ?? new Uint8Array(0),\n                } as Required<Instruction>;\n            },\n        );\n    }\n\n    return memoizedGetInstructionEncoder;\n}\n\nlet memoizedGetInstructionDecoder: VariableSizeDecoder<Instruction> | undefined;\nexport function getInstructionDecoder(): VariableSizeDecoder<Instruction> {\n    if (!memoizedGetInstructionDecoder) {\n        memoizedGetInstructionDecoder = mapDecoder<Required<Instruction>, Instruction>(\n            getStructDecoder([\n                ['programAddressIndex', getU8Decoder()],\n                ['accountIndices', getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],\n                ['data', getBytesDecoder({ size: getShortU16Decoder() })],\n            ]),\n            // Convert an instruction to exclude optional fields if they are empty\n            (instruction: Required<Instruction>): Instruction => {\n                if (instruction.accountIndices.length && instruction.data.byteLength) {\n                    return instruction;\n                }\n                const { accountIndices, data, ...rest } = instruction;\n                return {\n                    ...rest,\n                    ...(accountIndices.length ? { accountIndices } : null),\n                    ...(data.byteLength ? { data } : null),\n                };\n            },\n        );\n    }\n    return memoizedGetInstructionDecoder;\n}\n\nexport function getInstructionCodec(): VariableSizeCodec<Instruction> {\n    return combineCodec(getInstructionEncoder(), getInstructionDecoder());\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nimport { TransactionVersion } from '../types';\n\nconst VERSION_FLAG_MASK = 0x80;\n\nexport function getTransactionVersionEncoder(): VariableSizeEncoder<TransactionVersion> {\n    return createEncoder({\n        getSizeFromValue: value => (value === 'legacy' ? 0 : 1),\n        maxSize: 1,\n        write: (value, bytes, offset) => {\n            if (value === 'legacy') {\n                return offset;\n            }\n            if (value < 0 || value > 127) {\n                throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, {\n                    actualVersion: value,\n                });\n            }\n            bytes.set([value | VERSION_FLAG_MASK], offset);\n            return offset + 1;\n        },\n    });\n}\n\nexport function getTransactionVersionDecoder(): VariableSizeDecoder<TransactionVersion> {\n    return createDecoder({\n        maxSize: 1,\n        read: (bytes, offset) => {\n            const firstByte = bytes[offset];\n            if ((firstByte & VERSION_FLAG_MASK) === 0) {\n                // No version flag set; it's a legacy (unversioned) transaction.\n                return ['legacy', offset];\n            } else {\n                const version = (firstByte ^ VERSION_FLAG_MASK) as TransactionVersion;\n                return [version, offset + 1];\n            }\n        },\n    });\n}\n\nexport function getTransactionVersionCodec(): VariableSizeCodec<TransactionVersion> {\n    return combineCodec(getTransactionVersionEncoder(), getTransactionVersionDecoder());\n}\n","import {\n    combineCodec,\n    FixedSizeDecoder,\n    mapDecoder,\n    mapEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder } from '@solana/codecs-numbers';\nimport { SignatureBytes } from '@solana/keys';\n\nimport { CompilableTransaction } from '../compilable-transaction';\nimport { CompiledTransaction, getCompiledTransaction } from '../compile-transaction';\nimport { decompileTransaction, DecompileTransactionConfig } from '../decompile-transaction';\nimport { ITransactionWithSignatures } from '../signatures';\nimport { getCompiledMessageDecoder, getCompiledMessageEncoder } from './message';\n\nfunction getCompiledTransactionEncoder(): VariableSizeEncoder<CompiledTransaction> {\n    return getStructEncoder([\n        ['signatures', getArrayEncoder(getBytesEncoder({ size: 64 }), { size: getShortU16Encoder() })],\n        ['compiledMessage', getCompiledMessageEncoder()],\n    ]);\n}\n\nexport function getCompiledTransactionDecoder(): VariableSizeDecoder<CompiledTransaction> {\n    return getStructDecoder([\n        [\n            'signatures',\n            getArrayDecoder(getBytesDecoder({ size: 64 }) as FixedSizeDecoder<SignatureBytes, 64>, {\n                size: getShortU16Decoder(),\n            }),\n        ],\n        ['compiledMessage', getCompiledMessageDecoder()],\n    ]);\n}\n\nexport function getTransactionEncoder(): VariableSizeEncoder<\n    CompilableTransaction | (CompilableTransaction & ITransactionWithSignatures)\n> {\n    return mapEncoder(getCompiledTransactionEncoder(), getCompiledTransaction);\n}\n\nexport function getTransactionDecoder(\n    config?: DecompileTransactionConfig,\n): VariableSizeDecoder<CompilableTransaction | (CompilableTransaction & ITransactionWithSignatures)> {\n    return mapDecoder(getCompiledTransactionDecoder(), compiledTransaction =>\n        decompileTransaction(compiledTransaction, config),\n    );\n}\n\nexport function getTransactionCodec(\n    config?: DecompileTransactionConfig,\n): VariableSizeCodec<CompilableTransaction | (CompilableTransaction & ITransactionWithSignatures)> {\n    return combineCodec(getTransactionEncoder(), getTransactionDecoder(config));\n}\n","import { SignatureBytes } from '@solana/keys';\n\nimport { CompilableTransaction } from './compilable-transaction';\nimport { CompiledMessage, compileMessage } from './message';\nimport { ITransactionWithSignatures } from './signatures';\n\nexport type CompiledTransaction = Readonly<{\n    compiledMessage: CompiledMessage;\n    signatures: SignatureBytes[];\n}>;\n\nexport function getCompiledTransaction(\n    transaction: CompilableTransaction | (CompilableTransaction & ITransactionWithSignatures),\n): CompiledTransaction {\n    const compiledMessage = compileMessage(transaction);\n    let signatures;\n    if ('signatures' in transaction) {\n        signatures = [];\n        for (let ii = 0; ii < compiledMessage.header.numSignerAccounts; ii++) {\n            signatures[ii] =\n                transaction.signatures[compiledMessage.staticAccounts[ii]] ?? new Uint8Array(Array(64).fill(0));\n        }\n    } else {\n        signatures = Array(compiledMessage.header.numSignerAccounts).fill(new Uint8Array(Array(64).fill(0)));\n    }\n    return {\n        compiledMessage,\n        signatures,\n    };\n}\n","import { Address, getAddressFromPublicKey } from '@solana/addresses';\nimport { Decoder } from '@solana/codecs-core';\nimport { getBase58Decoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { isSignerRole } from '@solana/instructions';\nimport { Signature, SignatureBytes, signBytes } from '@solana/keys';\n\nimport { CompilableTransaction } from './compilable-transaction';\nimport { ITransactionWithFeePayer } from './fee-payer';\nimport { compileMessage } from './message';\nimport { getCompiledMessageEncoder } from './serializers/message';\n\nexport interface IFullySignedTransaction extends ITransactionWithSignatures {\n    readonly __brand: unique symbol;\n}\nexport interface ITransactionWithSignatures {\n    readonly signatures: Readonly<Record<Address, SignatureBytes>>;\n}\n\nlet base58Decoder: Decoder<string> | undefined;\n\nexport function getSignatureFromTransaction(\n    transaction: ITransactionWithFeePayer & ITransactionWithSignatures,\n): Signature {\n    if (!base58Decoder) base58Decoder = getBase58Decoder();\n\n    const signatureBytes = transaction.signatures[transaction.feePayer];\n    if (!signatureBytes) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING);\n    }\n    const transactionSignature = base58Decoder.decode(signatureBytes);\n    return transactionSignature as Signature;\n}\n\nexport async function partiallySignTransaction<TTransaction extends CompilableTransaction>(\n    keyPairs: CryptoKeyPair[],\n    transaction: TTransaction | (ITransactionWithSignatures & TTransaction),\n): Promise<ITransactionWithSignatures & TTransaction> {\n    const compiledMessage = compileMessage(transaction);\n    const nextSignatures: Record<Address, SignatureBytes> =\n        'signatures' in transaction ? { ...transaction.signatures } : {};\n    const wireMessageBytes = getCompiledMessageEncoder().encode(compiledMessage);\n    const publicKeySignaturePairs = await Promise.all(\n        keyPairs.map(keyPair =>\n            Promise.all([getAddressFromPublicKey(keyPair.publicKey), signBytes(keyPair.privateKey, wireMessageBytes)]),\n        ),\n    );\n    for (const [signerPublicKey, signature] of publicKeySignaturePairs) {\n        nextSignatures[signerPublicKey] = signature;\n    }\n    const out = {\n        ...transaction,\n        signatures: nextSignatures,\n    };\n    Object.freeze(out);\n    return out;\n}\n\nexport async function signTransaction<TTransaction extends CompilableTransaction>(\n    keyPairs: CryptoKeyPair[],\n    transaction: TTransaction | (ITransactionWithSignatures & TTransaction),\n): Promise<IFullySignedTransaction & TTransaction> {\n    const out = await partiallySignTransaction(keyPairs, transaction);\n    assertTransactionIsFullySigned(out);\n    Object.freeze(out);\n    return out;\n}\n\nexport function assertTransactionIsFullySigned<TTransaction extends CompilableTransaction>(\n    transaction: ITransactionWithSignatures & TTransaction,\n): asserts transaction is IFullySignedTransaction & TTransaction {\n    const signerAddressesFromInstructions = transaction.instructions\n        .flatMap(i => i.accounts?.filter(a => isSignerRole(a.role)) ?? [])\n        .map(a => a.address);\n    const requiredSigners = new Set([transaction.feePayer, ...signerAddressesFromInstructions]);\n\n    const missingSigs: Address[] = [];\n    requiredSigners.forEach(address => {\n        if (!transaction.signatures[address]) {\n            missingSigs.push(address);\n        }\n    });\n\n    if (missingSigs.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING, {\n            addresses: missingSigs,\n        });\n    }\n}\n","import { getBase64Decoder } from '@solana/codecs-strings';\n\nimport { getTransactionEncoder } from './serializers/transaction';\n\nexport type Base64EncodedWireTransaction = string & {\n    readonly __brand: unique symbol;\n};\n\nexport function getBase64EncodedWireTransaction(\n    transaction: Parameters<ReturnType<typeof getTransactionEncoder>['encode']>[0],\n): Base64EncodedWireTransaction {\n    const wireTransactionBytes = getTransactionEncoder().encode(transaction);\n    return getBase64Decoder().decode(wireTransactionBytes) as Base64EncodedWireTransaction;\n}\n"]}