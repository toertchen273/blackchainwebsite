import { SolanaError, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST, getSolanaErrorFromJsonRpcError, SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID } from '@solana/errors';
import { createRpcMessage } from '@solana/rpc-spec-types';

// src/rpc-subscriptions.ts
function createSubscriptionRpc(rpcConfig) {
  return makeProxy(rpcConfig);
}
function makeProxy(rpcConfig) {
  return new Proxy(rpcConfig.api, {
    defineProperty() {
      return false;
    },
    deleteProperty() {
      return false;
    },
    get(target, p, receiver) {
      return function(...rawParams) {
        const notificationName = p.toString();
        const createRpcSubscription = Reflect.get(target, notificationName, receiver);
        if (p.toString().endsWith("Notifications") === false && !createRpcSubscription) {
          throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST, {
            notificationName
          });
        }
        const newRequest = createRpcSubscription ? createRpcSubscription(...rawParams) : {
          params: rawParams,
          subscribeMethodName: notificationName.replace(/Notifications$/, "Subscribe"),
          unsubscribeMethodName: notificationName.replace(/Notifications$/, "Unsubscribe")
        };
        return createPendingRpcSubscription(rpcConfig, newRequest);
      };
    }
  });
}
function registerIterableCleanup(iterable, cleanupFn) {
  (async () => {
    try {
      for await (const _ of iterable)
        ;
    } catch {
    } finally {
      cleanupFn();
    }
  })();
}
function createPendingRpcSubscription(rpcConfig, { params, subscribeMethodName, unsubscribeMethodName, responseTransformer }) {
  return {
    async subscribe({ abortSignal }) {
      abortSignal.throwIfAborted();
      let subscriptionId;
      function handleCleanup() {
        if (subscriptionId !== void 0) {
          const payload = createRpcMessage(unsubscribeMethodName, [subscriptionId]);
          connection.send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(payload).finally(() => {
            connectionAbortController.abort();
          });
        } else {
          connectionAbortController.abort();
        }
      }
      abortSignal.addEventListener("abort", handleCleanup);
      const connectionAbortController = new AbortController();
      const subscribeMessage = createRpcMessage(subscribeMethodName, params);
      const connection = await rpcConfig.transport({
        payload: subscribeMessage,
        signal: connectionAbortController.signal
      });
      function handleConnectionCleanup() {
        abortSignal.removeEventListener("abort", handleCleanup);
      }
      registerIterableCleanup(connection, handleConnectionCleanup);
      for await (const message of connection) {
        if ("id" in message && message.id === subscribeMessage.id) {
          if ("error" in message) {
            throw getSolanaErrorFromJsonRpcError(message.error);
          } else {
            subscriptionId = message.result;
            break;
          }
        }
      }
      if (subscriptionId == null) {
        throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID);
      }
      return {
        async *[Symbol.asyncIterator]() {
          for await (const message of connection) {
            if (!("params" in message) || message.params.subscription !== subscriptionId) {
              continue;
            }
            const notification = message.params.result;
            yield responseTransformer ? responseTransformer(notification, subscribeMethodName) : notification;
          }
        }
      };
    }
  };
}

// src/rpc-subscriptions-api.ts
function createRpcSubscriptionsApi(config) {
  return new Proxy({}, {
    defineProperty() {
      return false;
    },
    deleteProperty() {
      return false;
    },
    get(...args) {
      const [_, p] = args;
      const notificationName = p.toString();
      return function(...rawParams) {
        const params = config?.parametersTransformer ? config?.parametersTransformer(rawParams, notificationName) : rawParams;
        const responseTransformer = config?.responseTransformer ? config?.responseTransformer : (rawResponse) => rawResponse;
        const subscribeMethodName = config?.subscribeNotificationNameTransformer ? config?.subscribeNotificationNameTransformer(notificationName) : notificationName;
        const unsubscribeMethodName = config?.unsubscribeNotificationNameTransformer ? config?.unsubscribeNotificationNameTransformer(notificationName) : notificationName;
        return {
          params,
          responseTransformer,
          subscribeMethodName,
          unsubscribeMethodName
        };
      };
    }
  });
}

export { createRpcSubscriptionsApi, createSubscriptionRpc };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.native.js.map