{"version":3,"sources":["../src/confirmation-strategy-blockheight.ts","../src/confirmation-strategy-nonce.ts","../src/confirmation-strategy-recent-signature.ts","../src/confirmation-strategy-timeout.ts","../src/waiters.ts","../src/confirmation-strategy-racer.ts"],"names":["SolanaError","getTimeoutPromise"],"mappings":"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","sourcesContent":["import { SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED, SolanaError } from '@solana/errors';\nimport type { GetEpochInfoApi, Rpc } from '@solana/rpc';\nimport type { RpcSubscriptions, SlotNotificationsApi } from '@solana/rpc-subscriptions';\nimport type { Commitment } from '@solana/rpc-types';\n\ntype GetBlockHeightExceedencePromiseFn = (config: {\n    abortSignal: AbortSignal;\n    commitment?: Commitment;\n    lastValidBlockHeight: bigint;\n}) => Promise<void>;\n\nexport function createBlockHeightExceedencePromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: Readonly<{\n    rpc: Rpc<GetEpochInfoApi>;\n    rpcSubscriptions: RpcSubscriptions<SlotNotificationsApi>;\n}>): GetBlockHeightExceedencePromiseFn {\n    return async function getBlockHeightExceedencePromise({\n        abortSignal: callerAbortSignal,\n        commitment,\n        lastValidBlockHeight,\n    }) {\n        const abortController = new AbortController();\n        const handleAbort = () => {\n            abortController.abort();\n        };\n        callerAbortSignal.addEventListener('abort', handleAbort, { signal: abortController.signal });\n        async function getBlockHeightAndDifferenceBetweenSlotHeightAndBlockHeight() {\n            const { absoluteSlot, blockHeight } = await rpc\n                .getEpochInfo({ commitment })\n                .send({ abortSignal: abortController.signal });\n            return {\n                blockHeight,\n                differenceBetweenSlotHeightAndBlockHeight: absoluteSlot - blockHeight,\n            };\n        }\n        try {\n            const [slotNotifications, { blockHeight: initialBlockHeight, differenceBetweenSlotHeightAndBlockHeight }] =\n                await Promise.all([\n                    rpcSubscriptions.slotNotifications().subscribe({ abortSignal: abortController.signal }),\n                    getBlockHeightAndDifferenceBetweenSlotHeightAndBlockHeight(),\n                ]);\n            let currentBlockHeight = initialBlockHeight;\n            if (currentBlockHeight <= lastValidBlockHeight) {\n                let lastKnownDifferenceBetweenSlotHeightAndBlockHeight = differenceBetweenSlotHeightAndBlockHeight;\n                for await (const slotNotification of slotNotifications) {\n                    const { slot } = slotNotification;\n                    if (slot - lastKnownDifferenceBetweenSlotHeightAndBlockHeight > lastValidBlockHeight) {\n                        // Before making a final decision, recheck the actual block height.\n                        const {\n                            blockHeight: recheckedBlockHeight,\n                            differenceBetweenSlotHeightAndBlockHeight: currentDifferenceBetweenSlotHeightAndBlockHeight,\n                        } = await getBlockHeightAndDifferenceBetweenSlotHeightAndBlockHeight();\n                        currentBlockHeight = recheckedBlockHeight;\n                        if (currentBlockHeight > lastValidBlockHeight) {\n                            // Verfied; the block height has been exceeded.\n                            break;\n                        } else {\n                            // The block height has not been exceeded, which implies that the\n                            // difference between the slot height and the block height has grown\n                            // (ie. some blocks have been skipped since we started). Recalibrate the\n                            // difference and keep waiting.\n                            lastKnownDifferenceBetweenSlotHeightAndBlockHeight =\n                                currentDifferenceBetweenSlotHeightAndBlockHeight;\n                        }\n                    }\n                }\n            }\n            throw new SolanaError(SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED, {\n                currentBlockHeight,\n                lastValidBlockHeight,\n            });\n        } finally {\n            abortController.abort();\n        }\n    };\n}\n","import type { Address } from '@solana/addresses';\nimport { getBase58Decoder, getBase64Encoder } from '@solana/codecs-strings';\nimport { SOLANA_ERROR__INVALID_NONCE, SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND, SolanaError } from '@solana/errors';\nimport type { GetAccountInfoApi, Rpc } from '@solana/rpc';\nimport type { AccountNotificationsApi, RpcSubscriptions } from '@solana/rpc-subscriptions';\nimport type { Base64EncodedDataResponse, Commitment } from '@solana/rpc-types';\nimport type { Nonce } from '@solana/transactions';\n\ntype GetNonceInvalidationPromiseFn = (config: {\n    abortSignal: AbortSignal;\n    commitment: Commitment;\n    currentNonceValue: Nonce;\n    nonceAccountAddress: Address;\n}) => Promise<void>;\n\nconst NONCE_VALUE_OFFSET =\n    4 + // version(u32)\n    4 + // state(u32)\n    32; // nonce authority(pubkey)\n// Then comes the nonce value.\n\nexport function createNonceInvalidationPromiseFactory(\n    rpc: Rpc<GetAccountInfoApi>,\n    rpcSubscriptions: RpcSubscriptions<AccountNotificationsApi>,\n): GetNonceInvalidationPromiseFn {\n    return async function getNonceInvalidationPromise({\n        abortSignal: callerAbortSignal,\n        commitment,\n        currentNonceValue: expectedNonceValue,\n        nonceAccountAddress,\n    }) {\n        const abortController = new AbortController();\n        function handleAbort() {\n            abortController.abort();\n        }\n        callerAbortSignal.addEventListener('abort', handleAbort, { signal: abortController.signal });\n        /**\n         * STEP 1: Set up a subscription for nonce account changes.\n         */\n        const accountNotifications = await rpcSubscriptions\n            .accountNotifications(nonceAccountAddress, { commitment, encoding: 'base64' })\n            .subscribe({ abortSignal: abortController.signal });\n        const base58Decoder = getBase58Decoder();\n        const base64Encoder = getBase64Encoder();\n        function getNonceFromAccountData([base64EncodedBytes]: Base64EncodedDataResponse): Nonce {\n            const data = base64Encoder.encode(base64EncodedBytes);\n            const nonceValueBytes = data.slice(NONCE_VALUE_OFFSET, NONCE_VALUE_OFFSET + 32);\n            return base58Decoder.decode(nonceValueBytes) as Nonce;\n        }\n        const nonceAccountDidAdvancePromise = (async () => {\n            for await (const accountNotification of accountNotifications) {\n                const nonceValue = getNonceFromAccountData(accountNotification.value.data);\n                if (nonceValue !== expectedNonceValue) {\n                    throw new SolanaError(SOLANA_ERROR__INVALID_NONCE, {\n                        actualNonceValue: nonceValue,\n                        expectedNonceValue,\n                    });\n                }\n            }\n        })();\n        /**\n         * STEP 2: Having subscribed for updates, make a one-shot request for the current nonce\n         *         value to check if it has already been advanced.\n         */\n        const nonceIsAlreadyInvalidPromise = (async () => {\n            const { value: nonceAccount } = await rpc\n                .getAccountInfo(nonceAccountAddress, {\n                    commitment,\n                    dataSlice: { length: 32, offset: NONCE_VALUE_OFFSET },\n                    encoding: 'base58',\n                })\n                .send({ abortSignal: abortController.signal });\n            if (!nonceAccount) {\n                throw new SolanaError(SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND, {\n                    nonceAccountAddress,\n                });\n            }\n            const nonceValue =\n                // This works because we asked for the exact slice of data representing the nonce\n                // value, and furthermore asked for it in `base58` encoding.\n                nonceAccount.data[0] as unknown as Nonce;\n            if (nonceValue !== expectedNonceValue) {\n                throw new SolanaError(SOLANA_ERROR__INVALID_NONCE, {\n                    actualNonceValue: nonceValue,\n                    expectedNonceValue,\n                });\n            } else {\n                await new Promise(() => {\n                    /* never resolve */\n                });\n            }\n        })();\n        try {\n            return await Promise.race([nonceAccountDidAdvancePromise, nonceIsAlreadyInvalidPromise]);\n        } finally {\n            abortController.abort();\n        }\n    };\n}\n","import { getSolanaErrorFromTransactionError } from '@solana/errors';\nimport type { Signature } from '@solana/keys';\nimport type { GetSignatureStatusesApi, Rpc } from '@solana/rpc';\nimport type { RpcSubscriptions, SignatureNotificationsApi } from '@solana/rpc-subscriptions';\nimport { type Commitment, commitmentComparator } from '@solana/rpc-types';\n\ntype GetRecentSignatureConfirmationPromiseFn = (config: {\n    abortSignal: AbortSignal;\n    commitment: Commitment;\n    signature: Signature;\n}) => Promise<void>;\n\nexport function createRecentSignatureConfirmationPromiseFactory(\n    rpc: Rpc<GetSignatureStatusesApi>,\n    rpcSubscriptions: RpcSubscriptions<SignatureNotificationsApi>,\n): GetRecentSignatureConfirmationPromiseFn {\n    return async function getRecentSignatureConfirmationPromise({\n        abortSignal: callerAbortSignal,\n        commitment,\n        signature,\n    }) {\n        const abortController = new AbortController();\n        function handleAbort() {\n            abortController.abort();\n        }\n        callerAbortSignal.addEventListener('abort', handleAbort, { signal: abortController.signal });\n        /**\n         * STEP 1: Set up a subscription for status changes to a signature.\n         */\n        const signatureStatusNotifications = await rpcSubscriptions\n            .signatureNotifications(signature, { commitment })\n            .subscribe({ abortSignal: abortController.signal });\n        const signatureDidCommitPromise = (async () => {\n            for await (const signatureStatusNotification of signatureStatusNotifications) {\n                if (signatureStatusNotification.value.err) {\n                    throw getSolanaErrorFromTransactionError(signatureStatusNotification.value.err);\n                } else {\n                    return;\n                }\n            }\n        })();\n        /**\n         * STEP 2: Having subscribed for updates, make a one-shot request for the current status.\n         *         This will only yield a result if the signature is still in the status cache.\n         */\n        const signatureStatusLookupPromise = (async () => {\n            const { value: signatureStatusResults } = await rpc\n                .getSignatureStatuses([signature])\n                .send({ abortSignal: abortController.signal });\n            const signatureStatus = signatureStatusResults[0];\n            if (\n                signatureStatus &&\n                signatureStatus.confirmationStatus &&\n                commitmentComparator(signatureStatus.confirmationStatus, commitment) >= 0\n            ) {\n                return;\n            } else {\n                await new Promise(() => {\n                    /* never resolve */\n                });\n            }\n        })();\n        try {\n            return await Promise.race([signatureDidCommitPromise, signatureStatusLookupPromise]);\n        } finally {\n            abortController.abort();\n        }\n    };\n}\n","import type { Commitment } from '@solana/rpc-types';\n\ntype Config = Readonly<{\n    abortSignal: AbortSignal;\n    commitment: Commitment;\n}>;\n\nexport async function getTimeoutPromise({ abortSignal: callerAbortSignal, commitment }: Config) {\n    return await new Promise((_, reject) => {\n        const handleAbort = (e: AbortSignalEventMap['abort']) => {\n            clearTimeout(timeoutId);\n            const abortError = new DOMException((e.target as AbortSignal).reason, 'AbortError');\n            reject(abortError);\n        };\n        callerAbortSignal.addEventListener('abort', handleAbort);\n        const timeoutMs = commitment === 'processed' ? 30_000 : 60_000;\n        const startMs = performance.now();\n        const timeoutId =\n            // We use `setTimeout` instead of `AbortSignal.timeout()` because we want to measure\n            // elapsed time instead of active time.\n            // See https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/timeout_static\n            setTimeout(() => {\n                const elapsedMs = performance.now() - startMs;\n                reject(new DOMException(`Timeout elapsed after ${elapsedMs} ms`, 'TimeoutError'));\n            }, timeoutMs);\n    });\n}\n","import { Signature } from '@solana/keys';\nimport type { Slot } from '@solana/rpc-types';\nimport {\n    getSignatureFromTransaction,\n    IDurableNonceTransaction,\n    ITransactionWithFeePayer,\n    ITransactionWithSignatures,\n} from '@solana/transactions';\n\nimport { createBlockHeightExceedencePromiseFactory } from './confirmation-strategy-blockheight';\nimport { createNonceInvalidationPromiseFactory } from './confirmation-strategy-nonce';\nimport { BaseTransactionConfirmationStrategyConfig, raceStrategies } from './confirmation-strategy-racer';\nimport { getTimeoutPromise } from './confirmation-strategy-timeout';\n\ninterface WaitForDurableNonceTransactionConfirmationConfig extends BaseTransactionConfirmationStrategyConfig {\n    getNonceInvalidationPromise: ReturnType<typeof createNonceInvalidationPromiseFactory>;\n    transaction: IDurableNonceTransaction & ITransactionWithFeePayer & ITransactionWithSignatures;\n}\n\ninterface WaitForRecentTransactionWithBlockhashLifetimeConfirmationConfig\n    extends BaseTransactionConfirmationStrategyConfig {\n    getBlockHeightExceedencePromise: ReturnType<typeof createBlockHeightExceedencePromiseFactory>;\n    transaction: ITransactionWithFeePayer &\n        ITransactionWithSignatures &\n        Readonly<{\n            lifetimeConstraint: {\n                lastValidBlockHeight: Slot;\n            };\n        }>;\n}\n\ninterface WaitForRecentTransactionWithTimeBasedLifetimeConfirmationConfig\n    extends BaseTransactionConfirmationStrategyConfig {\n    getTimeoutPromise: typeof getTimeoutPromise;\n    signature: Signature;\n}\n\nexport async function waitForDurableNonceTransactionConfirmation(\n    config: WaitForDurableNonceTransactionConfirmationConfig,\n): Promise<void> {\n    await raceStrategies(\n        getSignatureFromTransaction(config.transaction),\n        config,\n        function getSpecificStrategiesForRace({ abortSignal, commitment, getNonceInvalidationPromise, transaction }) {\n            return [\n                getNonceInvalidationPromise({\n                    abortSignal,\n                    commitment,\n                    currentNonceValue: transaction.lifetimeConstraint.nonce,\n                    nonceAccountAddress: transaction.instructions[0].accounts[0].address,\n                }),\n            ];\n        },\n    );\n}\n\nexport async function waitForRecentTransactionConfirmation(\n    config: WaitForRecentTransactionWithBlockhashLifetimeConfirmationConfig,\n): Promise<void> {\n    await raceStrategies(\n        getSignatureFromTransaction(config.transaction),\n        config,\n        function getSpecificStrategiesForRace({\n            abortSignal,\n            commitment,\n            getBlockHeightExceedencePromise,\n            transaction,\n        }) {\n            return [\n                getBlockHeightExceedencePromise({\n                    abortSignal,\n                    commitment,\n                    lastValidBlockHeight: transaction.lifetimeConstraint.lastValidBlockHeight,\n                }),\n            ];\n        },\n    );\n}\n\n/** @deprecated */\nexport async function waitForRecentTransactionConfirmationUntilTimeout(\n    config: WaitForRecentTransactionWithTimeBasedLifetimeConfirmationConfig,\n): Promise<void> {\n    await raceStrategies(\n        config.signature,\n        config,\n        function getSpecificStrategiesForRace({ abortSignal, commitment, getTimeoutPromise }) {\n            return [\n                getTimeoutPromise({\n                    abortSignal,\n                    commitment,\n                }),\n            ];\n        },\n    );\n}\n","import type { Signature } from '@solana/keys';\nimport type { Commitment } from '@solana/rpc-types';\n\nimport { createRecentSignatureConfirmationPromiseFactory } from './confirmation-strategy-recent-signature';\n\nexport interface BaseTransactionConfirmationStrategyConfig {\n    abortSignal?: AbortSignal;\n    commitment: Commitment;\n    getRecentSignatureConfirmationPromise: ReturnType<typeof createRecentSignatureConfirmationPromiseFactory>;\n}\n\ntype WithNonNullableAbortSignal<T> = Omit<T, 'abortSignal'> & Readonly<{ abortSignal: AbortSignal }>;\n\nexport async function raceStrategies<TConfig extends BaseTransactionConfirmationStrategyConfig>(\n    signature: Signature,\n    config: TConfig,\n    getSpecificStrategiesForRace: (config: WithNonNullableAbortSignal<TConfig>) => readonly Promise<unknown>[],\n) {\n    const { abortSignal: callerAbortSignal, commitment, getRecentSignatureConfirmationPromise } = config;\n    callerAbortSignal?.throwIfAborted();\n    const abortController = new AbortController();\n    if (callerAbortSignal) {\n        const handleAbort = () => {\n            abortController.abort();\n        };\n        callerAbortSignal.addEventListener('abort', handleAbort, { signal: abortController.signal });\n    }\n    try {\n        const specificStrategies = getSpecificStrategiesForRace({\n            ...config,\n            abortSignal: abortController.signal,\n        });\n        return await Promise.race([\n            getRecentSignatureConfirmationPromise({\n                abortSignal: abortController.signal,\n                commitment,\n                signature,\n            }),\n            ...specificStrategies,\n        ]);\n    } finally {\n        abortController.abort();\n    }\n}\n"]}