{"version":3,"sources":["../src/rpc.ts","../src/rpc-api.ts"],"names":[],"mappings":";AAAA,SAAS,sCAAsC;AAC/C;AAAA,EAEI;AAAA,OAKG;AA2BA,SAAS,UACZ,WACgB;AAChB,SAAO,UAAU,SAAS;AAC9B;AAEA,SAAS,UACL,WACgB;AAChB,SAAO,IAAI,MAAM,UAAU,KAAK;AAAA,IAC5B,iBAAiB;AACb,aAAO;AAAA,IACX;AAAA,IACA,iBAAiB;AACb,aAAO;AAAA,IACX;AAAA,IACA,IAAI,QAAQ,GAAG,UAAU;AACrB,aAAO,YAAa,WAAsB;AACtC,cAAM,aAAa,EAAE,SAAS;AAC9B,cAAM,mBAAmB,QAAQ,IAAI,QAAQ,YAAY,QAAQ;AACjE,cAAM,aAAa,mBACb,iBAAiB,GAAG,SAAS,IAC7B,EAAE,YAAY,QAAQ,UAAU;AACtC,eAAO,wBAAwB,WAAW,UAAU;AAAA,MACxD;AAAA,IACJ;AAAA,EACJ,CAAC;AACL;AAEA,SAAS,wBACL,WACA,gBAC4B;AAC5B,SAAO;AAAA,IACH,MAAM,KAAK,SAA8C;AACrD,YAAM,EAAE,YAAY,QAAQ,oBAAoB,IAAI;AACpD,YAAM,UAAU,iBAAiB,YAAY,MAAM;AACnD,YAAM,WAAW,MAAM,UAAU,UAAgC;AAAA,QAC7D;AAAA,QACA,QAAQ,SAAS;AAAA,MACrB,CAAC;AACD,UAAI,WAAW,UAAU;AACrB,cAAM,+BAA+B,SAAS,KAAK;AAAA,MACvD;AACA,aACI,sBAAsB,oBAAoB,SAAS,QAAQ,UAAU,IAAI,SAAS;AAAA,IAE1F;AAAA,EACJ;AACJ;;;AC7DO,SAAS,aAAgD,QAA4C;AACxG,SAAO,IAAI,MAAM,CAAC,GAA0B;AAAA,IACxC,iBAAiB;AACb,aAAO;AAAA,IACX;AAAA,IACA,iBAAiB;AACb,aAAO;AAAA,IACX;AAAA,IACA,OACO,MACL;AACE,YAAM,CAAC,GAAG,CAAC,IAAI;AACf,YAAM,aAAa,EAAE,SAAS;AAC9B,aAAO,YACA,WAG6C;AAChD,cAAM,SAAS,QAAQ,wBACjB,QAAQ,sBAAsB,WAAW,UAAU,IACnD;AACN,cAAM,sBAAsB,QAAQ,sBAC9B,QAAQ,sBACR,CAAC,gBAAyB;AAChC,eAAO;AAAA,UACH;AAAA,UACA;AAAA,UACA;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ,CAAC;AACL","sourcesContent":["import { getSolanaErrorFromJsonRpcError } from '@solana/errors';\nimport {\n    Callable,\n    createRpcMessage,\n    Flatten,\n    OverloadImplementations,\n    RpcResponse,\n    UnionToIntersection,\n} from '@solana/rpc-spec-types';\n\nimport { RpcApi } from './rpc-api';\nimport { PendingRpcRequest, RpcRequest, RpcSendOptions } from './rpc-request';\nimport { RpcTransport } from './rpc-transport';\n\nexport type RpcConfig<TRpcMethods, TRpcTransport extends RpcTransport> = Readonly<{\n    api: RpcApi<TRpcMethods>;\n    transport: TRpcTransport;\n}>;\n\nexport type Rpc<TRpcMethods> = {\n    [TMethodName in keyof TRpcMethods]: PendingRpcRequestBuilder<OverloadImplementations<TRpcMethods, TMethodName>>;\n};\n\ntype PendingRpcRequestBuilder<TMethodImplementations> = UnionToIntersection<\n    Flatten<{\n        [P in keyof TMethodImplementations]: PendingRpcRequestReturnTypeMapper<TMethodImplementations[P]>;\n    }>\n>;\n\ntype PendingRpcRequestReturnTypeMapper<TMethodImplementation> =\n    // Check that this property of the TRpcMethods interface is, in fact, a function.\n    TMethodImplementation extends Callable\n        ? (...args: Parameters<TMethodImplementation>) => PendingRpcRequest<ReturnType<TMethodImplementation>>\n        : never;\n\nexport function createRpc<TRpcMethods, TRpcTransport extends RpcTransport>(\n    rpcConfig: RpcConfig<TRpcMethods, TRpcTransport>,\n): Rpc<TRpcMethods> {\n    return makeProxy(rpcConfig) as Rpc<TRpcMethods>;\n}\n\nfunction makeProxy<TRpcMethods, TRpcTransport extends RpcTransport>(\n    rpcConfig: RpcConfig<TRpcMethods, TRpcTransport>,\n): Rpc<TRpcMethods> {\n    return new Proxy(rpcConfig.api, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get(target, p, receiver) {\n            return function (...rawParams: unknown[]) {\n                const methodName = p.toString();\n                const createRpcRequest = Reflect.get(target, methodName, receiver);\n                const newRequest = createRpcRequest\n                    ? createRpcRequest(...rawParams)\n                    : { methodName, params: rawParams };\n                return createPendingRpcRequest(rpcConfig, newRequest);\n            };\n        },\n    }) as Rpc<TRpcMethods>;\n}\n\nfunction createPendingRpcRequest<TRpcMethods, TRpcTransport extends RpcTransport, TResponse>(\n    rpcConfig: RpcConfig<TRpcMethods, TRpcTransport>,\n    pendingRequest: RpcRequest<TResponse>,\n): PendingRpcRequest<TResponse> {\n    return {\n        async send(options?: RpcSendOptions): Promise<TResponse> {\n            const { methodName, params, responseTransformer } = pendingRequest;\n            const payload = createRpcMessage(methodName, params);\n            const response = await rpcConfig.transport<RpcResponse<unknown>>({\n                payload,\n                signal: options?.abortSignal,\n            });\n            if ('error' in response) {\n                throw getSolanaErrorFromJsonRpcError(response.error);\n            }\n            return (\n                responseTransformer ? responseTransformer(response.result, methodName) : response.result\n            ) as TResponse;\n        },\n    };\n}\n","import { Callable } from '@solana/rpc-spec-types';\n\nimport { RpcRequest } from './rpc-request';\n\nexport type RpcApiConfig = Readonly<{\n    parametersTransformer?: <T extends unknown[]>(params: T, methodName: string) => unknown[];\n    responseTransformer?: <T>(response: unknown, methodName: string) => T;\n}>;\n\nexport type RpcApi<TRpcMethods> = {\n    [MethodName in keyof TRpcMethods]: RpcReturnTypeMapper<TRpcMethods[MethodName]>;\n};\n\ntype RpcReturnTypeMapper<TRpcMethod> = TRpcMethod extends Callable\n    ? (...rawParams: unknown[]) => RpcRequest<ReturnType<TRpcMethod>>\n    : never;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RpcApiMethod = (...args: any) => any;\nexport interface RpcApiMethods {\n    [methodName: string]: RpcApiMethod;\n}\n\nexport function createRpcApi<TRpcMethods extends RpcApiMethods>(config?: RpcApiConfig): RpcApi<TRpcMethods> {\n    return new Proxy({} as RpcApi<TRpcMethods>, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get<TMethodName extends keyof RpcApi<TRpcMethods>>(\n            ...args: Parameters<NonNullable<ProxyHandler<RpcApi<TRpcMethods>>['get']>>\n        ) {\n            const [_, p] = args;\n            const methodName = p.toString() as keyof TRpcMethods as string;\n            return function (\n                ...rawParams: Parameters<\n                    TRpcMethods[TMethodName] extends CallableFunction ? TRpcMethods[TMethodName] : never\n                >\n            ): RpcRequest<ReturnType<TRpcMethods[TMethodName]>> {\n                const params = config?.parametersTransformer\n                    ? config?.parametersTransformer(rawParams, methodName)\n                    : rawParams;\n                const responseTransformer = config?.responseTransformer\n                    ? config?.responseTransformer<ReturnType<TRpcMethods[TMethodName]>>\n                    : (rawResponse: unknown) => rawResponse as ReturnType<TRpcMethods[TMethodName]>;\n                return {\n                    methodName,\n                    params,\n                    responseTransformer,\n                };\n            };\n        },\n    });\n}\n"]}