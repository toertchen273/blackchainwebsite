'use strict';

var errors = require('@solana/errors');

// ../build-scripts/env-shim.ts
var __DEV__ = /* @__PURE__ */ (() => process["env"].NODE_ENV === "development")();

// ../ws-impl/dist/index.browser.js
var e = globalThis.WebSocket;

// src/websocket-connection.ts
var EXPLICIT_ABORT_TOKEN = Symbol(
  __DEV__ ? "This symbol is thrown from a socket's iterator when the connection is explicitly aborted by the user" : void 0
);
async function createWebSocketConnection({
  sendBufferHighWatermark,
  signal,
  url
}) {
  return new Promise((resolve, reject) => {
    signal.addEventListener("abort", handleAbort, { once: true });
    const iteratorState = /* @__PURE__ */ new Map();
    function errorAndClearAllIteratorStates(reason) {
      const errorCallbacks = [...iteratorState.values()].filter((state) => state.__hasPolled).map(({ onError }) => onError);
      iteratorState.clear();
      errorCallbacks.forEach((cb) => {
        try {
          cb(reason);
        } catch {
        }
      });
    }
    function handleAbort() {
      errorAndClearAllIteratorStates(EXPLICIT_ABORT_TOKEN);
      if (webSocket.readyState !== e.CLOSED && webSocket.readyState !== e.CLOSING) {
        webSocket.close(1e3);
      }
    }
    function handleClose(ev) {
      bufferDrainWatcher?.onCancel();
      signal.removeEventListener("abort", handleAbort);
      webSocket.removeEventListener("close", handleClose);
      webSocket.removeEventListener("error", handleError);
      webSocket.removeEventListener("open", handleOpen);
      webSocket.removeEventListener("message", handleMessage);
      errorAndClearAllIteratorStates(ev);
    }
    function handleError(ev) {
      if (!hasConnected) {
        reject(
          new errors.SolanaError(errors.SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT, {
            errorEvent: ev
          })
        );
      }
    }
    let hasConnected = false;
    let bufferDrainWatcher;
    function handleOpen() {
      hasConnected = true;
      resolve({
        async send(payload) {
          const message = JSON.stringify(payload);
          if (!bufferDrainWatcher && webSocket.readyState === e.OPEN && webSocket.bufferedAmount > sendBufferHighWatermark) {
            let onCancel;
            const promise = new Promise((resolve2, reject2) => {
              const intervalId = setInterval(() => {
                if (webSocket.readyState !== e.OPEN || !(webSocket.bufferedAmount > sendBufferHighWatermark)) {
                  clearInterval(intervalId);
                  bufferDrainWatcher = void 0;
                  resolve2();
                }
              }, 16);
              onCancel = () => {
                bufferDrainWatcher = void 0;
                clearInterval(intervalId);
                reject2(
                  new errors.SolanaError(
                    errors.SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED
                  )
                );
              };
            });
            bufferDrainWatcher = {
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-ignore
              onCancel,
              promise
            };
          }
          if (bufferDrainWatcher) {
            await bufferDrainWatcher.promise;
          }
          webSocket.send(message);
        },
        async *[Symbol.asyncIterator]() {
          const iteratorKey = Symbol();
          iteratorState.set(iteratorKey, { __hasPolled: false, queuedMessages: [] });
          try {
            while (true) {
              const state = iteratorState.get(iteratorKey);
              if (!state) {
                throw new errors.SolanaError(
                  errors.SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING
                );
              }
              if (state.__hasPolled) {
                throw new errors.SolanaError(
                  errors.SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE
                );
              }
              const queuedMessages = state.queuedMessages;
              if (queuedMessages.length) {
                state.queuedMessages = [];
                yield* queuedMessages;
              } else {
                try {
                  yield await new Promise((resolve2, reject2) => {
                    iteratorState.set(iteratorKey, {
                      __hasPolled: true,
                      onError: reject2,
                      onMessage: resolve2
                    });
                  });
                } catch (e2) {
                  if (e2 === EXPLICIT_ABORT_TOKEN) {
                    return;
                  } else {
                    throw new errors.SolanaError(
                      errors.SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED,
                      {
                        cause: e2
                      }
                    );
                  }
                }
              }
            }
          } finally {
            iteratorState.delete(iteratorKey);
          }
        }
      });
    }
    function handleMessage({ data }) {
      const message = JSON.parse(data);
      iteratorState.forEach((state, iteratorKey) => {
        if (state.__hasPolled) {
          const { onMessage } = state;
          iteratorState.set(iteratorKey, { __hasPolled: false, queuedMessages: [] });
          onMessage(message);
        } else {
          state.queuedMessages.push(message);
        }
      });
    }
    const webSocket = new e(url);
    webSocket.addEventListener("close", handleClose);
    webSocket.addEventListener("error", handleError);
    webSocket.addEventListener("open", handleOpen);
    webSocket.addEventListener("message", handleMessage);
  });
}

// src/websocket-transport.ts
function createWebSocketTransport({ sendBufferHighWatermark, url }) {
  if (/^wss?:/i.test(url) === false) {
    const protocolMatch = url.match(/^([^:]+):/);
    throw new DOMException(
      protocolMatch ? `Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or 'wss'. '${protocolMatch[1]}:' is not allowed.` : `Failed to construct 'WebSocket': The URL '${url}' is invalid.`
    );
  }
  return async function sendWebSocketMessage({ payload, signal }) {
    signal?.throwIfAborted();
    const connection = await createWebSocketConnection({
      sendBufferHighWatermark,
      signal,
      url
    });
    signal?.throwIfAborted();
    await connection.send(payload);
    return {
      [Symbol.asyncIterator]: connection[Symbol.asyncIterator].bind(connection),
      send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: connection.send.bind(connection)
    };
  };
}

exports.createWebSocketTransport = createWebSocketTransport;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.browser.cjs.map