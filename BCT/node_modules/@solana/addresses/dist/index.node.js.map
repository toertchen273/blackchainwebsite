{"version":3,"sources":["../src/address.ts","../src/program-derived-address.ts","../src/vendor/noble/ed25519.ts","../src/curve.ts","../src/public-key.ts"],"names":["SolanaError","address"],"mappings":"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","sourcesContent":["import {\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    mapEncoder,\n} from '@solana/codecs-core';\nimport { getBase58Decoder, getBase58Encoder, getStringDecoder, getStringEncoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nexport type Address<TAddress extends string = string> = TAddress & {\n    readonly __brand: unique symbol;\n};\n\nlet memoizedBase58Encoder: Encoder<string> | undefined;\nlet memoizedBase58Decoder: Decoder<string> | undefined;\n\nfunction getMemoizedBase58Encoder(): Encoder<string> {\n    if (!memoizedBase58Encoder) memoizedBase58Encoder = getBase58Encoder();\n    return memoizedBase58Encoder;\n}\n\nfunction getMemoizedBase58Decoder(): Decoder<string> {\n    if (!memoizedBase58Decoder) memoizedBase58Decoder = getBase58Decoder();\n    return memoizedBase58Decoder;\n}\n\nexport function isAddress(putativeAddress: string): putativeAddress is Address<typeof putativeAddress> {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest address (32 bytes of zeroes)\n        putativeAddress.length < 32 ||\n        // Highest address (32 bytes of 255)\n        putativeAddress.length > 44\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeAddress);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        return false;\n    }\n    return true;\n}\n\nexport function assertIsAddress(putativeAddress: string): asserts putativeAddress is Address<typeof putativeAddress> {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest address (32 bytes of zeroes)\n        putativeAddress.length < 32 ||\n        // Highest address (32 bytes of 255)\n        putativeAddress.length > 44\n    ) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeAddress.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeAddress);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\nexport function address<TAddress extends string = string>(putativeAddress: TAddress): Address<TAddress> {\n    assertIsAddress(putativeAddress);\n    return putativeAddress as Address<TAddress>;\n}\n\nexport function getAddressEncoder(): FixedSizeEncoder<Address, 32> {\n    return mapEncoder(getStringEncoder({ encoding: getMemoizedBase58Encoder(), size: 32 }), putativeAddress =>\n        address(putativeAddress),\n    );\n}\n\nexport function getAddressDecoder(): FixedSizeDecoder<Address, 32> {\n    return getStringDecoder({ encoding: getMemoizedBase58Decoder(), size: 32 }) as FixedSizeDecoder<Address, 32>;\n}\n\nexport function getAddressCodec(): FixedSizeCodec<Address, Address, 32> {\n    return combineCodec(getAddressEncoder(), getAddressDecoder());\n}\n\nexport function getAddressComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n","import { assertDigestCapabilityIsAvailable } from '@solana/assertions';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,\n    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,\n    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,\n    SolanaError,\n} from '@solana/errors';\n\nimport { Address, assertIsAddress, getAddressCodec, isAddress } from './address';\nimport { compressedPointBytesAreOnCurve } from './curve';\n\n/**\n * An address derived from a program address and a set of seeds.\n * It includes the bump seed used to derive the address and\n * ensure the address is not on the Ed25519 curve.\n */\nexport type ProgramDerivedAddress<TAddress extends string = string> = Readonly<\n    [Address<TAddress>, ProgramDerivedAddressBump]\n>;\n\n/**\n * A number between 0 and 255, inclusive.\n */\nexport type ProgramDerivedAddressBump = number & {\n    readonly __brand: unique symbol;\n};\n\n/**\n * Returns true if the input value is a program derived address.\n */\nexport function isProgramDerivedAddress<TAddress extends string = string>(\n    value: unknown,\n): value is ProgramDerivedAddress<TAddress> {\n    return (\n        Array.isArray(value) &&\n        value.length === 2 &&\n        typeof value[0] === 'string' &&\n        typeof value[1] === 'number' &&\n        value[1] >= 0 &&\n        value[1] <= 255 &&\n        isAddress(value[0])\n    );\n}\n\n/**\n * Fails if the input value is not a program derived address.\n */\nexport function assertIsProgramDerivedAddress<TAddress extends string = string>(\n    value: unknown,\n): asserts value is ProgramDerivedAddress<TAddress> {\n    const validFormat =\n        Array.isArray(value) && value.length === 2 && typeof value[0] === 'string' && typeof value[1] === 'number';\n    if (!validFormat) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MALFORMED_PDA);\n    }\n    if (value[1] < 0 || value[1] > 255) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE, {\n            bump: value[1],\n        });\n    }\n    assertIsAddress(value[0]);\n}\n\ntype ProgramDerivedAddressInput = Readonly<{\n    programAddress: Address;\n    seeds: Seed[];\n}>;\n\ntype SeedInput = Readonly<{\n    baseAddress: Address;\n    programAddress: Address;\n    seed: Seed;\n}>;\n\ntype Seed = Uint8Array | string;\n\nconst MAX_SEED_LENGTH = 32;\nconst MAX_SEEDS = 16;\nconst PDA_MARKER_BYTES = [\n    // The string 'ProgramDerivedAddress'\n    80, 114, 111, 103, 114, 97, 109, 68, 101, 114, 105, 118, 101, 100, 65, 100, 100, 114, 101, 115, 115,\n] as const;\n\nasync function createProgramDerivedAddress({ programAddress, seeds }: ProgramDerivedAddressInput): Promise<Address> {\n    await assertDigestCapabilityIsAvailable();\n    if (seeds.length > MAX_SEEDS) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED, {\n            actual: seeds.length,\n            maxSeeds: MAX_SEEDS,\n        });\n    }\n    let textEncoder: TextEncoder;\n    const seedBytes = seeds.reduce((acc, seed, ii) => {\n        const bytes = typeof seed === 'string' ? (textEncoder ||= new TextEncoder()).encode(seed) : seed;\n        if (bytes.byteLength > MAX_SEED_LENGTH) {\n            throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n                actual: bytes.byteLength,\n                index: ii,\n                maxSeedLength: MAX_SEED_LENGTH,\n            });\n        }\n        acc.push(...bytes);\n        return acc;\n    }, [] as number[]);\n    const base58EncodedAddressCodec = getAddressCodec();\n    const programAddressBytes = base58EncodedAddressCodec.encode(programAddress);\n    const addressBytesBuffer = await crypto.subtle.digest(\n        'SHA-256',\n        new Uint8Array([...seedBytes, ...programAddressBytes, ...PDA_MARKER_BYTES]),\n    );\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n    if (await compressedPointBytesAreOnCurve(addressBytes)) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE);\n    }\n    return base58EncodedAddressCodec.decode(addressBytes);\n}\n\nexport async function getProgramDerivedAddress({\n    programAddress,\n    seeds,\n}: ProgramDerivedAddressInput): Promise<ProgramDerivedAddress> {\n    let bumpSeed = 255;\n    while (bumpSeed > 0) {\n        try {\n            const address = await createProgramDerivedAddress({\n                programAddress,\n                seeds: [...seeds, new Uint8Array([bumpSeed])],\n            });\n            return [address, bumpSeed as ProgramDerivedAddressBump];\n        } catch (e) {\n            if (isSolanaError(e, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE)) {\n                bumpSeed--;\n            } else {\n                throw e;\n            }\n        }\n    }\n    throw new SolanaError(SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED);\n}\n\nexport async function createAddressWithSeed({ baseAddress, programAddress, seed }: SeedInput): Promise<Address> {\n    const { encode, decode } = getAddressCodec();\n\n    const seedBytes = typeof seed === 'string' ? new TextEncoder().encode(seed) : seed;\n    if (seedBytes.byteLength > MAX_SEED_LENGTH) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n            actual: seedBytes.byteLength,\n            index: 0,\n            maxSeedLength: MAX_SEED_LENGTH,\n        });\n    }\n\n    const programAddressBytes = encode(programAddress);\n    if (\n        programAddressBytes.length >= PDA_MARKER_BYTES.length &&\n        programAddressBytes.slice(-PDA_MARKER_BYTES.length).every((byte, index) => byte === PDA_MARKER_BYTES[index])\n    ) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER);\n    }\n\n    const addressBytesBuffer = await crypto.subtle.digest(\n        'SHA-256',\n        new Uint8Array([...encode(baseAddress), ...seedBytes, ...programAddressBytes]),\n    );\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n\n    return decode(addressBytes);\n}\n","/**!\n * noble-ed25519\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2019 Paul Miller (https://paulmillr.com)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the “Software”), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nconst D = 37095705934669439343138083508754565189542113879843219016388785533085940283555n;\nconst P = 57896044618658097711785492504343953926634992332820282019728792003956564819949n; // 2n ** 255n - 19n;  ed25519 is twisted edwards curve\nconst RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n; // √-1\n\n// mod division\nfunction mod(a: bigint): bigint {\n    const r = a % P;\n    return r >= 0n ? r : P + r;\n}\nfunction pow2(x: bigint, power: bigint): bigint {\n    // pow2(x, 4) == x^(2^4)\n    let r = x;\n    while (power-- > 0n) {\n        r *= r;\n        r %= P;\n    }\n    return r;\n}\nfunction pow_2_252_3(x: bigint): bigint {\n    // x^(2^252-3) unrolled util for square root\n    const x2 = (x * x) % P; // x^2,       bits 1\n    const b2 = (x2 * x) % P; // x^3,       bits 11\n    const b4 = (pow2(b2, 2n) * b2) % P; // x^(2^4-1), bits 1111\n    const b5 = (pow2(b4, 1n) * x) % P; // x^(2^5-1), bits 11111\n    const b10 = (pow2(b5, 5n) * b5) % P; // x^(2^10)\n    const b20 = (pow2(b10, 10n) * b10) % P; // x^(2^20)\n    const b40 = (pow2(b20, 20n) * b20) % P; // x^(2^40)\n    const b80 = (pow2(b40, 40n) * b40) % P; // x^(2^80)\n    const b160 = (pow2(b80, 80n) * b80) % P; // x^(2^160)\n    const b240 = (pow2(b160, 80n) * b80) % P; // x^(2^240)\n    const b250 = (pow2(b240, 10n) * b10) % P; // x^(2^250)\n    const pow_p_5_8 = (pow2(b250, 2n) * x) % P; // < To pow to (p+3)/8, multiply it by x.\n    return pow_p_5_8;\n}\nfunction uvRatio(u: bigint, v: bigint): bigint | null {\n    // for sqrt comp\n    const v3 = mod(v * v * v); // v³\n    const v7 = mod(v3 * v3 * v); // v⁷\n    const pow = pow_2_252_3(u * v7); // (uv⁷)^(p-5)/8\n    let x = mod(u * v3 * pow); // (uv³)(uv⁷)^(p-5)/8\n    const vx2 = mod(v * x * x); // vx²\n    const root1 = x; // First root candidate\n    const root2 = mod(x * RM1); // Second root candidate; RM1 is √-1\n    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n    const useRoot2 = vx2 === mod(-u); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === mod(-u * RM1); // There is no valid root, vx² = -u√-1\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n    if ((mod(x) & 1n) === 1n) x = mod(-x); // edIsNegative\n    if (!useRoot1 && !useRoot2) {\n        return null;\n    }\n    return x;\n}\n// https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.3\nexport function pointIsOnCurve(y: bigint, lastByte: number): boolean {\n    const y2 = mod(y * y); // y²\n    const u = mod(y2 - 1n); // u=y²-1\n    const v = mod(D * y2 + 1n);\n    const x = uvRatio(u, v); // (uv³)(uv⁷)^(p-5)/8; square root\n    if (x === null) {\n        return false;\n    }\n    const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n    if (x === 0n && isLastByteOdd) {\n        return false;\n    }\n    return true;\n}\n","import { pointIsOnCurve } from './vendor/noble/ed25519';\n\nfunction byteToHex(byte: number): string {\n    const hexString = byte.toString(16);\n    if (hexString.length === 1) {\n        return `0${hexString}`;\n    } else {\n        return hexString;\n    }\n}\n\nfunction decompressPointBytes(bytes: Uint8Array): bigint {\n    const hexString = bytes.reduce((acc, byte, ii) => `${byteToHex(ii === 31 ? byte & ~0x80 : byte)}${acc}`, '');\n    const integerLiteralString = `0x${hexString}`;\n    return BigInt(integerLiteralString);\n}\n\nexport async function compressedPointBytesAreOnCurve(bytes: Uint8Array): Promise<boolean> {\n    if (bytes.byteLength !== 32) {\n        return false;\n    }\n    const y = decompressPointBytes(bytes);\n    return pointIsOnCurve(y, bytes[31]);\n}\n","import { assertKeyExporterIsAvailable } from '@solana/assertions';\nimport { SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY, SolanaError } from '@solana/errors';\n\nimport { Address, getAddressDecoder } from './address';\n\nexport async function getAddressFromPublicKey(publicKey: CryptoKey): Promise<Address> {\n    await assertKeyExporterIsAvailable();\n    if (publicKey.type !== 'public' || publicKey.algorithm.name !== 'Ed25519') {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY);\n    }\n    const publicKeyBytes = await crypto.subtle.exportKey('raw', publicKey);\n    return getAddressDecoder().decode(new Uint8Array(publicKeyBytes));\n}\n"]}