{"version":3,"sources":["../../build-scripts/env-shim.ts","../src/http-transport.ts","../src/http-transport-headers.ts"],"names":["SolanaError"],"mappings":";AACO,IAAM,UAA2B,uBAAO,QAAgB,KAAU,EAAE,aAAa,eAAe;;;ACDvG,SAAS,yCAAyC,eAAAA,oBAAmB;;;ACArE,SAAS,oDAAoD,mBAAmB;AA2ChF,IAAM,qBAA8C;AAAA,EAChD,QAAQ;AAAA,EACR,kBAAkB;AAAA,EAClB,gBAAgB;AACpB;AAEA,IAAM,oBAA6C;AAAA,EAC/C,kBAAkB;AAAA,EAClB,mBAAmB;AAAA,EACnB,kCAAkC;AAAA,EAClC,iCAAiC;AAAA,EACjC,YAAY;AAAA,EACZ,kBAAkB;AAAA,EAClB,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,cAAc;AAAA,EACd,QAAQ;AAAA,EACR,sBAAsB;AAAA;AAAA;AAAA;AAAA,EAItB,SAAS;AAAA,EACT,IAAI;AAAA,EACJ,SAAS;AAAA,EACT,qBAAqB;AAAA,EACrB,SAAS;AAAA,EACT,KAAK;AACT;AAEO,SAAS,kCACZ,SAC4C;AAC5C,QAAM,aAAa,OAAO,KAAK,OAAO,EAAE,OAAO,gBAAc;AACzD,UAAM,sBAAsB,WAAW,YAAY;AACnD,WACI,mBAAmB,WAAW,YAAY,CAAC,MAAM,QACjD,kBAAkB,WAAW,YAAY,CAAC,MAAM,QAChD,oBAAoB,WAAW,QAAQ,KACvC,oBAAoB,WAAW,MAAM;AAAA,EAE7C,CAAC;AACD,MAAI,WAAW,SAAS,GAAG;AACvB,UAAM,IAAI,YAAY,oDAAoD;AAAA,MACtE,SAAS;AAAA,IACb,CAAC;AAAA,EACL;AACJ;AAMO,SAAS,iBACZ,SACiD;AACjD,QAAM,MAA8B,CAAC;AACrC,aAAW,cAAc,SAAS;AAC9B,QAAI,WAAW,YAAY,CAAC,IAAI,QAAQ,UAAU;AAAA,EACtD;AACA,SAAO;AACX;;;AD5EO,SAAS,oBAAoB,QAA8B;AAC9D,MAAI,WAAW,OAAiD;AAC5D,kDAA8C;AAAA,EAClD;AACA,QAAM,EAAE,SAAS,IAAI,IAAI;AACzB,MAAI,WAAW,SAAS;AACpB,sCAAkC,OAAO;AAAA,EAC7C;AACA,MAAI;AACJ,MAAkB,0BAA0B,QAAQ;AAChD,uBAAmB,EAAE,YAAY,OAAO,qBAAqB;AAAA,EACjE;AACA,QAAM,gBAAgB,WAAW,iBAAiB,OAAO;AACzD,SAAO,eAAe,gBAA2B;AAAA,IAC7C;AAAA,IACA;AAAA,EACJ,GAAoD;AAChD,UAAM,OAAO,KAAK,UAAU,OAAO;AACnC,UAAM,cAAc;AAAA,MAChB,GAAG;AAAA,MACH;AAAA,MACA,SAAS;AAAA,QACL,GAAG;AAAA;AAAA,QAEH,QAAQ;AAAA,QACR,kBAAkB,KAAK,OAAO,SAAS;AAAA,QACvC,gBAAgB;AAAA,MACpB;AAAA,MACA,QAAQ;AAAA,MACR;AAAA,IACJ;AACA,UAAM,WAAW,MAAM,MAAM,KAAK,WAAW;AAC7C,QAAI,CAAC,SAAS,IAAI;AACd,YAAM,IAAIA,aAAY,yCAAyC;AAAA,QAC3D,SAAS,SAAS;AAAA,QAClB,YAAY,SAAS;AAAA,MACzB,CAAC;AAAA,IACL;AACA,WAAQ,MAAM,SAAS,KAAK;AAAA,EAChC;AACJ","sourcesContent":["// Clever obfuscation to prevent the build system from inlining the value of `NODE_ENV`\nexport const __DEV__ = /* @__PURE__ */ (() => (process as any)['en' + 'v'].NODE_ENV === 'development')();\n","import { SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, SolanaError } from '@solana/errors';\nimport { RpcTransport } from '@solana/rpc-spec';\nimport type Dispatcher from 'undici-types/dispatcher';\n\nimport {\n    AllowedHttpRequestHeaders,\n    assertIsAllowedHttpRequestHeaders,\n    normalizeHeaders,\n} from './http-transport-headers';\n\ntype Config = Readonly<{\n    dispatcher_NODE_ONLY?: Dispatcher;\n    headers?: AllowedHttpRequestHeaders;\n    url: string;\n}>;\n\nlet didWarnDispatcherWasSuppliedInNonNodeEnvironment = false;\nfunction warnDispatcherWasSuppliedInNonNodeEnvironment() {\n    if (didWarnDispatcherWasSuppliedInNonNodeEnvironment) {\n        return;\n    }\n    didWarnDispatcherWasSuppliedInNonNodeEnvironment = true;\n    console.warn(\n        'You have supplied a `Dispatcher` to `createHttpTransport()`. It has been ignored ' +\n            'because Undici dispatchers only work in Node environments. To eliminate this ' +\n            'warning, omit the `dispatcher_NODE_ONLY` property from your config when running in ' +\n            'a non-Node environment.',\n    );\n}\n\nexport function createHttpTransport(config: Config): RpcTransport {\n    if (__DEV__ && !__NODEJS__ && 'dispatcher_NODE_ONLY' in config) {\n        warnDispatcherWasSuppliedInNonNodeEnvironment();\n    }\n    const { headers, url } = config;\n    if (__DEV__ && headers) {\n        assertIsAllowedHttpRequestHeaders(headers);\n    }\n    let dispatcherConfig: { dispatcher: Dispatcher | undefined } | undefined;\n    if (__NODEJS__ && 'dispatcher_NODE_ONLY' in config) {\n        dispatcherConfig = { dispatcher: config.dispatcher_NODE_ONLY };\n    }\n    const customHeaders = headers && normalizeHeaders(headers);\n    return async function makeHttpRequest<TResponse>({\n        payload,\n        signal,\n    }: Parameters<RpcTransport>[0]): Promise<TResponse> {\n        const body = JSON.stringify(payload);\n        const requestInfo = {\n            ...dispatcherConfig,\n            body,\n            headers: {\n                ...customHeaders,\n                // Keep these headers lowercase so they will override any user-supplied headers above.\n                accept: 'application/json',\n                'content-length': body.length.toString(),\n                'content-type': 'application/json; charset=utf-8',\n            },\n            method: 'POST',\n            signal,\n        };\n        const response = await fetch(url, requestInfo);\n        if (!response.ok) {\n            throw new SolanaError(SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, {\n                message: response.statusText,\n                statusCode: response.status,\n            });\n        }\n        return (await response.json()) as TResponse;\n    };\n}\n","import { SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, SolanaError } from '@solana/errors';\n\nexport type AllowedHttpRequestHeaders = Readonly<\n    {\n        // Someone can still sneak a forbidden header past Typescript if they do something like\n        // fOo-BaR, but at that point they deserve the runtime failure.\n        [K in DisallowedHeaders | ForbiddenHeaders as\n            | Capitalize<Lowercase<K>> // `Foo-bar`\n            | K // `Foo-Bar`\n            | Lowercase<K> // `foo-bar`\n            | Uncapitalize<K> // `foo-Bar`\n            // `FOO-BAR`\n            | Uppercase<K>]?: never;\n    } & { [headerName: string]: string }\n>;\n// These are headers that we simply don't allow the developer to override because they're\n// fundamental to the operation of the JSON-RPC transport.\ntype DisallowedHeaders = 'Accept' | 'Content-Length' | 'Content-Type' | 'Solana-Client';\ntype ForbiddenHeaders =\n    | 'Accept-Charset'\n    | 'Accept-Encoding'\n    | 'Access-Control-Request-Headers'\n    | 'Access-Control-Request-Method'\n    | 'Connection'\n    | 'Content-Length'\n    | 'Cookie'\n    | 'Date'\n    | 'DNT'\n    | 'Expect'\n    | 'Host'\n    | 'Keep-Alive'\n    | 'Origin'\n    | 'Permissions-Policy'\n    | 'Referer'\n    | 'TE'\n    | 'Trailer'\n    | 'Transfer-Encoding'\n    | 'Upgrade'\n    | 'Via'\n    | `Proxy-${string}`\n    | `Sec-${string}`;\n\n// These are headers which are fundamental to the JSON-RPC transport, and must not be modified.\nconst DISALLOWED_HEADERS: Record<string, boolean> = {\n    accept: true,\n    'content-length': true,\n    'content-type': true,\n};\n// https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\nconst FORBIDDEN_HEADERS: Record<string, boolean> = {\n    'accept-charset': true,\n    'accept-encoding': true,\n    'access-control-request-headers': true,\n    'access-control-request-method': true,\n    connection: true,\n    'content-length': true,\n    cookie: true,\n    date: true,\n    dnt: true,\n    expect: true,\n    host: true,\n    'keep-alive': true,\n    origin: true,\n    'permissions-policy': true,\n    // Prefix matching is implemented in code, below.\n    // 'proxy-': true,\n    // 'sec-': true,\n    referer: true,\n    te: true,\n    trailer: true,\n    'transfer-encoding': true,\n    upgrade: true,\n    via: true,\n};\n\nexport function assertIsAllowedHttpRequestHeaders(\n    headers: Record<string, string>,\n): asserts headers is AllowedHttpRequestHeaders {\n    const badHeaders = Object.keys(headers).filter(headerName => {\n        const lowercaseHeaderName = headerName.toLowerCase();\n        return (\n            DISALLOWED_HEADERS[headerName.toLowerCase()] === true ||\n            FORBIDDEN_HEADERS[headerName.toLowerCase()] === true ||\n            lowercaseHeaderName.startsWith('proxy-') ||\n            lowercaseHeaderName.startsWith('sec-')\n        );\n    });\n    if (badHeaders.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, {\n            headers: badHeaders,\n        });\n    }\n}\n\n/**\n * Lowercasing header names makes it easier to override user-supplied headers, such as those defined\n * in the `DisallowedHeaders` type.\n */\nexport function normalizeHeaders<T extends Record<string, string>>(\n    headers: T,\n): { [K in string & keyof T as Lowercase<K>]: T[K] } {\n    const out: Record<string, string> = {};\n    for (const headerName in headers) {\n        out[headerName.toLowerCase()] = headers[headerName];\n    }\n    return out as { [K in string & keyof T as Lowercase<K>]: T[K] };\n}\n"]}