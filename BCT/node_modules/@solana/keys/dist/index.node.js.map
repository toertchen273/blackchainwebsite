{"version":3,"sources":["../src/key-pair.ts","../src/private-key.ts","../src/signatures.ts"],"names":["SolanaError","signature"],"mappings":"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","sourcesContent":["import { assertKeyGenerationIsAvailable } from '@solana/assertions';\nimport { SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport { createPrivateKeyFromBytes } from './private-key';\n\nexport async function generateKeyPair(): Promise<CryptoKeyPair> {\n    await assertKeyGenerationIsAvailable();\n    const keyPair = await crypto.subtle.generateKey(\n        /* algorithm */ 'Ed25519', // Native implementation status: https://github.com/WICG/webcrypto-secure-curves/issues/20\n        /* extractable */ false, // Prevents the bytes of the private key from being visible to JS.\n        /* allowed uses */ ['sign', 'verify'],\n    );\n    return keyPair as CryptoKeyPair;\n}\n\nexport async function createKeyPairFromBytes(bytes: Uint8Array, extractable?: boolean): Promise<CryptoKeyPair> {\n    if (bytes.byteLength !== 64) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH, { byteLength: bytes.byteLength });\n    }\n    const [publicKey, privateKey] = await Promise.all([\n        crypto.subtle.importKey('raw', bytes.slice(32), 'Ed25519', /* extractable */ true, ['verify']),\n        createPrivateKeyFromBytes(bytes.slice(0, 32), extractable),\n    ]);\n    return { privateKey, publicKey } as CryptoKeyPair;\n}\n","import { SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nfunction addPkcs8Header(bytes: Uint8Array): Uint8Array {\n    // prettier-ignore\n    return new Uint8Array([\n        /**\n         * PKCS#8 header\n         */\n        0x30, // ASN.1 sequence tag\n        0x2e, // Length of sequence (46 more bytes)\n\n            0x02, // ASN.1 integer tag\n            0x01, // Length of integer\n                0x00, // Version number\n\n            0x30, // ASN.1 sequence tag\n            0x05, // Length of sequence\n                0x06, // ASN.1 object identifier tag\n                0x03, // Length of object identifier\n                    // Edwards curve algorithms identifier https://oid-rep.orange-labs.fr/get/1.3.101.112\n                        0x2b, // iso(1) / identified-organization(3) (The first node is multiplied by the decimal 40 and the result is added to the value of the second node)\n                        0x65, // thawte(101)\n                    // Ed25519 identifier\n                        0x70, // id-Ed25519(112)\n\n        /**\n         * Private key payload\n         */\n        0x04, // ASN.1 octet string tag\n        0x22, // String length (34 more bytes)\n\n            // Private key bytes as octet string\n            0x04, // ASN.1 octet string tag\n            0x20, // String length (32 bytes)\n\n        ...bytes\n    ]);\n}\n\nexport async function createPrivateKeyFromBytes(bytes: Uint8Array, extractable?: boolean): Promise<CryptoKey> {\n    const actualLength = bytes.byteLength;\n    if (actualLength !== 32) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, {\n            actualLength,\n        });\n    }\n    const privateKeyBytesPkcs8 = addPkcs8Header(bytes);\n    return await crypto.subtle.importKey('pkcs8', privateKeyBytesPkcs8, 'Ed25519', extractable ?? false, ['sign']);\n}\n","import { assertSigningCapabilityIsAvailable, assertVerificationCapabilityIsAvailable } from '@solana/assertions';\nimport { Encoder } from '@solana/codecs-core';\nimport { getBase58Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nexport type Signature = string & { readonly __brand: unique symbol };\nexport type SignatureBytes = Uint8Array & { readonly __brand: unique symbol };\n\nlet base58Encoder: Encoder<string> | undefined;\n\nexport function assertIsSignature(putativeSignature: string): asserts putativeSignature is Signature {\n    if (!base58Encoder) base58Encoder = getBase58Encoder();\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (64 bytes of zeroes)\n        putativeSignature.length < 64 ||\n        // Highest value (64 bytes of 255)\n        putativeSignature.length > 88\n    ) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeSignature.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const bytes = base58Encoder.encode(putativeSignature);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 64) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\nexport function isSignature(putativeSignature: string): putativeSignature is Signature {\n    if (!base58Encoder) base58Encoder = getBase58Encoder();\n\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (64 bytes of zeroes)\n        putativeSignature.length < 64 ||\n        // Highest value (64 bytes of 255)\n        putativeSignature.length > 88\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const bytes = base58Encoder.encode(putativeSignature);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 64) {\n        return false;\n    }\n    return true;\n}\n\nexport async function signBytes(key: CryptoKey, data: Uint8Array): Promise<SignatureBytes> {\n    await assertSigningCapabilityIsAvailable();\n    const signedData = await crypto.subtle.sign('Ed25519', key, data);\n    return new Uint8Array(signedData) as SignatureBytes;\n}\n\nexport function signature(putativeSignature: string): Signature {\n    assertIsSignature(putativeSignature);\n    return putativeSignature;\n}\n\nexport async function verifySignature(key: CryptoKey, signature: SignatureBytes, data: Uint8Array): Promise<boolean> {\n    await assertVerificationCapabilityIsAvailable();\n    return await crypto.subtle.verify('Ed25519', key, signature, data);\n}\n"]}