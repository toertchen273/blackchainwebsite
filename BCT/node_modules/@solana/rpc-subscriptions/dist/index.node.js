import { createSolanaRpcSubscriptionsApi } from '@solana/rpc-subscriptions-api';
export * from '@solana/rpc-subscriptions-api';
import { createSubscriptionRpc } from '@solana/rpc-subscriptions-spec';
export * from '@solana/rpc-subscriptions-spec';
import { pipe } from '@solana/functional';
import fastStableStringify from 'fast-stable-stringify';
import { SolanaError, SOLANA_ERROR__RPC__INTEGER_OVERFLOW, safeCaptureStackTrace, SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING } from '@solana/errors';
import { createWebSocketTransport } from '@solana/rpc-subscriptions-transport-websocket';

// ../build-scripts/env-shim.ts
var __DEV__ = /* @__PURE__ */ (() => process["env"].NODE_ENV === "development")();
function createSolanaJsonRpcIntegerOverflowError(methodName, keyPath, value) {
  let argumentLabel = "";
  if (typeof keyPath[0] === "number") {
    const argPosition = keyPath[0] + 1;
    const lastDigit = argPosition % 10;
    const lastTwoDigits = argPosition % 100;
    if (lastDigit == 1 && lastTwoDigits != 11) {
      argumentLabel = argPosition + "st";
    } else if (lastDigit == 2 && lastTwoDigits != 12) {
      argumentLabel = argPosition + "nd";
    } else if (lastDigit == 3 && lastTwoDigits != 13) {
      argumentLabel = argPosition + "rd";
    } else {
      argumentLabel = argPosition + "th";
    }
  } else {
    argumentLabel = `\`${keyPath[0].toString()}\``;
  }
  const path = keyPath.length > 1 ? keyPath.slice(1).map((pathPart) => typeof pathPart === "number" ? `[${pathPart}]` : pathPart).join(".") : void 0;
  const error = new SolanaError(SOLANA_ERROR__RPC__INTEGER_OVERFLOW, {
    argumentLabel,
    keyPath,
    methodName,
    optionalPathLabel: path ? ` at path \`${path}\`` : "",
    value,
    ...path !== void 0 ? { path } : void 0
  });
  safeCaptureStackTrace(error, createSolanaJsonRpcIntegerOverflowError);
  return error;
}

// src/rpc-default-config.ts
var DEFAULT_RPC_CONFIG = {
  defaultCommitment: "confirmed",
  onIntegerOverflow(methodName, keyPath, value) {
    throw createSolanaJsonRpcIntegerOverflowError(methodName, keyPath, value);
  }
};
function registerIterableCleanup(iterable, cleanupFn) {
  (async () => {
    try {
      for await (const _ of iterable)
        ;
    } catch {
    } finally {
      cleanupFn();
    }
  })();
}
function getCachedAbortableIterableFactory({
  getAbortSignalFromInputArgs,
  getCacheKeyFromInputArgs,
  onCacheHit,
  onCreateIterable
}) {
  const cache = /* @__PURE__ */ new Map();
  function getCacheEntryOrThrow(cacheKey) {
    const currentCacheEntry = cache.get(cacheKey);
    if (!currentCacheEntry) {
      throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING, {
        cacheKey: cacheKey.toString()
      });
    }
    return currentCacheEntry;
  }
  return async (...args) => {
    const cacheKey = getCacheKeyFromInputArgs(...args);
    const signal = getAbortSignalFromInputArgs(...args);
    if (cacheKey === void 0) {
      return await onCreateIterable(signal, ...args);
    }
    const cleanup = () => {
      cache.delete(cacheKey);
      signal.removeEventListener("abort", handleAbort);
    };
    const handleAbort = () => {
      const cacheEntry = getCacheEntryOrThrow(cacheKey);
      if (cacheEntry.purgeScheduled !== true) {
        cacheEntry.purgeScheduled = true;
        globalThis.queueMicrotask(() => {
          cacheEntry.purgeScheduled = false;
          if (cacheEntry.referenceCount === 0) {
            cacheEntry.abortController.abort();
            cleanup();
          }
        });
      }
      cacheEntry.referenceCount--;
    };
    signal.addEventListener("abort", handleAbort);
    try {
      const cacheEntry = cache.get(cacheKey);
      if (!cacheEntry) {
        const singletonAbortController = new AbortController();
        const newIterablePromise = onCreateIterable(singletonAbortController.signal, ...args);
        const newCacheEntry = {
          abortController: singletonAbortController,
          iterable: newIterablePromise,
          purgeScheduled: false,
          referenceCount: 1
        };
        cache.set(cacheKey, newCacheEntry);
        const newIterable = await newIterablePromise;
        registerIterableCleanup(newIterable, cleanup);
        newCacheEntry.iterable = newIterable;
        return newIterable;
      } else {
        cacheEntry.referenceCount++;
        const iterableOrIterablePromise = cacheEntry.iterable;
        const cachedIterable = "then" in iterableOrIterablePromise ? await iterableOrIterablePromise : iterableOrIterablePromise;
        await onCacheHit(cachedIterable, ...args);
        return cachedIterable;
      }
    } catch (e) {
      cleanup();
      throw e;
    }
  };
}

// src/rpc-subscriptions-coalescer.ts
var EXPLICIT_ABORT_TOKEN = Symbol(
  __DEV__ ? "This symbol is thrown from a subscription's iterator when the subscription is explicitly aborted by the user" : void 0
);
function registerIterableCleanup2(iterable, cleanupFn) {
  (async () => {
    try {
      for await (const _ of iterable)
        ;
    } catch {
    } finally {
      cleanupFn();
    }
  })();
}
function getRpcSubscriptionsWithSubscriptionCoalescing({
  getDeduplicationKey,
  rpcSubscriptions
}) {
  const cache = /* @__PURE__ */ new Map();
  return new Proxy(rpcSubscriptions, {
    defineProperty() {
      return false;
    },
    deleteProperty() {
      return false;
    },
    get(target, p, receiver) {
      const subscriptionMethod = Reflect.get(target, p, receiver);
      if (typeof subscriptionMethod !== "function") {
        return subscriptionMethod;
      }
      return function(...rawParams) {
        const deduplicationKey = getDeduplicationKey(p, rawParams);
        if (deduplicationKey === void 0) {
          return subscriptionMethod(...rawParams);
        }
        if (cache.has(deduplicationKey)) {
          return cache.get(deduplicationKey);
        }
        const iterableFactory = getCachedAbortableIterableFactory({
          getAbortSignalFromInputArgs: ({ abortSignal }) => abortSignal,
          getCacheKeyFromInputArgs: () => deduplicationKey,
          async onCacheHit(_iterable, _config) {
          },
          async onCreateIterable(abortSignal, config) {
            const pendingSubscription2 = subscriptionMethod(
              ...rawParams
            );
            const iterable = await pendingSubscription2.subscribe({
              ...config,
              abortSignal
            });
            registerIterableCleanup2(iterable, () => {
              cache.delete(deduplicationKey);
            });
            return iterable;
          }
        });
        const pendingSubscription = {
          async subscribe(...args) {
            const iterable = await iterableFactory(...args);
            const { abortSignal } = args[0];
            let abortPromise;
            return {
              ...iterable,
              async *[Symbol.asyncIterator]() {
                abortPromise ||= abortSignal.aborted ? Promise.reject(EXPLICIT_ABORT_TOKEN) : new Promise((_, reject) => {
                  abortSignal.addEventListener("abort", () => {
                    reject(EXPLICIT_ABORT_TOKEN);
                  });
                });
                try {
                  const iterator = iterable[Symbol.asyncIterator]();
                  while (true) {
                    const iteratorResult = await Promise.race([iterator.next(), abortPromise]);
                    if (iteratorResult.done) {
                      return;
                    } else {
                      yield iteratorResult.value;
                    }
                  }
                } catch (e) {
                  if (e === EXPLICIT_ABORT_TOKEN) {
                    return;
                  }
                  cache.delete(deduplicationKey);
                  throw e;
                }
              }
            };
          }
        };
        cache.set(deduplicationKey, pendingSubscription);
        return pendingSubscription;
      };
    }
  });
}

// src/rpc-subscriptions-autopinger.ts
var PING_PAYLOAD = {
  jsonrpc: "2.0",
  method: "ping"
};
function getWebSocketTransportWithAutoping({
  intervalMs,
  transport
}) {
  const pingableConnections = /* @__PURE__ */ new Map();
  return async (...args) => {
    const connection = await transport(...args);
    let intervalId;
    function sendPing() {
      connection.send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(PING_PAYLOAD);
    }
    function restartPingTimer() {
      clearInterval(intervalId);
      intervalId = setInterval(sendPing, intervalMs);
    }
    if (pingableConnections.has(connection) === false) {
      pingableConnections.set(connection, {
        [Symbol.asyncIterator]: connection[Symbol.asyncIterator].bind(connection),
        send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: (...args2) => {
          restartPingTimer();
          return connection.send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(...args2);
        }
      });
      (async () => {
        try {
          for await (const _ of connection) {
            restartPingTimer();
          }
        } catch {
        } finally {
          pingableConnections.delete(connection);
          clearInterval(intervalId);
          if (handleOffline) {
            globalThis.window.removeEventListener("offline", handleOffline);
          }
          if (handleOnline) {
            globalThis.window.removeEventListener("online", handleOnline);
          }
        }
      })();
      {
        restartPingTimer();
      }
      let handleOffline;
      let handleOnline;
    }
    return pingableConnections.get(connection);
  };
}

// src/rpc-subscriptions-connection-sharding.ts
var NULL_SHARD_CACHE_KEY = Symbol(
  __DEV__ ? "Cache key to use when there is no connection sharding strategy" : void 0
);
function getWebSocketTransportWithConnectionSharding({
  getShard,
  transport
}) {
  return getCachedAbortableIterableFactory({
    getAbortSignalFromInputArgs: ({ signal }) => signal,
    getCacheKeyFromInputArgs: ({ payload }) => getShard ? getShard(payload) : NULL_SHARD_CACHE_KEY,
    onCacheHit: (connection, { payload }) => connection.send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(payload),
    onCreateIterable: (abortSignal, config) => transport({
      ...config,
      signal: abortSignal
    })
  });
}

// src/rpc-subscriptions-transport.ts
function createDefaultRpcSubscriptionsTransport(config) {
  const { getShard, intervalMs, ...rest } = config;
  return pipe(
    createWebSocketTransport({
      ...rest,
      sendBufferHighWatermark: config.sendBufferHighWatermark ?? // Let 128KB of data into the WebSocket buffer before buffering it in the app.
      131072
    }),
    (transport) => getWebSocketTransportWithAutoping({
      intervalMs: intervalMs ?? 5e3,
      transport
    }),
    (transport) => getWebSocketTransportWithConnectionSharding({
      getShard,
      transport
    })
  );
}

// src/rpc-subscriptions.ts
function createSolanaRpcSubscriptions(clusterUrl, config) {
  const transport = createDefaultRpcSubscriptionsTransport({ url: clusterUrl, ...config });
  return createSolanaRpcSubscriptionsFromTransport(transport);
}
function createSolanaRpcSubscriptions_UNSTABLE(clusterUrl, config) {
  return createSolanaRpcSubscriptions(
    clusterUrl,
    config
  );
}
function createSolanaRpcSubscriptionsFromTransport(transport) {
  return pipe(
    createSubscriptionRpc({
      api: createSolanaRpcSubscriptionsApi(DEFAULT_RPC_CONFIG),
      transport
    }),
    (rpcSubscriptions) => getRpcSubscriptionsWithSubscriptionCoalescing({
      getDeduplicationKey: (...args) => fastStableStringify(args),
      rpcSubscriptions
    })
  );
}
function createSolanaRpcSubscriptionsFromTransport_UNSTABLE(transport) {
  return createSolanaRpcSubscriptionsFromTransport(transport);
}

export { createDefaultRpcSubscriptionsTransport, createSolanaRpcSubscriptions, createSolanaRpcSubscriptionsFromTransport, createSolanaRpcSubscriptionsFromTransport_UNSTABLE, createSolanaRpcSubscriptions_UNSTABLE };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.node.js.map