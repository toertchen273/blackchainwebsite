{"version":3,"sources":["../../build-scripts/env-shim.ts","../src/websocket-connection.ts","../../ws-impl/src/index.browser.ts","../src/websocket-transport.ts"],"names":["index_browser_default","resolve","reject","e"],"mappings":"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","sourcesContent":["// Clever obfuscation to prevent the build system from inlining the value of `NODE_ENV`\nexport const __DEV__ = /* @__PURE__ */ (() => (process as any)['en' + 'v'].NODE_ENV === 'development')();\n","import {\n    SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT,\n    SolanaError,\n} from '@solana/errors';\nimport WebSocket from '@solana/ws-impl';\n\ntype Config = Readonly<{\n    sendBufferHighWatermark: number;\n    signal: AbortSignal;\n    url: string;\n}>;\ntype IteratorKey = symbol;\ntype IteratorState =\n    | {\n          __hasPolled: false;\n          queuedMessages: unknown[];\n      }\n    | {\n          __hasPolled: true;\n          onError: Parameters<ConstructorParameters<typeof Promise>[0]>[1];\n          onMessage: Parameters<ConstructorParameters<typeof Promise>[0]>[0];\n      };\nexport type RpcWebSocketConnection = Readonly<{\n    send(payload: unknown): Promise<void>;\n    [Symbol.asyncIterator](): AsyncGenerator<unknown>;\n}>;\n\nconst EXPLICIT_ABORT_TOKEN = Symbol(\n    __DEV__\n        ? \"This symbol is thrown from a socket's iterator when the connection is explicitly aborted by the user\"\n        : undefined,\n);\n\nexport async function createWebSocketConnection({\n    sendBufferHighWatermark,\n    signal,\n    url,\n}: Config): Promise<RpcWebSocketConnection> {\n    return new Promise((resolve, reject) => {\n        signal.addEventListener('abort', handleAbort, { once: true });\n        const iteratorState: Map<IteratorKey, IteratorState> = new Map();\n        function errorAndClearAllIteratorStates(reason: unknown) {\n            const errorCallbacks = [...iteratorState.values()]\n                .filter((state): state is Extract<IteratorState, { __hasPolled: true }> => state.__hasPolled)\n                .map(({ onError }) => onError);\n            iteratorState.clear();\n            errorCallbacks.forEach(cb => {\n                try {\n                    cb(reason);\n                } catch {\n                    /* empty */\n                }\n            });\n        }\n        function handleAbort() {\n            errorAndClearAllIteratorStates(EXPLICIT_ABORT_TOKEN);\n            if (webSocket.readyState !== WebSocket.CLOSED && webSocket.readyState !== WebSocket.CLOSING) {\n                webSocket.close(1000);\n            }\n        }\n        function handleClose(ev: CloseEvent) {\n            bufferDrainWatcher?.onCancel();\n            signal.removeEventListener('abort', handleAbort);\n            webSocket.removeEventListener('close', handleClose);\n            webSocket.removeEventListener('error', handleError);\n            webSocket.removeEventListener('open', handleOpen);\n            webSocket.removeEventListener('message', handleMessage);\n            errorAndClearAllIteratorStates(ev);\n        }\n        function handleError(ev: Event) {\n            if (!hasConnected) {\n                reject(\n                    new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT, {\n                        errorEvent: ev,\n                    }),\n                );\n            }\n        }\n        let hasConnected = false;\n        let bufferDrainWatcher: Readonly<{ onCancel(): void; promise: Promise<void> }> | undefined;\n        function handleOpen() {\n            hasConnected = true;\n            resolve({\n                async send(payload: unknown) {\n                    const message = JSON.stringify(payload);\n                    if (\n                        !bufferDrainWatcher &&\n                        webSocket.readyState === WebSocket.OPEN &&\n                        webSocket.bufferedAmount > sendBufferHighWatermark\n                    ) {\n                        let onCancel: () => void;\n                        const promise = new Promise<void>((resolve, reject) => {\n                            const intervalId = setInterval(() => {\n                                if (\n                                    webSocket.readyState !== WebSocket.OPEN ||\n                                    !(webSocket.bufferedAmount > sendBufferHighWatermark)\n                                ) {\n                                    clearInterval(intervalId);\n                                    bufferDrainWatcher = undefined;\n                                    resolve();\n                                }\n                            }, 16);\n                            onCancel = () => {\n                                bufferDrainWatcher = undefined;\n                                clearInterval(intervalId);\n                                reject(\n                                    new SolanaError(\n                                        SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED,\n                                    ),\n                                );\n                            };\n                        });\n                        bufferDrainWatcher = {\n                            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                            // @ts-ignore\n                            onCancel,\n                            promise,\n                        };\n                    }\n                    if (bufferDrainWatcher) {\n                        await bufferDrainWatcher.promise;\n                    }\n                    webSocket.send(message);\n                },\n                async *[Symbol.asyncIterator]() {\n                    const iteratorKey = Symbol();\n                    iteratorState.set(iteratorKey, { __hasPolled: false, queuedMessages: [] });\n                    try {\n                        while (true) {\n                            const state = iteratorState.get(iteratorKey);\n                            if (!state) {\n                                // There should always be state by now.\n                                throw new SolanaError(\n                                    SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING,\n                                );\n                            }\n                            if (state.__hasPolled) {\n                                // You should never be able to poll twice in a row.\n                                throw new SolanaError(\n                                    SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n                                );\n                            }\n                            const queuedMessages = state.queuedMessages;\n                            if (queuedMessages.length) {\n                                state.queuedMessages = [];\n                                yield* queuedMessages;\n                            } else {\n                                try {\n                                    yield await new Promise((resolve, reject) => {\n                                        iteratorState.set(iteratorKey, {\n                                            __hasPolled: true,\n                                            onError: reject,\n                                            onMessage: resolve,\n                                        });\n                                    });\n                                } catch (e) {\n                                    if (e === EXPLICIT_ABORT_TOKEN) {\n                                        return;\n                                    } else {\n                                        throw new SolanaError(\n                                            SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED,\n                                            {\n                                                cause: e,\n                                            },\n                                        );\n                                    }\n                                }\n                            }\n                        }\n                    } finally {\n                        iteratorState.delete(iteratorKey);\n                    }\n                },\n            });\n        }\n        function handleMessage({ data }: MessageEvent) {\n            const message = JSON.parse(data);\n            iteratorState.forEach((state, iteratorKey) => {\n                if (state.__hasPolled) {\n                    const { onMessage } = state;\n                    iteratorState.set(iteratorKey, { __hasPolled: false, queuedMessages: [] });\n                    onMessage(message);\n                } else {\n                    state.queuedMessages.push(message);\n                }\n            });\n        }\n        const webSocket = new WebSocket(url);\n        webSocket.addEventListener('close', handleClose);\n        webSocket.addEventListener('error', handleError);\n        webSocket.addEventListener('open', handleOpen);\n        webSocket.addEventListener('message', handleMessage);\n    });\n}\n","export default globalThis.WebSocket;\n","import { RpcSubscriptionsTransport } from '@solana/rpc-subscriptions-spec';\n\nimport { createWebSocketConnection } from './websocket-connection';\n\ntype Config = Readonly<{\n    sendBufferHighWatermark: number;\n    url: string;\n}>;\n\nexport function createWebSocketTransport({ sendBufferHighWatermark, url }: Config): RpcSubscriptionsTransport {\n    if (/^wss?:/i.test(url) === false) {\n        const protocolMatch = url.match(/^([^:]+):/);\n        throw new DOMException(\n            protocolMatch\n                ? `Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or 'wss'. '${protocolMatch[1]}:' is not allowed.`\n                : `Failed to construct 'WebSocket': The URL '${url}' is invalid.`,\n        );\n    }\n    return async function sendWebSocketMessage({ payload, signal }: Parameters<RpcSubscriptionsTransport>[0]) {\n        signal?.throwIfAborted();\n        const connection = await createWebSocketConnection({\n            sendBufferHighWatermark,\n            signal,\n            url,\n        });\n        signal?.throwIfAborted();\n        await connection.send(payload);\n        return {\n            [Symbol.asyncIterator]: connection[Symbol.asyncIterator].bind(connection),\n            send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: connection.send.bind(connection),\n        };\n    };\n}\n"]}