{"version":3,"sources":["../../build-scripts/env-shim.ts","../../../node_modules/.pnpm/fast-stable-stringify@1.0.0/node_modules/fast-stable-stringify/index.js","../src/index.ts","../../errors/src/codes.ts","../../errors/src/messages.ts","../../errors/src/message-formatter.ts","../../errors/src/error.ts","../../errors/src/stack-trace.ts","../../errors/src/rpc-enum-errors.ts","../../errors/src/instruction-error.ts","../../errors/src/transaction-error.ts","../../errors/src/json-rpc-error.ts","../../codecs-core/src/assertions.ts","../../codecs-core/src/bytes.ts","../../codecs-core/src/codec.ts","../../codecs-core/src/combine-codec.ts","../../codecs-core/src/fix-codec.ts","../../codecs-core/src/map-codec.ts","../../codecs-core/src/offset-codec.ts","../../codecs-core/src/resize-codec.ts","../../codecs-core/src/pad-codec.ts","../../codecs-core/src/reverse-codec.ts","../../codecs-numbers/src/assertions.ts","../../codecs-numbers/src/common.ts","../../codecs-numbers/src/f32.ts","../../codecs-numbers/src/utils.ts","../../codecs-numbers/src/f64.ts","../../codecs-numbers/src/i128.ts","../../codecs-numbers/src/i16.ts","../../codecs-numbers/src/i32.ts","../../codecs-numbers/src/i64.ts","../../codecs-numbers/src/i8.ts","../../codecs-numbers/src/short-u16.ts","../../codecs-numbers/src/u128.ts","../../codecs-numbers/src/u16.ts","../../codecs-strings/src/assertions.ts","../../codecs-strings/src/baseX.ts","../../codecs-strings/src/base10.ts","../../codecs-strings/src/base16.ts","../../codecs-strings/src/base58.ts","../../codecs-strings/src/base64.ts","../../codecs-strings/src/baseX-reslice.ts","../../codecs-strings/src/null-characters.ts","../../codecs-strings/src/string.ts","../../codecs-strings/src/utf8.ts","../../text-encoding-impl/src/index.browser.ts","../../accounts/src/decode-account.ts","../../accounts/src/parse-account.ts","../../accounts/src/fetch-account.ts","../../accounts/src/maybe-account.ts","../../assertions/src/subtle-crypto.ts","../../addresses/src/address.ts","../../addresses/src/program-derived-address.ts","../../addresses/src/vendor/noble/ed25519.ts","../../addresses/src/curve.ts","../../codecs-data-structures/src/array.ts","../../codecs-data-structures/src/assertions.ts","../../codecs-data-structures/src/utils.ts","../../codecs-data-structures/src/bit-array.ts","../../codecs-data-structures/src/boolean.ts","../../codecs-data-structures/src/bytes.ts","../../codecs-data-structures/src/data-enum.ts","../../codecs-data-structures/src/map.ts","../../codecs-data-structures/src/tuple.ts","../../codecs-data-structures/src/nullable.ts","../../codecs-data-structures/src/scalar-enum.ts","../../options/src/option.ts","../../options/src/option-codec.ts","../../options/src/unwrap-option.ts","../../options/src/unwrap-option-recursively.ts","../../functional/src/pipe.ts","../../instructions/src/instruction.ts","../../instructions/src/roles.ts","../../keys/src/private-key.ts","../../keys/src/key-pair.ts","../../keys/src/signatures.ts","../../programs/src/resolve-transaction-error.ts","../../rpc-spec-types/src/rpc-message.ts","../../rpc-spec/src/rpc.ts","../../rpc-spec/src/rpc-api.ts","../../rpc-transformers/src/default-commitment.ts","../../rpc-transformers/src/params-transformer-bigint-downcast.ts","../../rpc-transformers/src/params-transformer-integer-overflow.ts","../../rpc-transformers/src/params-transformer-options-object-position-config.ts","../../rpc-transformers/src/tree-traversal.ts","../../rpc-transformers/src/params-transformer.ts","../../rpc-transformers/src/response-transformer-bigint-upcast.ts","../../rpc-transformers/src/response-transformer.ts","../../rpc-transformers/src/response-transformer-allowed-numeric-values.ts","../../rpc-api/src/index.ts","../../rpc-transport-http/src/http-transport.ts","../../rpc-transport-http/src/http-transport-headers.ts","../../rpc/src/rpc-integer-overflow-error.ts","../../rpc/src/rpc-default-config.ts","../../rpc/src/rpc-transport.ts","../../rpc/src/rpc-request-coalescer.ts","../../rpc/src/rpc-request-deduplication.ts","../../rpc-subscriptions-spec/src/rpc-subscriptions.ts","../../rpc-subscriptions-spec/src/rpc-subscriptions-api.ts","../../rpc-subscriptions-api/src/index.ts","../../rpc-subscriptions/src/index.ts","../../rpc-subscriptions-transport-websocket/src/websocket-connection.ts","../../ws-impl/src/index.browser.ts","../../rpc-subscriptions-transport-websocket/src/websocket-transport.ts","../../rpc-subscriptions/src/rpc-subscriptions.ts","../../rpc-subscriptions/src/rpc-integer-overflow-error.ts","../../rpc-subscriptions/src/rpc-default-config.ts","../../rpc-subscriptions/src/cached-abortable-iterable.ts","../../rpc-subscriptions/src/rpc-subscriptions-coalescer.ts","../../rpc-subscriptions/src/rpc-subscriptions-transport.ts","../../rpc-subscriptions/src/rpc-subscriptions-autopinger.ts","../../rpc-subscriptions/src/rpc-subscriptions-connection-sharding.ts","../../rpc-types/src/blockhash.ts","../../rpc-types/src/cluster-url.ts","../../rpc-types/src/commitment.ts","../../rpc-types/src/lamports.ts","../../rpc-types/src/stringified-bigint.ts","../../rpc-types/src/stringified-number.ts","../../transactions/src/unsigned-transaction.ts","../../transactions/src/blockhash.ts","../../transactions/src/create-transaction.ts","../../transactions/src/decompile-transaction.ts","../../transactions/src/durable-nonce.ts","../../transactions/src/fee-payer.ts","../../transactions/src/instructions.ts","../../transactions/src/accounts.ts","../../transactions/src/compile-address-table-lookups.ts","../../transactions/src/compile-header.ts","../../transactions/src/compile-instructions.ts","../../transactions/src/compile-lifetime-token.ts","../../transactions/src/compile-static-accounts.ts","../../transactions/src/message.ts","../../transactions/src/serializers/message.ts","../../transactions/src/serializers/address-table-lookup.ts","../../transactions/src/serializers/header.ts","../../transactions/src/serializers/instruction.ts","../../transactions/src/serializers/transaction-version.ts","../../transactions/src/serializers/transaction.ts","../../transactions/src/compile-transaction.ts","../../signers/src/deduplicate-signers.ts","../../signers/src/account-signer-meta.ts","../../signers/src/add-signers.ts","../../signers/src/fee-payer-signer.ts","../../signers/src/keypair-signer.ts","../../signers/src/message-partial-signer.ts","../../signers/src/transaction-partial-signer.ts","../../signers/src/message-modifying-signer.ts","../../signers/src/message-signer.ts","../../signers/src/noop-signer.ts","../../signers/src/sign-transaction.ts","../../signers/src/transaction-modifying-signer.ts","../../signers/src/transaction-sending-signer.ts","../../signers/src/transaction-signer.ts","../src/airdrop.ts","../../transaction-confirmation/src/confirmation-strategy-blockheight.ts","../../transaction-confirmation/src/confirmation-strategy-nonce.ts","../../transaction-confirmation/src/confirmation-strategy-recent-signature.ts","../../transaction-confirmation/src/confirmation-strategy-timeout.ts","../../transaction-confirmation/src/waiters.ts","../../transaction-confirmation/src/confirmation-strategy-racer.ts","../src/airdrop-internal.ts","../src/decode-transaction.ts","../src/send-transaction.ts","../src/send-transaction-internal.ts"],"names":["e","isSolanaError","ORDERED_ERROR_NAMES","SolanaError","Endian","combineCodec","createDecoder","createEncoder","alphabet","e2","SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE","address","base58Encoder","newOffset","getEncodedSize","_a","assertByteArrayHasEnoughBytesForCodec","isFixedSize","getU8Decoder","assertByteArrayIsNotEmptyForCodec","mapDecoder","mapEncoder","isSome","getU8Encoder","assertIsFixedSize","sumCodecSizes","getMaxSize","AccountRole2","AccountRole","program","__DEV__","normalizeHeaders","makeProxy","getAllowedNumericKeypaths","memoizedKeypaths","import_fast_stable_stringify","EXPLICIT_ABORT_TOKEN","resolve","createSolanaJsonRpcIntegerOverflowError","DEFAULT_RPC_CONFIG","registerIterableCleanup","registerIterableCleanup2","pendingSubscription","args","fastStableStringify","isVariableSize","memoizedBase58Encoder","memoizedBase58Decoder","getMemoizedBase58Encoder","getMemoizedBase58Decoder","assertIsBlockhash","IS_WRITABLE_BITMASK","isSignerRole","isWritableRole","mergeRoles","getAddressComparator","getShortU16Decoder","getStructEncoder","getArrayEncoder","getStructDecoder","getAddressEncoder","getStringEncoder","getShortU16Encoder","getStringDecoder","getBase58Decoder","getArrayDecoder","signature","out","o","base58Decoder","lamports"],"mappings":"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;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ;AAEO,SAAS,mCACZ,OACA,kBACW;AACX,SAAO;IACH;MACI,qBAAqB;MACrB,gBAAgB,WAAW,cAAc,iBAAiB;AACtD,YAAI,cAAc,0CAA0C;AACxD,iBAAO;YACH,WAAW;YACX;YACA,GAAI,oBAAoB,SAAY,EAAE,yBAAyB,gBAAgB,IAAI;UACvF;QACJ,WAAW,cAAc,yCAAyC;AAC9D,iBAAO;YACH,MAAM;YACN;UACJ;QACJ,WAAW,cAAc,iDAAiD;AACtE,iBAAO;YACH,aAAa;YACb;UACJ;QACJ;AACA,eAAO,EAAE,MAAM;MACnB;MACA,mBAAmB;MACnB,cAAc;IAClB;IACA;EACJ;AACJ;ACnFA,IAAME,uBAAsB;;;;EAIxB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ;AAEO,SAAS,mCAAmC,kBAAoE;AACnH,MAAI,OAAO,qBAAqB,YAAY,sBAAsB,kBAAkB;AAChF,WAAO;MACH,GAAI,iBAAiB;IACzB;EACJ;AACA,SAAO;IACH;MACI,qBAAqB;MACrB,gBAAgB,WAAW,cAAc,iBAAiB;AACtD,YAAI,cAAc,0CAA0C;AACxD,iBAAO;YACH,WAAW;YACX,GAAI,oBAAoB,SAAY,EAAE,yBAAyB,gBAAgB,IAAI;UACvF;QACJ,WAAW,cAAc,wDAAwD;AAC7E,iBAAO;YACH,OAAO;UACX;QACJ,WACI,cAAc,gEACd,cAAc,2EAChB;AACE,iBAAO;YACH,cAAe,gBAA8C;UACjE;QACJ;MACJ;MACA,mBAAmBA;MACnB,cAAc;IAClB;IACA;E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","sourcesContent":["// Clever obfuscation to prevent the build system from inlining the value of `NODE_ENV`\nexport const __DEV__ = /* @__PURE__ */ (() => (process as any)['en' + 'v'].NODE_ENV === 'development')();\n","var objToString = Object.prototype.toString;\nvar objKeys = Object.keys || function(obj) {\n\t\tvar keys = [];\n\t\tfor (var name in obj) {\n\t\t\tkeys.push(name);\n\t\t}\n\t\treturn keys;\n\t};\n\nfunction stringify(val, isArrayProp) {\n\tvar i, max, str, keys, key, propVal, toStr;\n\tif (val === true) {\n\t\treturn \"true\";\n\t}\n\tif (val === false) {\n\t\treturn \"false\";\n\t}\n\tswitch (typeof val) {\n\t\tcase \"object\":\n\t\t\tif (val === null) {\n\t\t\t\treturn null;\n\t\t\t} else if (val.toJSON && typeof val.toJSON === \"function\") {\n\t\t\t\treturn stringify(val.toJSON(), isArrayProp);\n\t\t\t} else {\n\t\t\t\ttoStr = objToString.call(val);\n\t\t\t\tif (toStr === \"[object Array]\") {\n\t\t\t\t\tstr = '[';\n\t\t\t\t\tmax = val.length - 1;\n\t\t\t\t\tfor(i = 0; i < max; i++) {\n\t\t\t\t\t\tstr += stringify(val[i], true) + ',';\n\t\t\t\t\t}\n\t\t\t\t\tif (max > -1) {\n\t\t\t\t\t\tstr += stringify(val[i], true);\n\t\t\t\t\t}\n\t\t\t\t\treturn str + ']';\n\t\t\t\t} else if (toStr === \"[object Object]\") {\n\t\t\t\t\t// only object is left\n\t\t\t\t\tkeys = objKeys(val).sort();\n\t\t\t\t\tmax = keys.length;\n\t\t\t\t\tstr = \"\";\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile (i < max) {\n\t\t\t\t\t\tkey = keys[i];\n\t\t\t\t\t\tpropVal = stringify(val[key], false);\n\t\t\t\t\t\tif (propVal !== undefined) {\n\t\t\t\t\t\t\tif (str) {\n\t\t\t\t\t\t\t\tstr += ',';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstr += JSON.stringify(key) + ':' + propVal;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\treturn '{' + str + '}';\n\t\t\t\t} else {\n\t\t\t\t\treturn JSON.stringify(val);\n\t\t\t\t}\n\t\t\t}\n\t\tcase \"function\":\n\t\tcase \"undefined\":\n\t\t\treturn isArrayProp ? null : undefined;\n\t\tcase \"string\":\n\t\t\treturn JSON.stringify(val);\n\t\tdefault:\n\t\t\treturn isFinite(val) ? val : null;\n\t}\n}\n\nmodule.exports = function(val) {\n\tvar returnVal = stringify(val, false);\n\tif (returnVal !== undefined) {\n\t\treturn ''+ returnVal;\n\t}\n};\n","export * from '@solana/accounts';\nexport * from '@solana/addresses';\nexport * from '@solana/codecs';\nexport * from '@solana/errors';\nexport * from '@solana/functional';\nexport * from '@solana/instructions';\nexport * from '@solana/keys';\nexport * from '@solana/programs';\nexport * from '@solana/rpc';\nexport * from '@solana/rpc-parsed-types';\nexport * from '@solana/rpc-subscriptions';\nexport * from '@solana/rpc-types';\nexport * from '@solana/signers';\nexport * from '@solana/transactions';\nexport * from './airdrop';\nexport * from './decode-transaction';\nexport * from './send-transaction';\n","/**\n * To add a new error, follow the instructions at\n * https://github.com/solana-labs/solana-web3.js/tree/master/packages/errors/#adding-a-new-error\n *\n * WARNING:\n *   - Don't remove error codes\n *   - Don't change or reorder error codes.\n *\n * Good naming conventions:\n *   - Prefixing common errors — e.g. under the same package — can be a good way to namespace them. E.g. All codec-related errors start with `SOLANA_ERROR__CODECS__`.\n *   - Use consistent names — e.g. choose `PDA` or `PROGRAM_DERIVED_ADDRESS` and stick with it. Ensure your names are consistent with existing error codes. The decision might have been made for you.\n *   - Recommended prefixes and suffixes:\n *     - `MALFORMED_`: Some input was not constructed properly. E.g. `MALFORMED_BASE58_ENCODED_ADDRESS`.\n *     - `INVALID_`: Some input is invalid (other than because it was MALFORMED). E.g. `INVALID_NUMBER_OF_BYTES`.\n *     - `EXPECTED_`: Some input was different than expected, no need to specify the \"GOT\" part unless necessary. E.g. `EXPECTED_DECODED_ACCOUNT`.\n *     - `_CANNOT_`: Some operation cannot be performed or some input cannot be used due to some condition. E.g. `CANNOT_DECODE_EMPTY_BYTE_ARRAY` or `PDA_CANNOT_END_WITH_PDA_MARKER`.\n *     - `_MUST_BE_`: Some condition must be true. E.g. `NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE`.\n *     - `_FAILED_TO_`: Tried to perform some operation and failed. E.g. `FAILED_TO_DECODE_ACCOUNT`.\n *     - `_NOT_FOUND`: Some operation lead to not finding something. E.g. `ACCOUNT_NOT_FOUND`.\n *     - `_OUT_OF_RANGE`: Some value is out of range. E.g. `ENUM_DISCRIMINATOR_OUT_OF_RANGE`.\n *     - `_EXCEEDED`: Some limit was exceeded. E.g. `PDA_MAX_SEED_LENGTH_EXCEEDED`.\n *     - `_MISMATCH`: Some elements do not match. E.g. `ENCODER_DECODER_FIXED_SIZE_MISMATCH`.\n *     - `_MISSING`: Some required input is missing. E.g. `TRANSACTION_FEE_PAYER_MISSING`.\n *     - `_UNIMPLEMENTED`: Some required component is not available in the environment. E.g. `SUBTLE_CRYPTO_VERIFY_FUNCTION_UNIMPLEMENTED`.\n */\nexport const SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1 as const;\nexport const SOLANA_ERROR__INVALID_NONCE = 2 as const;\nexport const SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3 as const;\nexport const SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4 as const;\nexport const SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5 as const;\nexport const SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6 as const;\nexport const SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7 as const;\nexport const SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8 as const;\nexport const SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9 as const;\n\n// JSON-RPC-related errors.\n// Reserve error codes in the range [-32768, -32000]\n// Keep in sync with https://github.com/anza-xyz/agave/blob/master/rpc-client-api/src/custom_error.rs\nexport const SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700 as const;\nexport const SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603 as const;\nexport const SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602 as const;\nexport const SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601 as const;\nexport const SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013 as const;\nexport const SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001 as const;\n\n// Addresses-related errors.\n// Reserve error codes in the range [2800000-2800999].\nexport const SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 2800000 as const;\nexport const SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001 as const;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002 as const;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003 as const;\nexport const SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004 as const;\nexport const SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005 as const;\nexport const SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006 as const;\nexport const SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007 as const;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008 as const;\nexport const SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009 as const;\nexport const SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010 as const;\n\n// Account-related errors.\n// Reserve error codes in the range [3230000-3230999].\nexport const SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 3230000 as const;\nexport const SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001 as const;\nexport const SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002 as const;\nexport const SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003 as const;\nexport const SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004 as const;\n\n// Subtle-Crypto-related errors.\n// Reserve error codes in the range [3610000-3610999].\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 3610000 as const;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001 as const;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002 as const;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003 as const;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004 as const;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005 as const;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006 as const;\n\n// Key-related errors.\n// Reserve error codes in the range [3704000-3704999].\nexport const SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704000 as const;\nexport const SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001 as const;\nexport const SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002 as const;\nexport const SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003 as const;\n\n// Instruction-related errors.\n// Reserve error codes in the range [4128000-4128999].\nexport const SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128000 as const;\nexport const SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001 as const;\nexport const SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002 as const;\n\n// Instruction errors.\n// Reserve error codes starting with [4615000-4615999] for the Rust enum `InstructionError`.\n// Error names here are dictated by the RPC (see ./instruction-error.ts).\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615000 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054 as const;\n\n// Signer-related errors.\n// Reserve error codes in the range [5508000-5508999].\nexport const SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508000 as const;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001 as const;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002 as const;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003 as const;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004 as const;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005 as const;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006 as const;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007 as const;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008 as const;\nexport const SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009 as const;\nexport const SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010 as const;\n\n// Transaction-related errors.\n// Reserve error codes in the range [5663000-5663999].\nexport const SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663000 as const;\nexport const SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001 as const;\nexport const SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002 as const;\nexport const SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003 as const;\nexport const SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004 as const;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005 as const;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006 as const;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007 as const;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008 as const;\nexport const SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009 as const;\nexport const SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010 as const;\nexport const SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011 as const;\nexport const SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012 as const;\nexport const SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013 as const;\nexport const SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE =\n    5663014 as const;\n\n// Transaction errors.\n// Reserve error codes starting with [7050000-7050999] for the Rust enum `TransactionError`.\n// Error names here are dictated by the RPC (see ./transaction-error.ts).\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 7050000 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008 as const;\n// `InstructionError` intentionally omitted.\nexport const SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036 as const;\n\n// Codec-related errors.\n// Reserve error codes in the range [8078000-8078999].\nexport const SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078000 as const;\nexport const SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001 as const;\nexport const SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002 as const;\nexport const SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003 as const;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004 as const;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005 as const;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006 as const;\nexport const SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007 as const;\nexport const SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008 as const;\nexport const SOLANA_ERROR__CODECS__INVALID_DATA_ENUM_VARIANT = 8078009 as const;\nexport const SOLANA_ERROR__CODECS__INVALID_SCALAR_ENUM_VARIANT = 8078010 as const;\nexport const SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011 as const;\nexport const SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012 as const;\nexport const SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013 as const;\nexport const SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014 as const;\n\n// RPC-related errors.\n// Reserve error codes in the range [8100000-8100999].\nexport const SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 8100000 as const;\nexport const SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001 as const;\nexport const SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002 as const;\n\n// RPC-Subscriptions-related errors.\n// Reserve error codes in the range [8190000-8190999].\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST = 8190000 as const;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001 as const;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002 as const;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED = 8190003 as const;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT = 8190004 as const;\n\n// Invariant violation errors.\n// Reserve error codes in the range [9900000-9900999].\n// These errors should only be thrown when there is a bug with the\n// library itself and should, in theory, never reach the end user.\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING = 9900000 as const;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE =\n    9900001 as const;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002 as const;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003 as const;\n\n/**\n * A union of every Solana error code\n *\n * You might be wondering why this is not a TypeScript enum or const enum.\n *\n * One of the goals of this library is to enable people to use some or none of it without having to\n * bundle all of it.\n *\n * If we made the set of error codes an enum then anyone who imported it (even if to only use a\n * single error code) would be forced to bundle every code and its label.\n *\n * Const enums appear to solve this problem by letting the compiler inline only the codes that are\n * actually used. Unfortunately exporting ambient (const) enums from a library like `@solana/errors`\n * is not safe, for a variety of reasons covered here: https://stackoverflow.com/a/28818850\n */\nexport type SolanaErrorCode =\n    | typeof SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED\n    | typeof SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT\n    | typeof SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT\n    | typeof SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND\n    | typeof SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE\n    | typeof SOLANA_ERROR__ADDRESSES__MALFORMED_PDA\n    | typeof SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED\n    | typeof SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER\n    | typeof SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED\n    | typeof SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__INVALID_DATA_ENUM_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS\n    | typeof SOLANA_ERROR__CODECS__INVALID_SCALAR_ENUM_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE\n    | typeof SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS\n    | typeof SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR\n    | typeof SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH\n    | typeof SOLANA_ERROR__INVALID_NONCE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING\n    | typeof SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__INVALID_PARAMS\n    | typeof SOLANA_ERROR__JSON_RPC__INVALID_REQUEST\n    | typeof SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND\n    | typeof SOLANA_ERROR__JSON_RPC__PARSE_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__SCAN_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION\n    | typeof SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__MALFORMED_BIGINT_STRING\n    | typeof SOLANA_ERROR__MALFORMED_NUMBER_STRING\n    | typeof SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW\n    | typeof SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR\n    | typeof SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT\n    | typeof SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS\n    | typeof SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME\n    | typeof SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE\n    | typeof SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES\n    | typeof SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE\n    | typeof SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT;\n","import {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,\n    SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY,\n    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,\n    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_DATA_ENUM_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SOLANA_ERROR__CODECS__INVALID_SCALAR_ENUM_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,\n    SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND,\n    SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SOLANA_ERROR__INVALID_NONCE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING,\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE,\n    SOLANA_ERROR__MALFORMED_BIGINT_STRING,\n    SOLANA_ERROR__MALFORMED_NUMBER_STRING,\n    SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__RPC__INTEGER_OVERFLOW,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT,\n    SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS,\n    SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER,\n    SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS,\n    SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT,\n    SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE,\n    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED,\n    SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP,\n    SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE,\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT,\n    SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED,\n    SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED,\n    SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE,\n    SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE,\n    SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT,\n    SolanaErrorCode,\n} from './codes';\n\n/**\n * To add a new error, follow the instructions at\n * https://github.com/solana-labs/solana-web3.js/tree/master/packages/errors#adding-a-new-error\n *\n * WARNING:\n *   - Don't change the meaning of an error message.\n */\nexport const SolanaErrorMessages: Readonly<{\n    // This type makes this data structure exhaustive with respect to `SolanaErrorCode`.\n    // TypeScript will fail to build this project if add an error code without a message.\n    [P in SolanaErrorCode]: string;\n}> = {\n    [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: 'Account not found at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]:\n        'Not all accounts were decoded. Encoded accounts found at addresses: $addresses.',\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: 'Expected decoded account at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: 'Failed to decode account data at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: 'Accounts not found at addresses: $addresses',\n    [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]:\n        'Unable to find a viable program address bump seed.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: '$putativeAddress is not a base58-encoded address.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]:\n        'Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: 'The `CryptoKey` must be an `Ed25519` public key.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: 'Invalid seeds; point must fall off the Ed25519 curve.',\n    [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]:\n        'Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].',\n    [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]:\n        'A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.',\n    [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]:\n        'The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.',\n    [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]:\n        'Expected program derived address bump to be in the range [0, 255], got: $bump.',\n    [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: 'Program address cannot end with PDA marker.',\n    [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]:\n        'The network has progressed past the last block for which this transaction could have been committed.',\n    [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]:\n        'Codec [$codecDescription] cannot decode empty byte arrays.',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]:\n        'Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]:\n        'Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]:\n        'Encoder and decoder must either both be fixed-size or variable-size.',\n    [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]:\n        'Enum discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.',\n    [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: 'Expected a fixed-size codec, got a variable-size one.',\n    [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]:\n        'Codec [$codecDescription] expected a positive byte length, got $bytesLength.',\n    [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: 'Expected a variable-size codec, got a fixed-size one.',\n    [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]:\n        'Codec [$codecDescription] expected $expected bytes, got $bytesLength.',\n    [SOLANA_ERROR__CODECS__INVALID_DATA_ENUM_VARIANT]:\n        'Invalid data enum variant. Expected one of [$variants], got $value.',\n    [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]:\n        'Expected [$codecDescription] to have $expected items, got $actual.',\n    [SOLANA_ERROR__CODECS__INVALID_SCALAR_ENUM_VARIANT]:\n        'Invalid scalar enum variant. Expected one of [$variants] or a number between $minRange and $maxRange, got $value.',\n    [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: 'Invalid value $value for base $base with alphabet $alphabet.',\n    [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]:\n        'Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.',\n    [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]:\n        'Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: 'instruction requires an uninitialized account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]:\n        'instruction tries to borrow reference for an account which is already borrowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]:\n        'instruction left account with an outstanding borrowed reference',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]:\n        \"program other than the account's owner changed the size of the account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: 'account data too small for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: 'instruction expected an executable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]:\n        'An account does not have enough lamports to be rent-exempt',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: 'Program arithmetic overflowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: 'Failed to serialize or deserialize account data: $encodedData',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]:\n        'Builtin programs must consume compute units',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: 'Cross-program invocation call depth too deep',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: 'Computational budget exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: 'custom program error: #$code',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: 'instruction contains duplicate accounts',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]:\n        'instruction modifications of multiply-passed account differ',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: 'executable accounts must be rent exempt',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: 'instruction changed executable accounts data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]:\n        'instruction changed the balance of an executable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: 'instruction changed executable bit of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]:\n        'instruction modified data of an account it does not own',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]:\n        'instruction spent from the balance of an account it does not own',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: 'generic instruction error',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: 'Provided owner is not allowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: 'Account is immutable',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: 'Incorrect authority provided',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: 'incorrect program id for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: 'insufficient funds for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: 'invalid account data for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: 'Invalid account owner',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: 'invalid program argument',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: 'program returned invalid error code',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: 'invalid instruction data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: 'Failed to reallocate account data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: 'Provided seeds do not result in a valid address',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]:\n        'Accounts data allocations exceeded the maximum allowed per transaction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: 'Max accounts exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: 'Max instruction trace length exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]:\n        'Length of the seed is too long for address generation',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: 'An account required by the instruction is missing',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: 'missing required signature for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]:\n        'instruction illegally modified the program id of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: 'insufficient account keys for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]:\n        'Cross-program invocation with unauthorized signer or writable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]:\n        'Failed to create program execution environment',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: 'Program failed to compile',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: 'Program failed to complete',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: 'instruction modified data of a read-only account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]:\n        'instruction changed the balance of a read-only account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]:\n        'Cross-program invocation reentrancy not allowed for this instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: 'instruction modified rent epoch of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]:\n        'sum of account balances before and after instruction do not match',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: 'instruction requires an initialized account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: '',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: 'Unsupported program id',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: 'Unsupported sysvar',\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: 'The instruction does not have any accounts.',\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: 'The instruction does not have any data.',\n    [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]:\n        'Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.',\n    [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]:\n        'Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__INVALID_NONCE]:\n        'The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]:\n        'Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It ' +\n        'should be impossible to hit this error; please file an issue at ' +\n        'https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]:\n        'Invariant violation: Switch statement non-exhaustive. Received unexpected value ' +\n        '`$unexpectedValue`. It should be impossible to hit this error; please file an issue at ' +\n        'https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]:\n        'Invariant violation: WebSocket message iterator state is corrupt; iterated without first ' +\n        'resolving existing message promise. It should be impossible to hit this error; please ' +\n        'file an issue at https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING]:\n        'Invariant violation: WebSocket message iterator is missing state storage. It should be ' +\n        'impossible to hit this error; please file an issue at https://sola.na/web3invariant',\n    [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: 'JSON-RPC error: Internal JSON-RPC error ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: 'JSON-RPC error: Invalid method parameter(s) ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]:\n        'JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]:\n        'JSON-RPC error: The method does not exist / is not available ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]:\n        'JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: 'Minimum context slot has not been reached',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: 'Node is unhealthy; behind by $numSlotsBehind slots',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: 'No snapshot',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: 'Transaction simulation failed',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]:\n        'Transaction history is not available from this node',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: 'Transaction signature length mismatch',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]:\n        'Transaction signature verification failure',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: '$__serverMessage',\n    [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: 'Key pair bytes must be of length 64, got $byteLength.',\n    [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]:\n        'Expected private key bytes with length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]:\n        'Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.',\n    [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.',\n    [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: 'Lamports value must be in the range [0, 2e64-1]',\n    [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: '`$value` cannot be parsed as a `BigInt`',\n    [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: '`$value` cannot be parsed as a `Number`',\n    [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: 'No nonce account could be found at address `$nonceAccountAddress`',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST]:\n        \"Either the notification name must end in 'Notifications' or the API must supply a \" +\n        \"subscription creator function for the notification '$notificationName' to map between \" +\n        'the notification name and the subscribe/unsubscribe method names.',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]:\n        'Failed to obtain a subscription id from the server',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED]:\n        'WebSocket was closed before payload could be added to the send buffer',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED]: 'WebSocket connection closed',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT]: 'WebSocket failed to connect',\n    [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]:\n        'The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was ' +\n        '`$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds ' +\n        '`Number.MAX_SAFE_INTEGER`.',\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: 'HTTP error ($statusCode): $message',\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]:\n        'HTTP header(s) forbidden: $headers. Learn more at ' +\n        'https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.',\n    [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]:\n        'Multiple distinct signers were identified for address `$address`. Please ensure that ' +\n        'you are using the same signer instance for each address.',\n    [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]:\n        'The provided value does not implement the `KeyPairSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]:\n        'The provided value does not implement the `MessageModifyingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]:\n        'The provided value does not implement the `MessagePartialSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]:\n        'The provided value does not implement any of the `MessageSigner` interfaces',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]:\n        'The provided value does not implement the `TransactionModifyingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]:\n        'The provided value does not implement the `TransactionPartialSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]:\n        'The provided value does not implement the `TransactionSendingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]:\n        'The provided value does not implement any of the `TransactionSigner` interfaces',\n    [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]:\n        'More than one `TransactionSendingSigner` was identified.',\n    [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]:\n        'No `TransactionSendingSigner` was identified. Please provide a valid ' +\n        '`ITransactionWithSingleSendingSigner` transaction.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: 'No digest implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]:\n        'Cryptographic operations are only allowed in secure browser contexts. Read more ' +\n        'here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]:\n        'This runtime does not support the generation of Ed25519 key pairs.\\n\\nInstall and ' +\n        'import `@solana/webcrypto-ed25519-polyfill` before generating keys in ' +\n        'environments that do not support Ed25519.\\n\\nFor a list of runtimes that ' +\n        'currently support Ed25519 operations, visit ' +\n        'https://github.com/WICG/webcrypto-secure-curves/issues/20.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]:\n        'No signature verification implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: 'No key generation implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: 'No signing implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: 'No key export implementation could be found.',\n    [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: 'Timestamp value must be in the range [-8.64e15, 8.64e15]. `$value` given',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]:\n        'Transaction processing left an account with an outstanding borrowed reference',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: 'Account in use',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: 'Account loaded twice',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]:\n        'Attempt to debit an account but found no record of a prior credit.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]:\n        \"Transaction loads an address table account that doesn't exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: 'This transaction has already been processed',\n    [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: 'Blockhash not found',\n    [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: 'Loader call chain is too deep',\n    [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]:\n        'Transactions are currently disabled due to cluster maintenance',\n    [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]:\n        'Transaction contains a duplicate instruction ($index) that is not allowed',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: 'Insufficient funds for fee',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]:\n        'Transaction results in an account ($accountIndex) with insufficient funds for rent',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: 'This account may not be used to pay transaction fees',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: 'Transaction contains an invalid account reference',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]:\n        'Transaction loads an address table account with invalid data',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]:\n        'Transaction address table lookup uses an invalid index',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]:\n        'Transaction loads an address table account with an invalid owner',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]:\n        'LoadedAccountsDataSizeLimit set for transaction must be greater than 0.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]:\n        'This program may not be used for executing instructions',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]:\n        'Transaction leaves an account with a lower balance than rent-exempt minimum',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]:\n        'Transaction loads a writable account that cannot be written',\n    [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]:\n        'Transaction exceeded max loaded accounts data size cap',\n    [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]:\n        'Transaction requires a fee but has no signature present',\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: 'Attempt to load a program that does not exist',\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]:\n        'Execution of the program referenced by account at index $accountIndex is temporarily restricted.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: 'ResanitizationNeeded',\n    [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: 'Transaction failed to sanitize accounts offsets correctly',\n    [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: 'Transaction did not pass signature verification',\n    [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: 'Transaction locked too many accounts',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]:\n        'Sum of account balances before and after transaction do not match',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: 'The transaction failed with the error `$errorName`',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: 'Transaction version is unsupported',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]:\n        'Transaction would exceed account data limit within the block',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]:\n        'Transaction would exceed total account data limit',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]:\n        'Transaction would exceed max account limit within the block',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]:\n        'Transaction would exceed max Block Cost Limit',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: 'Transaction would exceed max Vote Cost Limit',\n    [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: 'Transaction is missing an address at index: $index.',\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: 'Transaction does not have a blockhash lifetime',\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: 'Transaction is not a durable nonce transaction',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]:\n        'Contents of these address lookup tables unknown: $lookupTableAddresses',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]:\n        'Lookup of address at index $highestRequestedIndex failed for lookup table ' +\n        '`$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table ' +\n        'may have been extended since its contents were retrieved',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: 'No fee payer set in CompiledTransaction',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]:\n        'Could not find program address at index $index',\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: 'Transaction is missing a fee payer.',\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]:\n        \"Could not determine this transaction's signature. Make sure that the transaction has \" +\n        'been signed by its fee payer.',\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]:\n        'Transaction first instruction is not advance nonce account instruction.',\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]:\n        'Transaction with no instructions cannot be durable nonce transaction.',\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]:\n        'This transaction includes an address (`$programAddress`) which is both ' +\n        'invoked and set as the fee payer. Program addresses may not pay fees',\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]:\n        'This transaction includes an address (`$programAddress`) which is both invoked and ' +\n        'marked writable. Program addresses may not be writable',\n    [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: 'Transaction is missing signatures for addresses: $addresses.',\n    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]:\n        'Transaction version must be in the range [0, 127]. `$actualVersion` given',\n};\n","import { SolanaErrorCode } from './codes';\nimport { SolanaErrorMessages } from './messages';\n\nfunction encodeValue(value: unknown): string {\n    if (Array.isArray(value)) {\n        return (\n            /* \"[\" */ '%5B' +\n            value\n                .map(element =>\n                    typeof element === 'string'\n                        ? encodeURIComponent(`\"${element.replace(/\"/g, '\\\\\"')}\"`)\n                        : encodeValue(element),\n                )\n                .join(/* \", \" */ '%2C%20') +\n            /* \"]\" */ '%5D'\n        );\n    } else if (typeof value === 'bigint') {\n        return `${value}n`;\n    } else {\n        return encodeURIComponent(\n            String(\n                value != null && Object.getPrototypeOf(value) === null\n                    ? // Plain objects with no protoype don't have a `toString` method.\n                      // Convert them before stringifying them.\n                      { ...(value as object) }\n                    : value,\n            ),\n        );\n    }\n}\n\nfunction encodeObjectContextEntry([key, value]: [string, unknown]): `${typeof key}=${string}` {\n    return `${key}=${encodeValue(value)}`;\n}\n\nfunction encodeContextObject(context: object) {\n    return Object.entries(context).map(encodeObjectContextEntry).join('&');\n}\n\nexport function getHumanReadableErrorMessage<TErrorCode extends SolanaErrorCode>(\n    code: TErrorCode,\n    context: object = {},\n): string {\n    const messageFormatString = SolanaErrorMessages[code];\n    const message = messageFormatString.replace(/(?<!\\\\)\\$(\\w+)/g, (substring, variableName) =>\n        variableName in context ? `${context[variableName as keyof typeof context]}` : substring,\n    );\n    return message;\n}\n\nexport function getErrorMessage<TErrorCode extends SolanaErrorCode>(code: TErrorCode, context: object = {}): string {\n    if (__DEV__) {\n        return getHumanReadableErrorMessage(code, context);\n    } else {\n        let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \\`npx @solana/errors decode ${code}`;\n        if (Object.keys(context).length) {\n            /**\n             * DANGER: Be sure that the shell command is escaped in such a way that makes it\n             *         impossible for someone to craft malicious context values that would result in\n             *         an exploit against anyone who bindly copy/pastes it into their terminal.\n             */\n            decodingAdviceMessage += ` $\"${encodeContextObject(context)}\"`;\n        }\n        return `${decodingAdviceMessage}\\``;\n    }\n}\n","import { SolanaErrorCode } from './codes';\nimport { SolanaErrorContext } from './context';\nimport { getErrorMessage } from './message-formatter';\n\nexport function isSolanaError<TErrorCode extends SolanaErrorCode>(\n    e: unknown,\n    code?: TErrorCode,\n): e is SolanaError<TErrorCode> {\n    const isSolanaError = e instanceof Error && e.name === 'SolanaError';\n    if (isSolanaError) {\n        if (code !== undefined) {\n            return (e as SolanaError<TErrorCode>).context.__code === code;\n        }\n        return true;\n    }\n    return false;\n}\n\ntype SolanaErrorCodedContext = Readonly<{\n    [P in SolanaErrorCode]: (SolanaErrorContext[P] extends undefined ? object : SolanaErrorContext[P]) & {\n        __code: P;\n    };\n}>;\n\nexport class SolanaError<TErrorCode extends SolanaErrorCode = SolanaErrorCode> extends Error {\n    readonly context: SolanaErrorCodedContext[TErrorCode];\n    constructor(\n        ...[code, contextAndErrorOptions]: SolanaErrorContext[TErrorCode] extends undefined\n            ? [code: TErrorCode, errorOptions?: ErrorOptions | undefined]\n            : [code: TErrorCode, contextAndErrorOptions: SolanaErrorContext[TErrorCode] & (ErrorOptions | undefined)]\n    ) {\n        let context: SolanaErrorContext[TErrorCode] | undefined;\n        let errorOptions: ErrorOptions | undefined;\n        if (contextAndErrorOptions) {\n            // If the `ErrorOptions` type ever changes, update this code.\n            const { cause, ...contextRest } = contextAndErrorOptions;\n            if (cause) {\n                errorOptions = { cause };\n            }\n            if (Object.keys(contextRest).length > 0) {\n                context = contextRest as SolanaErrorContext[TErrorCode];\n            }\n        }\n        const message = getErrorMessage(code, context);\n        super(message, errorOptions);\n        this.context = {\n            __code: code,\n            ...context,\n        } as SolanaErrorCodedContext[TErrorCode];\n        // This is necessary so that `isSolanaError()` can identify a `SolanaError` without having\n        // to import the class for use in an `instanceof` check.\n        this.name = 'SolanaError';\n    }\n}\n","export function safeCaptureStackTrace(...args: Parameters<typeof Error.captureStackTrace>): void {\n    if ('captureStackTrace' in Error && typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(...args);\n    }\n}\n","import { SolanaErrorCode } from './codes';\nimport { SolanaErrorContext } from './context';\nimport { SolanaError } from './error';\nimport { safeCaptureStackTrace } from './stack-trace';\n\ntype Config = Readonly<{\n    /**\n     * Oh, hello. You might wonder what in tarnation is going on here. Allow us to explain.\n     *\n     * One of the goals of `@solana/errors` is to allow errors that are not interesting to your\n     * application to shake out of your app bundle in production. This means that we must never\n     * export large hardcoded maps of error codes/messages.\n     *\n     * Unfortunately, where instruction and transaction errors from the RPC are concerned, we have\n     * no choice but to keep a map between the RPC `rpcEnumError` enum name and its corresponding\n     * `SolanaError` code. In the interest of implementing that map in as few bytes of source code\n     * as possible, we do the following:\n     *\n     *   1. Reserve a block of sequential error codes for the enum in question\n     *   2. Hardcode the list of enum names in that same order\n     *   3. Match the enum error name from the RPC with its index in that list, and reconstruct the\n     *      `SolanaError` code by adding the `errorCodeBaseOffset` to that index\n     */\n    errorCodeBaseOffset: number;\n    getErrorContext: (\n        errorCode: SolanaErrorCode,\n        rpcErrorName: string,\n        rpcErrorContext?: unknown,\n    ) => SolanaErrorContext[SolanaErrorCode];\n    orderedErrorNames: string[];\n    rpcEnumError: string | { [key: string]: unknown };\n}>;\n\nexport function getSolanaErrorFromRpcError(\n    { errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }: Config,\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    constructorOpt: Function,\n): SolanaError {\n    let rpcErrorName;\n    let rpcErrorContext;\n    if (typeof rpcEnumError === 'string') {\n        rpcErrorName = rpcEnumError;\n    } else {\n        rpcErrorName = Object.keys(rpcEnumError)[0];\n        rpcErrorContext = rpcEnumError[rpcErrorName];\n    }\n    const codeOffset = orderedErrorNames.indexOf(rpcErrorName);\n    const errorCode = (errorCodeBaseOffset + codeOffset) as SolanaErrorCode;\n    const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);\n    const err = new SolanaError(errorCode, errorContext);\n    safeCaptureStackTrace(err, constructorOpt);\n    return err;\n}\n","import {\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n} from './codes';\nimport { SolanaError } from './error';\nimport { getSolanaErrorFromRpcError } from './rpc-enum-errors';\n\nconst ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/program/src/instruction.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    'GenericError',\n    'InvalidArgument',\n    'InvalidInstructionData',\n    'InvalidAccountData',\n    'AccountDataTooSmall',\n    'InsufficientFunds',\n    'IncorrectProgramId',\n    'MissingRequiredSignature',\n    'AccountAlreadyInitialized',\n    'UninitializedAccount',\n    'UnbalancedInstruction',\n    'ModifiedProgramId',\n    'ExternalAccountLamportSpend',\n    'ExternalAccountDataModified',\n    'ReadonlyLamportChange',\n    'ReadonlyDataModified',\n    'DuplicateAccountIndex',\n    'ExecutableModified',\n    'RentEpochModified',\n    'NotEnoughAccountKeys',\n    'AccountDataSizeChanged',\n    'AccountNotExecutable',\n    'AccountBorrowFailed',\n    'AccountBorrowOutstanding',\n    'DuplicateAccountOutOfSync',\n    'Custom',\n    'InvalidError',\n    'ExecutableDataModified',\n    'ExecutableLamportChange',\n    'ExecutableAccountNotRentExempt',\n    'UnsupportedProgramId',\n    'CallDepth',\n    'MissingAccount',\n    'ReentrancyNotAllowed',\n    'MaxSeedLengthExceeded',\n    'InvalidSeeds',\n    'InvalidRealloc',\n    'ComputationalBudgetExceeded',\n    'PrivilegeEscalation',\n    'ProgramEnvironmentSetupFailure',\n    'ProgramFailedToComplete',\n    'ProgramFailedToCompile',\n    'Immutable',\n    'IncorrectAuthority',\n    'BorshIoError',\n    'AccountNotRentExempt',\n    'InvalidAccountOwner',\n    'ArithmeticOverflow',\n    'UnsupportedSysvar',\n    'IllegalOwner',\n    'MaxAccountsDataAllocationsExceeded',\n    'MaxAccountsExceeded',\n    'MaxInstructionTraceLengthExceeded',\n    'BuiltinProgramsMustConsumeComputeUnits',\n];\n\nexport function getSolanaErrorFromInstructionError(\n    index: number,\n    instructionError: string | { [key: string]: unknown },\n): SolanaError {\n    return getSolanaErrorFromRpcError(\n        {\n            errorCodeBaseOffset: 4615001,\n            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n                if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {\n                    return {\n                        errorName: rpcErrorName,\n                        index,\n                        ...(rpcErrorContext !== undefined ? { instructionErrorContext: rpcErrorContext } : null),\n                    };\n                } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {\n                    return {\n                        code: rpcErrorContext as number,\n                        index,\n                    };\n                } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR) {\n                    return {\n                        encodedData: rpcErrorContext as string,\n                        index,\n                    };\n                }\n                return { index };\n            },\n            orderedErrorNames: ORDERED_ERROR_NAMES,\n            rpcEnumError: instructionError,\n        },\n        getSolanaErrorFromInstructionError,\n    );\n}\n","import {\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n} from './codes';\nimport { SolanaError } from './error';\nimport { getSolanaErrorFromInstructionError } from './instruction-error';\nimport { getSolanaErrorFromRpcError } from './rpc-enum-errors';\n\n/**\n * How to add an error when an entry is added to the RPC `TransactionError` enum:\n *\n *   1. Follow the instructions in `./codes.ts` to add a corresponding Solana error code\n *   2. Add the `TransactionError` enum name in the same order as it appears in `./codes.ts`\n *   3. Add the new error name/code mapping to `./__tests__/transaction-error-test.ts`\n */\nconst ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    'AccountInUse',\n    'AccountLoadedTwice',\n    'AccountNotFound',\n    'ProgramAccountNotFound',\n    'InsufficientFundsForFee',\n    'InvalidAccountForFee',\n    'AlreadyProcessed',\n    'BlockhashNotFound',\n    // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`\n    'CallChainTooDeep',\n    'MissingSignatureForFee',\n    'InvalidAccountIndex',\n    'SignatureFailure',\n    'InvalidProgramForExecution',\n    'SanitizeFailure',\n    'ClusterMaintenance',\n    'AccountBorrowOutstanding',\n    'WouldExceedMaxBlockCostLimit',\n    'UnsupportedVersion',\n    'InvalidWritableAccount',\n    'WouldExceedMaxAccountCostLimit',\n    'WouldExceedAccountDataBlockLimit',\n    'TooManyAccountLocks',\n    'AddressLookupTableNotFound',\n    'InvalidAddressLookupTableOwner',\n    'InvalidAddressLookupTableData',\n    'InvalidAddressLookupTableIndex',\n    'InvalidRentPayingAccount',\n    'WouldExceedMaxVoteCostLimit',\n    'WouldExceedAccountDataTotalLimit',\n    'DuplicateInstruction',\n    'InsufficientFundsForRent',\n    'MaxLoadedAccountsDataSizeExceeded',\n    'InvalidLoadedAccountsDataSizeLimit',\n    'ResanitizationNeeded',\n    'ProgramExecutionTemporarilyRestricted',\n    'UnbalancedTransaction',\n];\n\nexport function getSolanaErrorFromTransactionError(transactionError: string | { [key: string]: unknown }): SolanaError {\n    if (typeof transactionError === 'object' && 'InstructionError' in transactionError) {\n        return getSolanaErrorFromInstructionError(\n            ...(transactionError.InstructionError as Parameters<typeof getSolanaErrorFromInstructionError>),\n        );\n    }\n    return getSolanaErrorFromRpcError(\n        {\n            errorCodeBaseOffset: 7050001,\n            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n                if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {\n                    return {\n                        errorName: rpcErrorName,\n                        ...(rpcErrorContext !== undefined ? { transactionErrorContext: rpcErrorContext } : null),\n                    };\n                } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {\n                    return {\n                        index: rpcErrorContext as number,\n                    };\n                } else if (\n                    errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT ||\n                    errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED\n                ) {\n                    return {\n                        accountIndex: (rpcErrorContext as { account_index: number }).account_index,\n                    };\n                }\n            },\n            orderedErrorNames: ORDERED_ERROR_NAMES,\n            rpcEnumError: transactionError,\n        },\n        getSolanaErrorFromTransactionError,\n    );\n}\n","import {\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SolanaErrorCode,\n} from './codes';\nimport { SolanaErrorContext } from './context';\nimport { SolanaError } from './error';\nimport { safeCaptureStackTrace } from './stack-trace';\nimport { getSolanaErrorFromTransactionError } from './transaction-error';\n\ninterface RpcErrorResponse {\n    code: number;\n    data?: unknown;\n    message: string;\n}\n\ntype TransactionError = string | { [key: string]: unknown };\n\n// Keep in sync with https://github.com/anza-xyz/agave/blob/master/rpc-client-api/src/response.rs\nexport interface RpcSimulateTransactionResult {\n    accounts:\n        | ({\n              data:\n                  | string // LegacyBinary\n                  | {\n                        // Json\n                        parsed: unknown;\n                        program: string;\n                        space: number;\n                    }\n                  // Binary\n                  | [encodedBytes: string, encoding: 'base58' | 'base64' | 'base64+zstd' | 'binary' | 'jsonParsed'];\n              executable: boolean;\n              lamports: number;\n              owner: string;\n              rentEpoch: number;\n              space?: number;\n          } | null)[]\n        | null;\n    err: TransactionError | null;\n    // Enabled by `enable_cpi_recording`\n    innerInstructions?:\n        | {\n              index: number;\n              instructions: (\n                  | {\n                        // Compiled\n                        accounts: number[];\n                        data: string;\n                        programIdIndex: number;\n                        stack_height?: number;\n                    }\n                  | {\n                        // Parsed\n                        parsed: unknown;\n                        program: string;\n                        program_id: string;\n                        stack_height?: number;\n                    }\n                  | {\n                        // PartiallyDecoded\n                        accounts: string[];\n                        data: string;\n                        program_id: string;\n                        stack_height?: number;\n                    }\n              )[];\n          }[]\n        | null;\n    logs: string[] | null;\n    returnData: {\n        data: [string, 'base64'];\n        programId: string;\n    } | null;\n    unitsConsumed: number | null;\n}\n\nexport function getSolanaErrorFromJsonRpcError({ code, data, message }: RpcErrorResponse): SolanaError {\n    let out: SolanaError;\n    if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {\n        const { err, ...preflightErrorContext } = data as RpcSimulateTransactionResult;\n        const causeObject = err ? { cause: getSolanaErrorFromTransactionError(err) } : null;\n        out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {\n            ...preflightErrorContext,\n            ...causeObject,\n        });\n    } else {\n        let errorContext;\n        switch (code) {\n            case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:\n            case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:\n            case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:\n            case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:\n            case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:\n            case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:\n                // The server supplies no structured data, but rather a pre-formatted message. Put\n                // the server message in `context` so as not to completely lose the data. The long\n                // term fix for this is to add data to the server responses and modify the\n                // messages in `@solana/errors` to be actual format strings.\n                errorContext = { __serverMessage: message };\n                break;\n            default:\n                if (typeof data === 'object' && !Array.isArray(data)) {\n                    errorContext = data;\n                }\n        }\n        out = new SolanaError(code as SolanaErrorCode, errorContext as SolanaErrorContext[SolanaErrorCode]);\n    }\n    safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);\n    return out;\n}\n","import {\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\n/**\n * Asserts that a given byte array is not empty.\n */\nexport function assertByteArrayIsNotEmptyForCodec(codecDescription: string, bytes: Uint8Array, offset = 0) {\n    if (bytes.length - offset <= 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription,\n        });\n    }\n}\n\n/**\n * Asserts that a given byte array has enough bytes to decode.\n */\nexport function assertByteArrayHasEnoughBytesForCodec(\n    codecDescription: string,\n    expected: number,\n    bytes: Uint8Array,\n    offset = 0,\n) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected,\n        });\n    }\n}\n\n/**\n * Asserts that a given offset is within the byte array bounds.\n * This range is between 0 and the byte array length and is inclusive.\n * An offset equals to the byte array length is considered a valid offset\n * as it allows the post-offset of codecs to signal the end of the byte array.\n */\nexport function assertByteArrayOffsetIsNotOutOfRange(codecDescription: string, offset: number, bytesLength: number) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset,\n        });\n    }\n}\n","/**\n * Concatenates an array of `Uint8Array`s into a single `Uint8Array`.\n * Reuses the original byte array when applicable.\n */\nexport const mergeBytes = (byteArrays: Uint8Array[]): Uint8Array => {\n    const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n\n    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach(arr => {\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\n\n/**\n * Pads a `Uint8Array` with zeroes to the specified length.\n * If the array is longer than the specified length, it is returned as-is.\n */\nexport const padBytes = (bytes: Uint8Array, length: number): Uint8Array => {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\n\n/**\n * Fixes a `Uint8Array` to the specified length.\n * If the array is longer than the specified length, it is truncated.\n * If the array is shorter than the specified length, it is padded with zeroes.\n */\nexport const fixBytes = (bytes: Uint8Array, length: number): Uint8Array =>\n    padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\n","import {\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\n/**\n * Defines an offset in bytes.\n */\nexport type Offset = number;\n\ntype BaseEncoder<TFrom> = {\n    /** Encode the provided value and return the encoded bytes directly. */\n    readonly encode: (value: TFrom) => Uint8Array;\n    /**\n     * Writes the encoded value into the provided byte array at the given offset.\n     * Returns the offset of the next byte after the encoded value.\n     */\n    readonly write: (value: TFrom, bytes: Uint8Array, offset: Offset) => Offset;\n};\n\nexport type FixedSizeEncoder<TFrom, TSize extends number = number> = BaseEncoder<TFrom> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\nexport type VariableSizeEncoder<TFrom> = BaseEncoder<TFrom> & {\n    /** The total size of the encoded value in bytes. */\n    readonly getSizeFromValue: (value: TFrom) => number;\n    /** The maximum size an encoded value can be in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can encode a value to a `Uint8Array`.\n */\nexport type Encoder<TFrom> = FixedSizeEncoder<TFrom> | VariableSizeEncoder<TFrom>;\n\ntype BaseDecoder<TTo> = {\n    /** Decodes the provided byte array at the given offset (or zero) and returns the value directly. */\n    readonly decode: (bytes: Uint8Array, offset?: Offset) => TTo;\n    /**\n     * Reads the encoded value from the provided byte array at the given offset.\n     * Returns the decoded value and the offset of the next byte after the encoded value.\n     */\n    readonly read: (bytes: Uint8Array, offset: Offset) => [TTo, Offset];\n};\n\nexport type FixedSizeDecoder<TTo, TSize extends number = number> = BaseDecoder<TTo> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\nexport type VariableSizeDecoder<TTo> = BaseDecoder<TTo> & {\n    /** The maximum size an encoded value can be in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can decode a value from a `Uint8Array`.\n */\nexport type Decoder<TTo> = FixedSizeDecoder<TTo> | VariableSizeDecoder<TTo>;\n\nexport type FixedSizeCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number> = FixedSizeDecoder<\n    TTo,\n    TSize\n> &\n    FixedSizeEncoder<TFrom, TSize>;\n\nexport type VariableSizeCodec<TFrom, TTo extends TFrom = TFrom> = VariableSizeDecoder<TTo> & VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can encode and decode a value to and from a `Uint8Array`.\n * It supports encoding looser types than it decodes for convenience.\n * For example, a `bigint` encoder will always decode to a `bigint`\n * but can be used to encode a `number`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value. Defaults to `TFrom`.\n */\nexport type Codec<TFrom, TTo extends TFrom = TFrom> = FixedSizeCodec<TFrom, TTo> | VariableSizeCodec<TFrom, TTo>;\n\n/**\n * Get the encoded size of a given value in bytes.\n */\nexport function getEncodedSize<TFrom>(\n    value: TFrom,\n    encoder: { fixedSize: number } | { getSizeFromValue: (value: TFrom) => number },\n): number {\n    return 'fixedSize' in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\n\n/** Fills the missing `encode` function using the existing `write` function. */\nexport function createEncoder<TFrom, TSize extends number>(\n    encoder: Omit<FixedSizeEncoder<TFrom, TSize>, 'encode'>,\n): FixedSizeEncoder<TFrom, TSize>;\nexport function createEncoder<TFrom>(encoder: Omit<VariableSizeEncoder<TFrom>, 'encode'>): VariableSizeEncoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom> {\n    return Object.freeze({\n        ...encoder,\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/** Fills the missing `decode` function using the existing `read` function. */\nexport function createDecoder<TTo, TSize extends number>(\n    decoder: Omit<FixedSizeDecoder<TTo, TSize>, 'decode'>,\n): FixedSizeDecoder<TTo, TSize>;\nexport function createDecoder<TTo>(decoder: Omit<VariableSizeDecoder<TTo>, 'decode'>): VariableSizeDecoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo> {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0],\n    });\n}\n\n/** Fills the missing `encode` and `decode` function using the existing `write` and `read` functions. */\nexport function createCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number>(\n    codec: Omit<FixedSizeCodec<TFrom, TTo, TSize>, 'decode' | 'encode'>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec: Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo> {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\nexport function isFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function isFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): decoder is FixedSizeDecoder<TTo, TSize>;\nexport function isFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function isFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): codec is { fixedSize: TSize };\nexport function isFixedSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { fixedSize: number } {\n    return 'fixedSize' in codec && typeof codec.fixedSize === 'number';\n}\n\nexport function assertIsFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): asserts encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function assertIsFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): asserts decoder is FixedSizeDecoder<TTo, TSize>;\nexport function assertIsFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): asserts codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function assertIsFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): asserts codec is { fixedSize: TSize };\nexport function assertIsFixedSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { fixedSize: number } {\n    if (!isFixedSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\n\nexport function isVariableSize<TFrom>(encoder: Encoder<TFrom>): encoder is VariableSizeEncoder<TFrom>;\nexport function isVariableSize<TTo>(decoder: Decoder<TTo>): decoder is VariableSizeDecoder<TTo>;\nexport function isVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): codec is VariableSizeCodec<TFrom, TTo>;\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number };\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number } {\n    return !isFixedSize(codec);\n}\n\nexport function assertIsVariableSize<T>(encoder: Encoder<T>): asserts encoder is VariableSizeEncoder<T>;\nexport function assertIsVariableSize<T>(decoder: Decoder<T>): asserts decoder is VariableSizeDecoder<T>;\nexport function assertIsVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): asserts codec is VariableSizeCodec<TFrom, TTo>;\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number };\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number } {\n    if (!isVariableSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    Codec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\n\n/**\n * Combines an encoder and a decoder into a codec.\n * The encoder and decoder must have the same fixed size, max size and description.\n * If a description is provided, it will override the encoder and decoder descriptions.\n */\nexport function combineCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: VariableSizeEncoder<TFrom>,\n    decoder: VariableSizeDecoder<TTo>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo> {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize,\n        });\n    }\n\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize,\n        });\n    }\n\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write,\n    };\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport { fixBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    Offset,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Creates a fixed-size encoder from a given encoder.\n *\n * @param encoder - The encoder to wrap into a fixed-size encoder.\n * @param fixedBytes - The fixed number of bytes to write.\n */\nexport function fixEncoder<TFrom, TSize extends number>(\n    encoder: Encoder<TFrom>,\n    fixedBytes: TSize,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value: TFrom, bytes: Uint8Array, offset: Offset) => {\n            // Here we exceptionally use the `encode` function instead of the `write`\n            // function as using the nested `write` function on a fixed-sized byte\n            // array may result in a out-of-bounds error on the nested encoder.\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray =\n                variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        },\n    });\n}\n\n/**\n * Creates a fixed-size decoder from a given decoder.\n *\n * @param decoder - The decoder to wrap into a fixed-size decoder.\n * @param fixedBytes - The fixed number of bytes to read.\n */\nexport function fixDecoder<TTo, TSize extends number>(\n    decoder: Decoder<TTo>,\n    fixedBytes: TSize,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes: Uint8Array, offset: Offset) => {\n            assertByteArrayHasEnoughBytesForCodec('fixCodec', fixedBytes, bytes, offset);\n            // Slice the byte array to the fixed size if necessary.\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            // If the nested decoder is fixed-size, pad and truncate the byte array accordingly.\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            // Decode the value using the nested decoder.\n            const [value] = decoder.read(bytes, 0);\n            return [value, offset + fixedBytes];\n        },\n    });\n}\n\n/**\n * Creates a fixed-size codec from a given codec.\n *\n * @param codec - The codec to wrap into a fixed-size codec.\n * @param fixedBytes - The fixed number of bytes to read/write.\n */\nexport function fixCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: Codec<TFrom, TTo>,\n    fixedBytes: TSize,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(fixEncoder(codec, fixedBytes), fixDecoder(codec, fixedBytes));\n}\n","import {\n    Codec,\n    createCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isVariableSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\n\n/**\n * Converts an encoder A to a encoder B by mapping their values.\n */\nexport function mapEncoder<TOldFrom, TNewFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TOldFrom, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeEncoder<TNewFrom, TSize>;\nexport function mapEncoder<TOldFrom, TNewFrom>(\n    encoder: VariableSizeEncoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeEncoder<TNewFrom>;\nexport function mapEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom>;\nexport function mapEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom> {\n    return createEncoder({\n        ...(isVariableSize(encoder)\n            ? { ...encoder, getSizeFromValue: (value: TNewFrom) => encoder.getSizeFromValue(unmap(value)) }\n            : encoder),\n        write: (value: TNewFrom, bytes, offset) => encoder.write(unmap(value), bytes, offset),\n    });\n}\n\n/**\n * Converts an decoder A to a decoder B by mapping their values.\n */\nexport function mapDecoder<TOldTo, TNewTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TOldTo, TSize>,\n    map: (value: TOldTo, bytes: Uint8Array, offset: number) => TNewTo,\n): FixedSizeDecoder<TNewTo, TSize>;\nexport function mapDecoder<TOldTo, TNewTo>(\n    decoder: VariableSizeDecoder<TOldTo>,\n    map: (value: TOldTo, bytes: Uint8Array, offset: number) => TNewTo,\n): VariableSizeDecoder<TNewTo>;\nexport function mapDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo>;\nexport function mapDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo> {\n    return createDecoder({\n        ...decoder,\n        read: (bytes: Uint8Array, offset) => {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [map(value, bytes, offset), newOffset];\n        },\n    });\n}\n\n/**\n * Converts a codec A to a codec B by mapping their values.\n */\nexport function mapCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom, TSize extends number>(\n    codec: FixedSizeCodec<TOldFrom, TTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeCodec<TNewFrom, TTo, TSize>;\nexport function mapCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: VariableSizeCodec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeCodec<TNewFrom, TTo>;\nexport function mapCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: Codec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Codec<TNewFrom, TTo>;\nexport function mapCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom, TSize extends number>(\n    codec: FixedSizeCodec<TOldFrom, TOldTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: Uint8Array, offset: number) => TNewTo,\n): FixedSizeCodec<TNewFrom, TNewTo, TSize>;\nexport function mapCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: VariableSizeCodec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: Uint8Array, offset: number) => TNewTo,\n): VariableSizeCodec<TNewFrom, TNewTo>;\nexport function mapCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo>;\nexport function mapCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map?: (value: TOldTo, bytes: Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo> {\n    return createCodec({\n        ...mapEncoder(codec, unmap),\n        read: map ? mapDecoder(codec, map).read : (codec.read as unknown as Decoder<TNewTo>['read']),\n    });\n}\n","import { assertByteArrayOffsetIsNotOutOfRange } from './assertions';\nimport { Codec, createDecoder, createEncoder, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\n\ntype OffsetConfig = {\n    postOffset?: PostOffsetFunction;\n    preOffset?: PreOffsetFunction;\n};\n\ntype PreOffsetFunctionScope = {\n    /** The entire byte array. */\n    bytes: Uint8Array;\n    /** The original offset prior to encode or decode. */\n    preOffset: Offset;\n    /** Wraps the offset to the byte array length. */\n    wrapBytes: (offset: Offset) => Offset;\n};\n\ntype PreOffsetFunction = (scope: PreOffsetFunctionScope) => Offset;\ntype PostOffsetFunction = (\n    scope: PreOffsetFunctionScope & {\n        /** The modified offset used to encode or decode. */\n        newPreOffset: Offset;\n        /** The original offset returned by the encoder or decoder. */\n        postOffset: Offset;\n    },\n) => Offset;\n\n/**\n * Moves the offset of a given encoder.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function offsetEncoder<TEncoder extends Encoder<any>>(encoder: TEncoder, config: OffsetConfig): TEncoder {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPostOffset, bytes.length);\n            return newPostOffset;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Moves the offset of a given decoder.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function offsetDecoder<TDecoder extends Decoder<any>>(decoder: TDecoder, config: OffsetConfig): TDecoder {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPostOffset, bytes.length);\n            return [value, newPostOffset];\n        },\n    }) as TDecoder;\n}\n\n/**\n * Moves the offset of a given codec.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function offsetCodec<TCodec extends Codec<any>>(codec: TCodec, config: OffsetConfig): TCodec {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config)) as TCodec;\n}\n\n/** A modulo function that handles negative dividends and zero divisors. */\nfunction modulo(dividend: number, divisor: number) {\n    if (divisor === 0) return 0;\n    return ((dividend % divisor) + divisor) % divisor;\n}\n","import { SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Updates the size of a given encoder.\n */\nexport function resizeEncoder<TFrom, TSize extends number, TNewSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeEncoder<TFrom, TNewSize>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function resizeEncoder<TEncoder extends Encoder<any>>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function resizeEncoder<TEncoder extends Encoder<any>>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeEncoder',\n            });\n        }\n        return createEncoder({ ...encoder, fixedSize }) as TEncoder;\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: value => {\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: 'resizeEncoder',\n                });\n            }\n            return newSize;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Updates the size of a given decoder.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function resizeDecoder<TFrom, TSize extends number, TNewSize extends number>(\n    decoder: FixedSizeDecoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeDecoder<TFrom, TNewSize>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function resizeDecoder<TDecoder extends Decoder<any>>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function resizeDecoder<TDecoder extends Decoder<any>>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeDecoder',\n            });\n        }\n        return createDecoder({ ...decoder, fixedSize }) as TDecoder;\n    }\n    return decoder;\n}\n\n/**\n * Updates the size of a given codec.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function resizeCodec<TFrom, TTo extends TFrom, TSize extends number, TNewSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeCodec<TFrom, TTo, TNewSize>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function resizeCodec<TCodec extends Codec<any>>(codec: TCodec, resize: (size: number) => number): TCodec;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function resizeCodec<TCodec extends Codec<any>>(codec: TCodec, resize: (size: number) => number): TCodec {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize)) as TCodec;\n}\n","import { Codec, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { offsetDecoder, offsetEncoder } from './offset-codec';\nimport { resizeDecoder, resizeEncoder } from './resize-codec';\n\n/**\n * Adds left padding to the given encoder.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function padLeftEncoder<TEncoder extends Encoder<any>>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given encoder.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function padRightEncoder<TEncoder extends Encoder<any>>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given decoder.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function padLeftDecoder<TDecoder extends Decoder<any>>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given decoder.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function padRightDecoder<TDecoder extends Decoder<any>>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given codec.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function padLeftCodec<TCodec extends Codec<any>>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset)) as TCodec;\n}\n\n/**\n * Adds right padding to the given codec.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function padRightCodec<TCodec extends Codec<any>>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset)) as TCodec;\n}\n","import {\n    assertIsFixedSize,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Reverses the bytes of a fixed-size encoder.\n */\nexport function reverseEncoder<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value: TFrom, bytes, offset) => {\n            const newOffset = encoder.write(value, bytes, offset);\n            const slice = bytes.slice(offset, offset + encoder.fixedSize).reverse();\n            bytes.set(slice, offset);\n            return newOffset;\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size decoder.\n */\nexport function reverseDecoder<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset) => {\n            const reverseEnd = offset + decoder.fixedSize;\n            if (offset === 0 && bytes.length === reverseEnd) {\n                return decoder.read(bytes.reverse(), offset);\n            }\n            const reversedBytes = bytes.slice();\n            reversedBytes.set(bytes.slice(offset, reverseEnd).reverse(), offset);\n            return decoder.read(reversedBytes, offset);\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size codec.\n */\nexport function reverseCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n","import { SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given number is between a given range.\n */\nexport function assertNumberIsBetweenForCodec(\n    codecDescription: string,\n    min: bigint | number,\n    max: bigint | number,\n    value: bigint | number,\n) {\n    if (value < min || value > max) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n            codecDescription,\n            max,\n            min,\n            value,\n        });\n    }\n}\n","import { Codec, Decoder, Encoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\n/** Defines a encoder for numbers and bigints. */\nexport type NumberEncoder = Encoder<bigint | number> | Encoder<number>;\n\n/** Defines a fixed-size encoder for numbers and bigints. */\nexport type FixedSizeNumberEncoder<TSize extends number = number> =\n    | FixedSizeEncoder<bigint | number, TSize>\n    | FixedSizeEncoder<number, TSize>;\n\n/** Defines a decoder for numbers and bigints. */\nexport type NumberDecoder = Decoder<bigint> | Decoder<number>;\n\n/** Defines a fixed-size decoder for numbers and bigints. */\nexport type FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\n\n/** Defines a codec for numbers and bigints. */\nexport type NumberCodec = Codec<bigint | number, bigint> | Codec<number>;\n\n/** Defines a fixed-size codec for numbers and bigints. */\nexport type FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<number, number, TSize>;\n\n/** Defines the config for number codecs that use more than one byte. */\nexport type NumberCodecConfig = {\n    /**\n     * Whether the serializer should use little-endian or big-endian encoding.\n     * @defaultValue `Endian.LITTLE`\n     */\n    endian?: Endian;\n};\n\n/** Defines the endianness of a number serializer. */\nexport enum Endian {\n    LITTLE,\n    BIG,\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getF32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'f32',\n        set: (view, value, le) => view.setFloat32(0, value, le),\n        size: 4,\n    });\n\nexport const getF32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat32(0, le),\n        name: 'f32',\n        size: 4,\n    });\n\nexport const getF32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<number, number, 4> =>\n    combineCodec(getF32Encoder(config), getF32Decoder(config));\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    Offset,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\nimport { Endian, NumberCodecConfig } from './common';\n\ntype NumberFactorySharedInput<TSize extends number> = {\n    config?: NumberCodecConfig;\n    name: string;\n    size: TSize;\n};\n\ntype NumberFactoryEncoderInput<TFrom, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    range?: [bigint | number, bigint | number];\n    set: (view: DataView, value: TFrom, littleEndian?: boolean) => void;\n};\n\ntype NumberFactoryDecoderInput<TTo, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    get: (view: DataView, littleEndian?: boolean) => TTo;\n};\n\nfunction isLittleEndian(config?: NumberCodecConfig): boolean {\n    return config?.endian === Endian.BIG ? false : true;\n}\n\nexport function numberEncoderFactory<TFrom extends bigint | number, TSize extends number>(\n    input: NumberFactoryEncoderInput<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: input.size,\n        write(value: TFrom, bytes: Uint8Array, offset: Offset): Offset {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        },\n    });\n}\n\nexport function numberDecoderFactory<TTo extends bigint | number, TSize extends number>(\n    input: NumberFactoryDecoderInput<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: input.size,\n        read(bytes, offset = 0): [TTo, number] {\n            assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);\n            assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);\n            const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n            return [input.get(view, isLittleEndian(input.config)), offset + input.size];\n        },\n    });\n}\n\n/**\n * Helper function to ensure that the ArrayBuffer is converted properly from a Uint8Array\n * Source: https://stackoverflow.com/questions/37228285/uint8array-to-arraybuffer\n */\nfunction toArrayBuffer(bytes: Uint8Array, offset?: number, length?: number): ArrayBuffer {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getF64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'f64',\n        set: (view, value, le) => view.setFloat64(0, value, le),\n        size: 8,\n    });\n\nexport const getF64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat64(0, le),\n        name: 'f64',\n        size: 8,\n    });\n\nexport const getF64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<number, number, 8> =>\n    combineCodec(getF64Encoder(config), getF64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'i128',\n        range: [-BigInt('0x7fffffffffffffffffffffffffffffff') - 1n, BigInt('0x7fffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\nexport const getI128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'i128',\n        size: 16,\n    });\n\nexport const getI128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getI128Encoder(config), getI128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'i16',\n        range: [-Number('0x7fff') - 1, Number('0x7fff')],\n        set: (view, value, le) => view.setInt16(0, value, le),\n        size: 2,\n    });\n\nexport const getI16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt16(0, le),\n        name: 'i16',\n        size: 2,\n    });\n\nexport const getI16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<number, number, 2> =>\n    combineCodec(getI16Encoder(config), getI16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'i32',\n        range: [-Number('0x7fffffff') - 1, Number('0x7fffffff')],\n        set: (view, value, le) => view.setInt32(0, value, le),\n        size: 4,\n    });\n\nexport const getI32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt32(0, le),\n        name: 'i32',\n        size: 4,\n    });\n\nexport const getI32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<number, number, 4> =>\n    combineCodec(getI32Encoder(config), getI32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'i64',\n        range: [-BigInt('0x7fffffffffffffff') - 1n, BigInt('0x7fffffffffffffff')],\n        set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n        size: 8,\n    });\n\nexport const getI64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigInt64(0, le),\n        name: 'i64',\n        size: 8,\n    });\n\nexport const getI64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getI64Encoder(config), getI64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI8Encoder = (): FixedSizeEncoder<number, 1> =>\n    numberEncoderFactory({\n        name: 'i8',\n        range: [-Number('0x7f') - 1, Number('0x7f')],\n        set: (view, value) => view.setInt8(0, value),\n        size: 1,\n    });\n\nexport const getI8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getInt8(0),\n        name: 'i8',\n        size: 1,\n    });\n\nexport const getI8Codec = (): FixedSizeCodec<number, number, 1> => combineCodec(getI8Encoder(), getI8Decoder());\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Offset,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\n\n/**\n * Encodes short u16 numbers.\n * @see {@link getShortU16Codec} for a more detailed description.\n */\nexport const getShortU16Encoder = (): VariableSizeEncoder<number> =>\n    createEncoder({\n        getSizeFromValue: (value: number): number => {\n            if (value <= 0b01111111) return 1;\n            if (value <= 0b0011111111111111) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value: number, bytes: Uint8Array, offset: Offset): Offset => {\n            assertNumberIsBetweenForCodec('shortU16', 0, 65535, value);\n            const shortU16Bytes = [0];\n            for (let ii = 0; ; ii += 1) {\n                // Shift the bits of the value over such that the next 7 bits are at the right edge.\n                const alignedValue = value >> (ii * 7);\n                if (alignedValue === 0) {\n                    // No more bits to consume.\n                    break;\n                }\n                // Extract those 7 bits using a mask.\n                const nextSevenBits = 0b1111111 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) {\n                    // Set the continuation bit of the previous slice.\n                    shortU16Bytes[ii - 1] |= 0b10000000;\n                }\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        },\n    });\n\n/**\n * Decodes short u16 numbers.\n * @see {@link getShortU16Codec} for a more detailed description.\n */\nexport const getShortU16Decoder = (): VariableSizeDecoder<number> =>\n    createDecoder({\n        maxSize: 3,\n        read: (bytes: Uint8Array, offset): [number, Offset] => {\n            let value = 0;\n            let byteCount = 0;\n            while (++byteCount) {\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 0b1111111 & currentByte;\n                // Insert the next group of seven bits into the correct slot of the output value.\n                value |= nextSevenBits << (byteIndex * 7);\n                if ((currentByte & 0b10000000) === 0) {\n                    // This byte does not have its continuation bit set. We're done.\n                    break;\n                }\n            }\n            return [value, offset + byteCount];\n        },\n    });\n\n/**\n * Encodes and decodes short u16 numbers.\n *\n * Short u16 numbers are the same as u16, but serialized with 1 to 3 bytes.\n * If the value is above 0x7f, the top bit is set and the remaining\n * value is stored in the next bytes. Each byte follows the same\n * pattern until the 3rd byte. The 3rd byte, if needed, uses\n * all 8 bits to store the last byte of the original value.\n */\nexport const getShortU16Codec = (): VariableSizeCodec<number> =>\n    combineCodec(getShortU16Encoder(), getShortU16Decoder());\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'u128',\n        range: [0n, BigInt('0xffffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\nexport const getU128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'u128',\n        size: 16,\n    });\n\nexport const getU128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getU128Encoder(config), getU128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'u16',\n        range: [0, Number('0xffff')],\n        set: (view, value, le) => view.setUint16(0, value, le),\n        size: 2,\n    });\n\nexport const getU16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint16(0, le),\n        name: 'u16',\n        size: 2,\n    });\n\nexport const getU16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<number, number, 2> =>\n    combineCodec(getU16Encoder(config), getU16Decoder(config));\n","import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string matches a given alphabet.\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Encodes a string using a custom alphabet by dividing\n * by the base and handling leading zeroes.\n * @see {@link getBaseXCodec} for a more detailed description.\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Decodes a string using a custom alphabet by dividing\n * by the base and handling leading zeroes.\n * @see {@link getBaseXCodec} for a more detailed description.\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * A string codec that requires a custom alphabet and uses\n * the length of that alphabet as the base. It then divides\n * the input by the base as many times as necessary to get\n * the output. It also supports leading zeroes by using the\n * first character of the alphabet as the zero character.\n *\n * This can be used to create codecs such as base10 or base58.\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/** Encodes strings in base10. */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/** Decodes strings in base10. */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/** Encodes and decodes strings in base10. */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/** Encodes strings in base16. */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const lowercaseValue = value.toLowerCase();\n            assertValidBaseString('0123456789abcdef', lowercaseValue, value);\n            const matches = lowercaseValue.match(/.{1,2}/g);\n            const hexBytes = matches ? matches.map((byte: string) => parseInt(byte, 16)) : [];\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/** Decodes strings in base16. */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/** Encodes and decodes strings in base16. */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/** Encodes strings in base58. */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/** Decodes strings in base58. */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/** Encodes and decodes strings in base58. */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    mapDecoder,\n    mapEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/** Encodes strings in base64. */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch (e) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch (e) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return mapEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/** Decodes strings in base64. */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return mapDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/** Encodes and decodes strings in base64. */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Encodes a string using a custom alphabet by reslicing the bits of the byte array.\n * @see {@link getBaseXResliceCodec} for a more detailed description.\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Decodes a string using a custom alphabet by reslicing the bits of the byte array.\n * @see {@link getBaseXResliceCodec} for a more detailed description.\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * A string serializer that reslices bytes into custom chunks\n * of bits that are then mapped to a custom alphabet.\n *\n * This can be used to create serializers whose alphabet\n * is a power of 2 such as base16 or base64.\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","/**Removes null characters from a string. */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/** Pads a string with null characters at the end. */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    fixDecoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoder,\n    getEncodedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getU32Decoder, getU32Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { getUtf8Decoder, getUtf8Encoder } from './utf8';\n\n/** Defines the config for string codecs. */\nexport type StringCodecConfig<\n    TPrefix extends NumberCodec | NumberDecoder | NumberEncoder,\n    TEncoding extends Codec<string> | Decoder<string> | Encoder<string>,\n> = {\n    /**\n     * The codec to use for encoding and decoding the content.\n     * @defaultValue UTF-8 encoding.\n     */\n    encoding?: TEncoding;\n\n    /**\n     * The size of the string. It can be one of the following:\n     * - a {@link NumberCodec} that prefixes the string with its size.\n     * - a fixed number of bytes.\n     * - or `'variable'` to use the rest of the byte array.\n     * @defaultValue u32 prefix.\n     */\n    size?: TPrefix | number | 'variable';\n};\n\n/** Encodes strings from a given encoding and size strategy. */\nexport function getStringEncoder<TSize extends number>(\n    config: StringCodecConfig<NumberEncoder, Encoder<string>> & { size: TSize },\n): FixedSizeEncoder<string, TSize>;\nexport function getStringEncoder<TSize extends number>(\n    config: StringCodecConfig<NumberEncoder, Encoder<string>> & {\n        encoding: FixedSizeEncoder<string, TSize>;\n        size: 'variable';\n    },\n): FixedSizeEncoder<string, TSize>;\nexport function getStringEncoder(\n    config?: StringCodecConfig<NumberEncoder, Encoder<string>>,\n): VariableSizeEncoder<string>;\nexport function getStringEncoder(config: StringCodecConfig<NumberEncoder, Encoder<string>> = {}): Encoder<string> {\n    const size = config.size ?? getU32Encoder();\n    const encoding = config.encoding ?? getUtf8Encoder();\n\n    if (size === 'variable') {\n        return encoding;\n    }\n\n    if (typeof size === 'number') {\n        return fixEncoder(encoding, size);\n    }\n\n    return createEncoder({\n        getSizeFromValue: (value: string) => {\n            const contentSize = getEncodedSize(value, encoding);\n            return getEncodedSize(contentSize, size) + contentSize;\n        },\n        write: (value: string, bytes, offset) => {\n            const contentSize = getEncodedSize(value, encoding);\n            offset = size.write(contentSize, bytes, offset);\n            return encoding.write(value, bytes, offset);\n        },\n    });\n}\n\n/** Decodes strings from a given encoding and size strategy. */\nexport function getStringDecoder<TSize extends number>(\n    config: StringCodecConfig<NumberDecoder, Decoder<string>> & { size: TSize },\n): FixedSizeDecoder<string, TSize>;\nexport function getStringDecoder<TSize extends number>(\n    config: StringCodecConfig<NumberDecoder, Decoder<string>> & {\n        encoding: FixedSizeDecoder<string, TSize>;\n        size: 'variable';\n    },\n): FixedSizeDecoder<string, TSize>;\nexport function getStringDecoder(\n    config?: StringCodecConfig<NumberDecoder, Decoder<string>>,\n): VariableSizeDecoder<string>;\nexport function getStringDecoder(config: StringCodecConfig<NumberDecoder, Decoder<string>> = {}): Decoder<string> {\n    const size = config.size ?? getU32Decoder();\n    const encoding = config.encoding ?? getUtf8Decoder();\n\n    if (size === 'variable') {\n        return encoding;\n    }\n\n    if (typeof size === 'number') {\n        return fixDecoder(encoding, size);\n    }\n\n    return createDecoder({\n        read: (bytes: Uint8Array, offset = 0) => {\n            assertByteArrayIsNotEmptyForCodec('string', bytes, offset);\n            const [lengthBigInt, lengthOffset] = size.read(bytes, offset);\n            const length = Number(lengthBigInt);\n            offset = lengthOffset;\n            const contentBytes = bytes.slice(offset, offset + length);\n            assertByteArrayHasEnoughBytesForCodec('string', length, contentBytes);\n            const [value, contentOffset] = encoding.read(contentBytes, 0);\n            offset += contentOffset;\n            return [value, offset];\n        },\n    });\n}\n\n/** Encodes and decodes strings from a given encoding and size strategy. */\nexport function getStringCodec<TSize extends number>(\n    config: StringCodecConfig<NumberCodec, Codec<string>> & { size: TSize },\n): FixedSizeCodec<string, string, TSize>;\nexport function getStringCodec<TSize extends number>(\n    config: StringCodecConfig<NumberCodec, Codec<string>> & {\n        encoding: FixedSizeCodec<string, string, TSize>;\n        size: 'variable';\n    },\n): FixedSizeCodec<string, string, TSize>;\nexport function getStringCodec(config?: StringCodecConfig<NumberCodec, Codec<string>>): VariableSizeCodec<string>;\nexport function getStringCodec(config: StringCodecConfig<NumberCodec, Codec<string>> = {}): Codec<string> {\n    return combineCodec(getStringEncoder(config), getStringDecoder(config));\n}\n","import {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/** Encodes UTF-8 strings using the native `TextEncoder` API. */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/** Decodes UTF-8 strings using the native `TextDecoder` API. */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/** Encodes and decodes UTF-8 strings using the native `TextEncoder` and `TextDecoder` API. */\nexport const getUtf8Codec = (): Codec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import type { Decoder } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SolanaError,\n} from '@solana/errors';\n\nimport type { Account, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\n\n/** Decodes the data of a given account using the provided decoder. */\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): MaybeAccount<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    try {\n        if ('exists' in encodedAccount && !encodedAccount.exists) {\n            return encodedAccount;\n        }\n        return Object.freeze({ ...encodedAccount, data: decoder.decode(encodedAccount.data) });\n    } catch (e) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT, {\n            address: encodedAccount.address,\n        });\n    }\n}\n\nfunction accountExists<TData extends object>(account: Account<TData> | MaybeAccount<TData>): account is Account<TData> {\n    return !('exists' in account) || ('exists' in account && account.exists);\n}\n\n/** Asserts that an account has been decoded. */\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is MaybeAccount<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress> | MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    if (accountExists(account) && account.data instanceof Uint8Array) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT, {\n            address: account.address,\n        });\n    }\n}\n\n/** Asserts that all accounts have been decoded. */\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: Account<TData | Uint8Array, TAddress>[],\n): asserts accounts is Account<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: MaybeAccount<TData | Uint8Array, TAddress>[],\n): asserts accounts is MaybeAccount<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: (Account<TData | Uint8Array, TAddress> | MaybeAccount<TData | Uint8Array, TAddress>)[],\n): asserts accounts is (Account<TData, TAddress> | MaybeAccount<TData, TAddress>)[] {\n    const encoded = accounts.filter(a => accountExists(a) && a.data instanceof Uint8Array);\n    if (encoded.length > 0) {\n        const encodedAddresses = encoded.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED, {\n            addresses: encodedAddresses,\n        });\n    }\n}\n","import type { Address } from '@solana/addresses';\nimport { getBase58Encoder, getBase64Encoder } from '@solana/codecs-strings';\nimport type {\n    AccountInfoBase,\n    AccountInfoWithBase58Bytes,\n    AccountInfoWithBase58EncodedData,\n    AccountInfoWithBase64EncodedData,\n} from '@solana/rpc-types';\n\nimport type { Account, BaseAccount, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport type { JsonParsedDataResponse } from './rpc-api';\n\ntype Base64EncodedRpcAccount = AccountInfoBase & AccountInfoWithBase64EncodedData;\n\n/** Parse an account object received from a base64-encoded RPC call into an EncodedAccount or MaybeEncodedAccount type. */\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase64Encoder().encode(rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype Base58EncodedRpcAccount = AccountInfoBase & (AccountInfoWithBase58Bytes | AccountInfoWithBase58EncodedData);\n\n/** Parse an account object received from a base58-encoded RPC call into an EncodedAccount or MaybeEncodedAccount type. */\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase58Encoder().encode(typeof rpcAccount.data === 'string' ? rpcAccount.data : rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype JsonParsedRpcAccount = AccountInfoBase & { readonly data: JsonParsedDataResponse<unknown> };\n\n/** Parse an account object received from a json-parsed RPC call into an Account or MaybeAccount type. */\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount,\n): Account<TData, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): MaybeAccount<TData, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = rpcAccount.data.parsed.info as TData;\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\nfunction parseBaseAccount(rpcAccount: AccountInfoBase): BaseAccount {\n    return Object.freeze({\n        executable: rpcAccount.executable,\n        lamports: rpcAccount.lamports,\n        programAddress: rpcAccount.owner,\n    });\n}\n","import type { Address } from '@solana/addresses';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Commitment, Slot } from '@solana/rpc-types';\n\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport { parseBase64RpcAccount, parseJsonRpcAccount } from './parse-account';\nimport type { GetAccountInfoApi, GetMultipleAccountsApi } from './rpc-api';\n\n/** Optional configuration for fetching a singular account. */\nexport type FetchAccountConfig = {\n    abortSignal?: AbortSignal;\n    commitment?: Commitment;\n    minContextSlot?: Slot;\n};\n\n/** Fetch a base64-encoded account that may or may not exist using an RPC client. */\nexport async function fetchEncodedAccount<TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<MaybeEncodedAccount<TAddress>> {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc.getAccountInfo(address, { ...rpcConfig, encoding: 'base64' }).send({ abortSignal });\n    return parseBase64RpcAccount(address, response.value);\n}\n\n/** Fetch a json-parsed account that may or may not exist using an RPC client. */\nexport async function fetchJsonParsedAccount<TData extends object, TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<MaybeAccount<TData, TAddress> | MaybeEncodedAccount<TAddress>> {\n    const { abortSignal, ...rpcConfig } = config;\n    const { value: account } = await rpc\n        .getAccountInfo(address, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return !!account && typeof account === 'object' && 'parsed' in account.data\n        ? parseJsonRpcAccount<TData, TAddress>(address, account as Parameters<typeof parseJsonRpcAccount>[1])\n        : parseBase64RpcAccount<TAddress>(address, account as Parameters<typeof parseBase64RpcAccount>[1]);\n}\n\n/** Optional configuration for fetching multiple accounts. */\nexport type FetchAccountsConfig = {\n    abortSignal?: AbortSignal;\n    commitment?: Commitment;\n    minContextSlot?: Slot;\n};\n\n/** Fetch multiple base64-encoded accounts that may or may not exist using an RPC client. */\nexport async function fetchEncodedAccounts<\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'base64' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => parseBase64RpcAccount(addresses[index], account)) as {\n        [P in keyof TAddresses]: MaybeEncodedAccount<TAddresses[P]>;\n    };\n}\n\n/** Fetch multiple json-parsed accounts that may or may not exist using an RPC client. */\nexport async function fetchJsonParsedAccounts<\n    TData extends object[],\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => {\n        return !!account && typeof account === 'object' && 'parsed' in account.data\n            ? parseJsonRpcAccount(addresses[index], account as Parameters<typeof parseJsonRpcAccount>[1])\n            : parseBase64RpcAccount(addresses[index], account as Parameters<typeof parseBase64RpcAccount>[1]);\n    }) as {\n        [P in keyof TAddresses]:\n            | MaybeAccount<TData[P & keyof TData], TAddresses[P]>\n            | MaybeEncodedAccount<TAddresses[P]>;\n    } & {\n        [P in keyof TData]:\n            | MaybeAccount<TData[P], TAddresses[P & keyof TAddresses]>\n            | MaybeEncodedAccount<TAddresses[P & keyof TAddresses]>;\n    };\n}\n","import { Address } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\n\nimport { Account } from './account';\n\n/** Defines a Solana account that may or may not exist after having tried to fetch it. */\nexport type MaybeAccount<TData extends Uint8Array | object, TAddress extends string = string> =\n    | { readonly address: Address<TAddress>; readonly exists: false }\n    | (Account<TData, TAddress> & { readonly exists: true });\n\n/** Defines a Solana account with encoded data that may or may not exist after having tried to fetch it. */\nexport type MaybeEncodedAccount<TAddress extends string = string> = MaybeAccount<Uint8Array, TAddress>;\n\n/** Asserts that an account that may or may not exists, actually exists. */\nexport function assertAccountExists<TData extends Uint8Array | object, TAddress extends string = string>(\n    account: MaybeAccount<TData, TAddress>,\n): asserts account is Account<TData, TAddress> & { exists: true } {\n    if (!account.exists) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND, { address: account.address });\n    }\n}\n\n/** Asserts that all accounts that may or may not exist, actually all exist. */\nexport function assertAccountsExist<TData extends Uint8Array | object, TAddress extends string = string>(\n    accounts: MaybeAccount<TData, TAddress>[],\n): asserts accounts is (Account<TData, TAddress> & { exists: true })[] {\n    const missingAccounts = accounts.filter(a => !a.exists);\n    if (missingAccounts.length > 0) {\n        const missingAddresses = missingAccounts.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND, { addresses: missingAddresses });\n    }\n}\n","import {\n    SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT,\n    SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED,\n    SolanaError,\n} from '@solana/errors';\n\nfunction assertIsSecureContext() {\n    if (__BROWSER__ && !globalThis.isSecureContext) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT);\n    }\n}\n\nlet cachedEd25519Decision: PromiseLike<boolean> | boolean | undefined;\nasync function isEd25519CurveSupported(subtle: SubtleCrypto): Promise<boolean> {\n    if (cachedEd25519Decision === undefined) {\n        cachedEd25519Decision = new Promise(resolve => {\n            subtle\n                .generateKey('Ed25519', /* extractable */ false, ['sign', 'verify'])\n                .catch(() => {\n                    resolve((cachedEd25519Decision = false));\n                })\n                .then(() => {\n                    resolve((cachedEd25519Decision = true));\n                });\n        });\n    }\n    if (typeof cachedEd25519Decision === 'boolean') {\n        return cachedEd25519Decision;\n    } else {\n        return await cachedEd25519Decision;\n    }\n}\n\nexport async function assertDigestCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.digest !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED);\n    }\n}\n\nexport async function assertKeyGenerationIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.generateKey !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED);\n    }\n    if (!(await isEd25519CurveSupported(globalThis.crypto.subtle))) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED);\n    }\n}\n\nexport async function assertKeyExporterIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.exportKey !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED);\n    }\n}\n\nexport async function assertSigningCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.sign !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED);\n    }\n}\n\nexport async function assertVerificationCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.verify !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED);\n    }\n}\n","import {\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    mapEncoder,\n} from '@solana/codecs-core';\nimport { getBase58Decoder, getBase58Encoder, getStringDecoder, getStringEncoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nexport type Address<TAddress extends string = string> = TAddress & {\n    readonly __brand: unique symbol;\n};\n\nlet memoizedBase58Encoder: Encoder<string> | undefined;\nlet memoizedBase58Decoder: Decoder<string> | undefined;\n\nfunction getMemoizedBase58Encoder(): Encoder<string> {\n    if (!memoizedBase58Encoder) memoizedBase58Encoder = getBase58Encoder();\n    return memoizedBase58Encoder;\n}\n\nfunction getMemoizedBase58Decoder(): Decoder<string> {\n    if (!memoizedBase58Decoder) memoizedBase58Decoder = getBase58Decoder();\n    return memoizedBase58Decoder;\n}\n\nexport function isAddress(putativeAddress: string): putativeAddress is Address<typeof putativeAddress> {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest address (32 bytes of zeroes)\n        putativeAddress.length < 32 ||\n        // Highest address (32 bytes of 255)\n        putativeAddress.length > 44\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeAddress);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        return false;\n    }\n    return true;\n}\n\nexport function assertIsAddress(putativeAddress: string): asserts putativeAddress is Address<typeof putativeAddress> {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest address (32 bytes of zeroes)\n        putativeAddress.length < 32 ||\n        // Highest address (32 bytes of 255)\n        putativeAddress.length > 44\n    ) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeAddress.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeAddress);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\nexport function address<TAddress extends string = string>(putativeAddress: TAddress): Address<TAddress> {\n    assertIsAddress(putativeAddress);\n    return putativeAddress as Address<TAddress>;\n}\n\nexport function getAddressEncoder(): FixedSizeEncoder<Address, 32> {\n    return mapEncoder(getStringEncoder({ encoding: getMemoizedBase58Encoder(), size: 32 }), putativeAddress =>\n        address(putativeAddress),\n    );\n}\n\nexport function getAddressDecoder(): FixedSizeDecoder<Address, 32> {\n    return getStringDecoder({ encoding: getMemoizedBase58Decoder(), size: 32 }) as FixedSizeDecoder<Address, 32>;\n}\n\nexport function getAddressCodec(): FixedSizeCodec<Address, Address, 32> {\n    return combineCodec(getAddressEncoder(), getAddressDecoder());\n}\n\nexport function getAddressComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n","import { assertDigestCapabilityIsAvailable } from '@solana/assertions';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,\n    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,\n    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,\n    SolanaError,\n} from '@solana/errors';\n\nimport { Address, assertIsAddress, getAddressCodec, isAddress } from './address';\nimport { compressedPointBytesAreOnCurve } from './curve';\n\n/**\n * An address derived from a program address and a set of seeds.\n * It includes the bump seed used to derive the address and\n * ensure the address is not on the Ed25519 curve.\n */\nexport type ProgramDerivedAddress<TAddress extends string = string> = Readonly<\n    [Address<TAddress>, ProgramDerivedAddressBump]\n>;\n\n/**\n * A number between 0 and 255, inclusive.\n */\nexport type ProgramDerivedAddressBump = number & {\n    readonly __brand: unique symbol;\n};\n\n/**\n * Returns true if the input value is a program derived address.\n */\nexport function isProgramDerivedAddress<TAddress extends string = string>(\n    value: unknown,\n): value is ProgramDerivedAddress<TAddress> {\n    return (\n        Array.isArray(value) &&\n        value.length === 2 &&\n        typeof value[0] === 'string' &&\n        typeof value[1] === 'number' &&\n        value[1] >= 0 &&\n        value[1] <= 255 &&\n        isAddress(value[0])\n    );\n}\n\n/**\n * Fails if the input value is not a program derived address.\n */\nexport function assertIsProgramDerivedAddress<TAddress extends string = string>(\n    value: unknown,\n): asserts value is ProgramDerivedAddress<TAddress> {\n    const validFormat =\n        Array.isArray(value) && value.length === 2 && typeof value[0] === 'string' && typeof value[1] === 'number';\n    if (!validFormat) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MALFORMED_PDA);\n    }\n    if (value[1] < 0 || value[1] > 255) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE, {\n            bump: value[1],\n        });\n    }\n    assertIsAddress(value[0]);\n}\n\ntype ProgramDerivedAddressInput = Readonly<{\n    programAddress: Address;\n    seeds: Seed[];\n}>;\n\ntype SeedInput = Readonly<{\n    baseAddress: Address;\n    programAddress: Address;\n    seed: Seed;\n}>;\n\ntype Seed = Uint8Array | string;\n\nconst MAX_SEED_LENGTH = 32;\nconst MAX_SEEDS = 16;\nconst PDA_MARKER_BYTES = [\n    // The string 'ProgramDerivedAddress'\n    80, 114, 111, 103, 114, 97, 109, 68, 101, 114, 105, 118, 101, 100, 65, 100, 100, 114, 101, 115, 115,\n] as const;\n\nasync function createProgramDerivedAddress({ programAddress, seeds }: ProgramDerivedAddressInput): Promise<Address> {\n    await assertDigestCapabilityIsAvailable();\n    if (seeds.length > MAX_SEEDS) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED, {\n            actual: seeds.length,\n            maxSeeds: MAX_SEEDS,\n        });\n    }\n    let textEncoder: TextEncoder;\n    const seedBytes = seeds.reduce((acc, seed, ii) => {\n        const bytes = typeof seed === 'string' ? (textEncoder ||= new TextEncoder()).encode(seed) : seed;\n        if (bytes.byteLength > MAX_SEED_LENGTH) {\n            throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n                actual: bytes.byteLength,\n                index: ii,\n                maxSeedLength: MAX_SEED_LENGTH,\n            });\n        }\n        acc.push(...bytes);\n        return acc;\n    }, [] as number[]);\n    const base58EncodedAddressCodec = getAddressCodec();\n    const programAddressBytes = base58EncodedAddressCodec.encode(programAddress);\n    const addressBytesBuffer = await crypto.subtle.digest(\n        'SHA-256',\n        new Uint8Array([...seedBytes, ...programAddressBytes, ...PDA_MARKER_BYTES]),\n    );\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n    if (await compressedPointBytesAreOnCurve(addressBytes)) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE);\n    }\n    return base58EncodedAddressCodec.decode(addressBytes);\n}\n\nexport async function getProgramDerivedAddress({\n    programAddress,\n    seeds,\n}: ProgramDerivedAddressInput): Promise<ProgramDerivedAddress> {\n    let bumpSeed = 255;\n    while (bumpSeed > 0) {\n        try {\n            const address = await createProgramDerivedAddress({\n                programAddress,\n                seeds: [...seeds, new Uint8Array([bumpSeed])],\n            });\n            return [address, bumpSeed as ProgramDerivedAddressBump];\n        } catch (e) {\n            if (isSolanaError(e, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE)) {\n                bumpSeed--;\n            } else {\n                throw e;\n            }\n        }\n    }\n    throw new SolanaError(SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED);\n}\n\nexport async function createAddressWithSeed({ baseAddress, programAddress, seed }: SeedInput): Promise<Address> {\n    const { encode, decode } = getAddressCodec();\n\n    const seedBytes = typeof seed === 'string' ? new TextEncoder().encode(seed) : seed;\n    if (seedBytes.byteLength > MAX_SEED_LENGTH) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n            actual: seedBytes.byteLength,\n            index: 0,\n            maxSeedLength: MAX_SEED_LENGTH,\n        });\n    }\n\n    const programAddressBytes = encode(programAddress);\n    if (\n        programAddressBytes.length >= PDA_MARKER_BYTES.length &&\n        programAddressBytes.slice(-PDA_MARKER_BYTES.length).every((byte, index) => byte === PDA_MARKER_BYTES[index])\n    ) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER);\n    }\n\n    const addressBytesBuffer = await crypto.subtle.digest(\n        'SHA-256',\n        new Uint8Array([...encode(baseAddress), ...seedBytes, ...programAddressBytes]),\n    );\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n\n    return decode(addressBytes);\n}\n","/**!\n * noble-ed25519\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2019 Paul Miller (https://paulmillr.com)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the “Software”), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nconst D = 37095705934669439343138083508754565189542113879843219016388785533085940283555n;\nconst P = 57896044618658097711785492504343953926634992332820282019728792003956564819949n; // 2n ** 255n - 19n;  ed25519 is twisted edwards curve\nconst RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n; // √-1\n\n// mod division\nfunction mod(a: bigint): bigint {\n    const r = a % P;\n    return r >= 0n ? r : P + r;\n}\nfunction pow2(x: bigint, power: bigint): bigint {\n    // pow2(x, 4) == x^(2^4)\n    let r = x;\n    while (power-- > 0n) {\n        r *= r;\n        r %= P;\n    }\n    return r;\n}\nfunction pow_2_252_3(x: bigint): bigint {\n    // x^(2^252-3) unrolled util for square root\n    const x2 = (x * x) % P; // x^2,       bits 1\n    const b2 = (x2 * x) % P; // x^3,       bits 11\n    const b4 = (pow2(b2, 2n) * b2) % P; // x^(2^4-1), bits 1111\n    const b5 = (pow2(b4, 1n) * x) % P; // x^(2^5-1), bits 11111\n    const b10 = (pow2(b5, 5n) * b5) % P; // x^(2^10)\n    const b20 = (pow2(b10, 10n) * b10) % P; // x^(2^20)\n    const b40 = (pow2(b20, 20n) * b20) % P; // x^(2^40)\n    const b80 = (pow2(b40, 40n) * b40) % P; // x^(2^80)\n    const b160 = (pow2(b80, 80n) * b80) % P; // x^(2^160)\n    const b240 = (pow2(b160, 80n) * b80) % P; // x^(2^240)\n    const b250 = (pow2(b240, 10n) * b10) % P; // x^(2^250)\n    const pow_p_5_8 = (pow2(b250, 2n) * x) % P; // < To pow to (p+3)/8, multiply it by x.\n    return pow_p_5_8;\n}\nfunction uvRatio(u: bigint, v: bigint): bigint | null {\n    // for sqrt comp\n    const v3 = mod(v * v * v); // v³\n    const v7 = mod(v3 * v3 * v); // v⁷\n    const pow = pow_2_252_3(u * v7); // (uv⁷)^(p-5)/8\n    let x = mod(u * v3 * pow); // (uv³)(uv⁷)^(p-5)/8\n    const vx2 = mod(v * x * x); // vx²\n    const root1 = x; // First root candidate\n    const root2 = mod(x * RM1); // Second root candidate; RM1 is √-1\n    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n    const useRoot2 = vx2 === mod(-u); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === mod(-u * RM1); // There is no valid root, vx² = -u√-1\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n    if ((mod(x) & 1n) === 1n) x = mod(-x); // edIsNegative\n    if (!useRoot1 && !useRoot2) {\n        return null;\n    }\n    return x;\n}\n// https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.3\nexport function pointIsOnCurve(y: bigint, lastByte: number): boolean {\n    const y2 = mod(y * y); // y²\n    const u = mod(y2 - 1n); // u=y²-1\n    const v = mod(D * y2 + 1n);\n    const x = uvRatio(u, v); // (uv³)(uv⁷)^(p-5)/8; square root\n    if (x === null) {\n        return false;\n    }\n    const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n    if (x === 0n && isLastByteOdd) {\n        return false;\n    }\n    return true;\n}\n","import { pointIsOnCurve } from './vendor/noble/ed25519';\n\nfunction byteToHex(byte: number): string {\n    const hexString = byte.toString(16);\n    if (hexString.length === 1) {\n        return `0${hexString}`;\n    } else {\n        return hexString;\n    }\n}\n\nfunction decompressPointBytes(bytes: Uint8Array): bigint {\n    const hexString = bytes.reduce((acc, byte, ii) => `${byteToHex(ii === 31 ? byte & ~0x80 : byte)}${acc}`, '');\n    const integerLiteralString = `0x${hexString}`;\n    return BigInt(integerLiteralString);\n}\n\nexport async function compressedPointBytesAreOnCurve(bytes: Uint8Array): Promise<boolean> {\n    if (bytes.byteLength !== 32) {\n        return false;\n    }\n    const y = decompressPointBytes(bytes);\n    return pointIsOnCurve(y, bytes[31]);\n}\n","import {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getU32Decoder, getU32Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { getFixedSize, getMaxSize } from './utils';\n\n/**\n * Represents all the size options for array-like codecs\n * — i.e. `array`, `map` and `set`.\n *\n * It can be one of the following:\n * - a {@link NumberCodec} that prefixes its content with its size.\n * - a fixed number of items.\n * - or `'remainder'` to infer the number of items by dividing\n *   the rest of the byte array by the fixed size of its item.\n *   Note that this option is only available for fixed-size items.\n */\nexport type ArrayLikeCodecSize<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> =\n    | TPrefix\n    | number\n    | 'remainder';\n\n/** Defines the configs for array codecs. */\nexport type ArrayCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the array.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Encodes an array of items.\n *\n * @param item - The encoder to use for the array's items.\n * @param config - A set of config for the encoder.\n */\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<TFrom[], 0>;\nexport function getArrayEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: ArrayCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom[]> {\n    const size = config.size ?? getU32Encoder();\n    const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize !== null\n            ? { fixedSize }\n            : {\n                  getSizeFromValue: (array: TFrom[]) => {\n                      const prefixSize = typeof size === 'object' ? getEncodedSize(array.length, size) : 0;\n                      return prefixSize + [...array].reduce((all, value) => all + getEncodedSize(value, item), 0);\n                  },\n                  maxSize,\n              }),\n        write: (array: TFrom[], bytes, offset) => {\n            if (typeof size === 'number') {\n                assertValidNumberOfItemsForCodec('array', size, array.length);\n            }\n            if (typeof size === 'object') {\n                offset = size.write(array.length, bytes, offset);\n            }\n            array.forEach(value => {\n                offset = item.write(value, bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Decodes an array of items.\n *\n * @param item - The encoder to use for the array's items.\n * @param config - A set of config for the encoder.\n */\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<TTo[], 0>;\nexport function getArrayDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: ArrayCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(item: Decoder<TTo>, config: ArrayCodecConfig<NumberDecoder> = {}): Decoder<TTo[]> {\n    const size = config.size ?? getU32Decoder();\n    const itemSize = getFixedSize(item);\n    const fixedSize = computeArrayLikeCodecSize(size, itemSize);\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize !== null ? { fixedSize } : { maxSize }),\n        read: (bytes: Uint8Array, offset) => {\n            const array: TTo[] = [];\n            if (typeof size === 'object' && bytes.slice(offset).length === 0) {\n                return [array, offset];\n            }\n\n            if (size === 'remainder') {\n                while (offset < bytes.length) {\n                    const [value, newOffset] = item.read(bytes, offset);\n                    offset = newOffset;\n                    array.push(value);\n                }\n                return [array, offset];\n            }\n\n            const [resolvedSize, newOffset] = typeof size === 'number' ? [size, offset] : size.read(bytes, offset);\n            offset = newOffset;\n            for (let i = 0; i < resolvedSize; i += 1) {\n                const [value, newOffset] = item.read(bytes, offset);\n                offset = newOffset;\n                array.push(value);\n            }\n            return [array, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for an array of items.\n *\n * @param item - The codec to use for the array's items.\n * @param config - A set of config for the codec.\n */\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<TFrom[], TTo[], 0>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: ArrayCodecConfig<NumberCodec>,\n): VariableSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> = {},\n): Codec<TFrom[], TTo[]> {\n    return combineCodec(getArrayEncoder(item, config as object), getArrayDecoder(item, config as object));\n}\n\nfunction computeArrayLikeCodecSize(size: number | object | 'remainder', itemSize: number | null): number | null {\n    if (typeof size !== 'number') return null;\n    if (size === 0) return 0;\n    return itemSize === null ? null : itemSize * size;\n}\n","import { SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, SolanaError } from '@solana/errors';\n\n/** Checks the number of items in an array-like structure is expected. */\nexport function assertValidNumberOfItemsForCodec(\n    codecDescription: string,\n    expected: bigint | number,\n    actual: bigint | number,\n) {\n    if (expected !== actual) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n            actual,\n            codecDescription,\n            expected,\n        });\n    }\n}\n","import { isFixedSize } from '@solana/codecs-core';\n\nexport function maxCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce(\n        (all, size) => (all === null || size === null ? null : Math.max(all, size)),\n        0 as number | null,\n    );\n}\n\nexport function sumCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce((all, size) => (all === null || size === null ? null : all + size), 0 as number | null);\n}\n\nexport function getFixedSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : null;\n}\n\nexport function getMaxSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : codec.maxSize ?? null;\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from '@solana/codecs-core';\n\n/** Defines the config for bitArray codecs. */\nexport type BitArrayCodecConfig = {\n    /**\n     * Whether to read the bits in reverse order.\n     * @defaultValue `false`\n     */\n    backward?: boolean;\n};\n\n/**\n * Encodes an array of booleans into bits.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the encoder.\n */\nexport function getBitArrayEncoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeEncoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createEncoder({\n        fixedSize: size,\n        write(value: boolean[], bytes, offset) {\n            const bytesToAdd: number[] = [];\n\n            for (let i = 0; i < size; i += 1) {\n                let byte = 0;\n                for (let j = 0; j < 8; j += 1) {\n                    const feature = Number(value[i * 8 + j] ?? 0);\n                    byte |= feature << (backward ? j : 7 - j);\n                }\n                if (backward) {\n                    bytesToAdd.unshift(byte);\n                } else {\n                    bytesToAdd.push(byte);\n                }\n            }\n\n            bytes.set(bytesToAdd, offset);\n            return size;\n        },\n    });\n}\n\n/**\n * Decodes bits into an array of booleans.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the decoder.\n */\nexport function getBitArrayDecoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeDecoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createDecoder({\n        fixedSize: size,\n        read(bytes, offset) {\n            assertByteArrayHasEnoughBytesForCodec('bitArray', size, bytes, offset);\n            const booleans: boolean[] = [];\n            let slice = bytes.slice(offset, offset + size);\n            slice = backward ? slice.reverse() : slice;\n\n            slice.forEach(byte => {\n                for (let i = 0; i < 8; i += 1) {\n                    if (backward) {\n                        booleans.push(Boolean(byte & 1));\n                        byte >>= 1;\n                    } else {\n                        booleans.push(Boolean(byte & 0b1000_0000));\n                        byte <<= 1;\n                    }\n                }\n            });\n\n            return [booleans, offset + size];\n        },\n    });\n}\n\n/**\n * An array of boolean codec that converts booleans to bits and vice versa.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the codec.\n */\nexport function getBitArrayCodec<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeCodec<boolean[], boolean[], TSize> {\n    return combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));\n}\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    mapDecoder,\n    mapEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\n/** Defines the config for boolean codecs. */\nexport type BooleanCodecConfig<TSize extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The number codec to delegate to.\n     * @defaultValue u8 size.\n     */\n    size?: TSize;\n};\n\n/**\n * Encodes booleans.\n *\n * @param config - A set of config for the encoder.\n */\nexport function getBooleanEncoder(): FixedSizeEncoder<boolean, 1>;\nexport function getBooleanEncoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<boolean, TSize>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder>): Encoder<boolean>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder> = {}): Encoder<boolean> {\n    const size = config.size ?? getU8Encoder();\n    assertIsFixedSize(size);\n    return mapEncoder(size, (value: boolean) => (value ? 1 : 0));\n}\n\n/**\n * Decodes booleans.\n *\n * @param config - A set of config for the decoder.\n */\nexport function getBooleanDecoder(): FixedSizeDecoder<boolean, 1>;\nexport function getBooleanDecoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<boolean, TSize>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder>): Decoder<boolean>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder> = {}): Decoder<boolean> {\n    const size = config.size ?? getU8Decoder();\n    assertIsFixedSize(size);\n    return mapDecoder(size, (value: bigint | number): boolean => Number(value) === 1);\n}\n\n/**\n * Creates a boolean codec.\n *\n * @param config - A set of config for the codec.\n */\nexport function getBooleanCodec(): FixedSizeCodec<boolean, boolean, 1>;\nexport function getBooleanCodec<TSize extends number>(\n    config: BooleanCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<boolean, boolean, TSize>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec>): Codec<boolean>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec> = {}): Codec<boolean> {\n    return combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    fixDecoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoder,\n    getEncodedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\n/** Defines the config for bytes codecs. */\nexport type BytesCodecConfig<TSize extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the byte array. It can be one of the following:\n     * - a {@link NumberSerializer} that prefixes the byte array with its size.\n     * - a fixed number of bytes.\n     * - or `'variable'` to use the rest of the byte array.\n     * @defaultValue `'variable'`\n     */\n    size?: TSize | number | 'variable';\n};\n\n/**\n * Encodes sized bytes.\n *\n * @param config - A set of config for the encoder.\n */\nexport function getBytesEncoder<TSize extends number>(\n    config: BytesCodecConfig<NumberEncoder> & { size: TSize },\n): FixedSizeEncoder<Uint8Array, TSize>;\nexport function getBytesEncoder(config?: BytesCodecConfig<NumberEncoder>): VariableSizeEncoder<Uint8Array>;\nexport function getBytesEncoder(config: BytesCodecConfig<NumberEncoder> = {}): Encoder<Uint8Array> {\n    const size = config.size ?? 'variable';\n\n    const byteEncoder: Encoder<Uint8Array> = createEncoder({\n        getSizeFromValue: (value: Uint8Array) => value.length,\n        write: (value: Uint8Array, bytes, offset) => {\n            bytes.set(value, offset);\n            return offset + value.length;\n        },\n    });\n\n    if (size === 'variable') {\n        return byteEncoder;\n    }\n\n    if (typeof size === 'number') {\n        return fixEncoder(byteEncoder, size);\n    }\n\n    return createEncoder({\n        getSizeFromValue: (value: Uint8Array) => getEncodedSize(value.length, size) + value.length,\n        write: (value: Uint8Array, bytes, offset) => {\n            offset = size.write(value.length, bytes, offset);\n            return byteEncoder.write(value, bytes, offset);\n        },\n    });\n}\n\n/**\n * Decodes sized bytes.\n *\n * @param config - A set of config for the decoder.\n */\nexport function getBytesDecoder<TSize extends number>(\n    config: BytesCodecConfig<NumberDecoder> & { size: TSize },\n): FixedSizeDecoder<Uint8Array, TSize>;\nexport function getBytesDecoder(config?: BytesCodecConfig<NumberDecoder>): VariableSizeDecoder<Uint8Array>;\nexport function getBytesDecoder(config: BytesCodecConfig<NumberDecoder> = {}): Decoder<Uint8Array> {\n    const size = config.size ?? 'variable';\n\n    const byteDecoder: Decoder<Uint8Array> = createDecoder({\n        read: (bytes: Uint8Array, offset) => {\n            const slice = bytes.slice(offset);\n            return [slice, offset + slice.length];\n        },\n    });\n\n    if (size === 'variable') {\n        return byteDecoder;\n    }\n\n    if (typeof size === 'number') {\n        return fixDecoder(byteDecoder, size);\n    }\n\n    return createDecoder({\n        read: (bytes: Uint8Array, offset) => {\n            assertByteArrayIsNotEmptyForCodec('bytes', bytes, offset);\n            const [lengthBigInt, lengthOffset] = size.read(bytes, offset);\n            const length = Number(lengthBigInt);\n            offset = lengthOffset;\n            const contentBytes = bytes.slice(offset, offset + length);\n            assertByteArrayHasEnoughBytesForCodec('bytes', length, contentBytes);\n            const [value, contentOffset] = byteDecoder.read(contentBytes, 0);\n            offset += contentOffset;\n            return [value, offset];\n        },\n    });\n}\n\n/**\n * Creates a sized bytes codec.\n *\n * @param config - A set of config for the codec.\n */\nexport function getBytesCodec<TSize extends number>(\n    config: BytesCodecConfig<NumberCodec> & { size: TSize },\n): FixedSizeCodec<Uint8Array, Uint8Array, TSize>;\nexport function getBytesCodec(config?: BytesCodecConfig<NumberCodec>): VariableSizeCodec<Uint8Array>;\nexport function getBytesCodec(config: BytesCodecConfig<NumberCodec> = {}): Codec<Uint8Array> {\n    return combineCodec(getBytesEncoder(config), getBytesDecoder(config));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    assertByteArrayIsNotEmptyForCodec,\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    getEncodedSize,\n    isFixedSize,\n} from '@solana/codecs-core';\nimport { getU8Decoder, getU8Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__INVALID_DATA_ENUM_VARIANT,\n    SolanaError,\n} from '@solana/errors';\n\nimport { getMaxSize, maxCodecSizes, sumCodecSizes } from './utils';\n\n/**\n * Defines a data enum using discriminated union types.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * ```\n */\nexport type DataEnum = { __kind: string };\n\n/**\n * Extracts a variant from a data enum.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * type ClickEvent = GetDataEnumKind<WebPageEvent, 'click'>;\n * // -> { __kind: 'click', x: number, y: number }\n * ```\n */\nexport type GetDataEnumKind<T extends DataEnum, K extends T['__kind']> = Extract<T, { __kind: K }>;\n\n/**\n * Extracts a variant from a data enum without its discriminator.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * type ClickEvent = GetDataEnumKindContent<WebPageEvent, 'click'>;\n * // -> { x: number, y: number }\n * ```\n */\nexport type GetDataEnumKindContent<T extends DataEnum, K extends T['__kind']> = Omit<\n    Extract<T, { __kind: K }>,\n    '__kind'\n>;\n\n/** Defines the config for data enum codecs. */\nexport type DataEnumCodecConfig<TDiscriminator = NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec to use for the enum discriminator prefixing the variant.\n     * @defaultValue u8 prefix.\n     */\n    size?: TDiscriminator;\n};\n\ntype Variants<T> = readonly (readonly [string, T])[];\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\ntype GetEncoderTypeFromVariants<TVariants extends Variants<Encoder<any>>> = {\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Encoder<infer TFrom>\n        ? TFrom extends object\n            ? TFrom\n            : object\n        : never) & { __kind: TVariants[I][0] };\n}[ArrayIndices<TVariants>];\n\ntype GetDecoderTypeFromVariants<TVariants extends Variants<Decoder<any>>> = {\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Decoder<infer TTo>\n        ? TTo extends object\n            ? TTo\n            : object\n        : never) & { __kind: TVariants[I][0] };\n}[ArrayIndices<TVariants>];\n\n/**\n * Creates a data enum encoder.\n *\n * @param variants - The variant encoders of the data enum.\n * @param config - A set of config for the encoder.\n */\nexport function getDataEnumEncoder<const TVariants extends Variants<Encoder<any>>>(\n    variants: TVariants,\n    config: DataEnumCodecConfig<NumberEncoder> = {},\n): Encoder<GetEncoderTypeFromVariants<TVariants>> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants>;\n    const prefix = config.size ?? getU8Encoder();\n    const fixedSize = getDataEnumFixedSize(variants, prefix);\n    return createEncoder({\n        ...(fixedSize !== null\n            ? { fixedSize }\n            : {\n                  getSizeFromValue: (variant: TFrom) => {\n                      const discriminator = getVariantDiscriminator(variants, variant);\n                      const variantEncoder = variants[discriminator][1];\n                      return (\n                          getEncodedSize(discriminator, prefix) +\n                          getEncodedSize(variant as TFrom & void, variantEncoder)\n                      );\n                  },\n                  maxSize: getDataEnumMaxSize(variants, prefix),\n              }),\n        write: (variant: TFrom, bytes, offset) => {\n            const discriminator = getVariantDiscriminator(variants, variant);\n            offset = prefix.write(discriminator, bytes, offset);\n            const variantEncoder = variants[discriminator][1];\n            return variantEncoder.write(variant as TFrom & void, bytes, offset);\n        },\n    });\n}\n\n/**\n * Creates a data enum decoder.\n *\n * @param variants - The variant decoders of the data enum.\n * @param config - A set of config for the decoder.\n */\nexport function getDataEnumDecoder<const TVariants extends Variants<Decoder<any>>>(\n    variants: TVariants,\n    config: DataEnumCodecConfig<NumberDecoder> = {},\n): Decoder<GetDecoderTypeFromVariants<TVariants>> {\n    type TTo = GetDecoderTypeFromVariants<TVariants>;\n    const prefix = config.size ?? getU8Decoder();\n    const fixedSize = getDataEnumFixedSize(variants, prefix);\n    return createDecoder({\n        ...(fixedSize !== null ? { fixedSize } : { maxSize: getDataEnumMaxSize(variants, prefix) }),\n        read: (bytes: Uint8Array, offset) => {\n            assertByteArrayIsNotEmptyForCodec('dataEnum', bytes, offset);\n            const [discriminator, dOffset] = prefix.read(bytes, offset);\n            offset = dOffset;\n            const variantField = variants[Number(discriminator)] ?? null;\n            if (!variantField) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                    discriminator,\n                    maxRange: variants.length - 1,\n                    minRange: 0,\n                });\n            }\n            const [variant, vOffset] = variantField[1].read(bytes, offset);\n            offset = vOffset;\n            return [{ __kind: variantField[0], ...(variant ?? {}) } as TTo, offset];\n        },\n    });\n}\n\n/**\n * Creates a data enum codec.\n *\n * @param variants - The variant codecs of the data enum.\n * @param config - A set of config for the codec.\n */\nexport function getDataEnumCodec<const TVariants extends Variants<Codec<any, any>>>(\n    variants: TVariants,\n    config: DataEnumCodecConfig<NumberCodec> = {},\n): Codec<\n    GetEncoderTypeFromVariants<TVariants>,\n    GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n> {\n    return combineCodec(\n        getDataEnumEncoder(variants, config),\n        getDataEnumDecoder(variants, config) as Decoder<\n            GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n        >,\n    );\n}\n\nfunction getDataEnumFixedSize<const TVariants extends Variants<Decoder<any> | Encoder<any>>>(\n    variants: TVariants,\n    prefix: object | { fixedSize: number },\n): number | null {\n    if (variants.length === 0) return isFixedSize(prefix) ? prefix.fixedSize : null;\n    if (!isFixedSize(variants[0][1])) return null;\n    const variantSize = variants[0][1].fixedSize;\n    const sameSizedVariants = variants.every(\n        variant => isFixedSize(variant[1]) && variant[1].fixedSize === variantSize,\n    );\n    if (!sameSizedVariants) return null;\n    return isFixedSize(prefix) ? prefix.fixedSize + variantSize : null;\n}\n\nfunction getDataEnumMaxSize<const TVariants extends Variants<Decoder<any> | Encoder<any>>>(\n    variants: TVariants,\n    prefix: object | { fixedSize: number },\n) {\n    const maxVariantSize = maxCodecSizes(variants.map(([, codec]) => getMaxSize(codec)));\n    return sumCodecSizes([getMaxSize(prefix), maxVariantSize]) ?? undefined;\n}\n\nfunction getVariantDiscriminator<const TVariants extends Variants<Decoder<any> | Encoder<any>>>(\n    variants: TVariants,\n    variant: { __kind: string },\n) {\n    const discriminator = variants.findIndex(([key]) => variant.__kind === key);\n    if (discriminator < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_DATA_ENUM_VARIANT, {\n            value: variant.__kind,\n            variants: variants.map(([key]) => key),\n        });\n    }\n    return discriminator;\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    mapDecoder,\n    mapEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/** Defines the config for Map codecs. */\nexport type MapCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the array.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Creates a encoder for a map.\n *\n * @param key - The encoder to use for the map's keys.\n * @param value - The encoder to use for the map's values.\n * @param config - A set of config for the encoder.\n */\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>, 0>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: FixedSizeEncoder<TFromKey>,\n    value: FixedSizeEncoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config?: MapCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> = {},\n): Encoder<Map<TFromKey, TFromValue>> {\n    return mapEncoder(\n        getArrayEncoder(getTupleEncoder([key, value]), config as object),\n        (map: Map<TFromKey, TFromValue>): [TFromKey, TFromValue][] => [...map.entries()],\n    );\n}\n\n/**\n * Creates a decoder for a map.\n *\n * @param key - The decoder to use for the map's keys.\n * @param value - The decoder to use for the map's values.\n * @param config - A set of config for the decoder.\n */\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Map<TToKey, TToValue>, 0>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: FixedSizeDecoder<TToKey>,\n    value: FixedSizeDecoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config?: MapCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> = {},\n): Decoder<Map<TToKey, TToValue>> {\n    return mapDecoder(\n        getArrayDecoder(getTupleDecoder([key, value]), config as object),\n        (entries: [TToKey, TToValue][]): Map<TToKey, TToValue> => new Map(entries),\n    );\n}\n\n/**\n * Creates a codec for a map.\n *\n * @param key - The codec to use for the map's keys.\n * @param value - The codec to use for the map's values.\n * @param config - A set of config for the codec.\n */\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>, 0>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: FixedSizeCodec<TFromKey, TToKey>,\n    value: FixedSizeCodec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config?: MapCodecConfig<NumberCodec>,\n): VariableSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> = {},\n): Codec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>> {\n    return combineCodec(getMapEncoder(key, value, config as object), getMapDecoder(key, value, config as object));\n}\n","import {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\ntype WrapInFixedSizeEncoder<TFrom> = {\n    [P in keyof TFrom]: FixedSizeEncoder<TFrom[P]>;\n};\ntype WrapInEncoder<TFrom> = {\n    [P in keyof TFrom]: Encoder<TFrom[P]>;\n};\ntype WrapInFixedSizeDecoder<TTo> = {\n    [P in keyof TTo]: FixedSizeDecoder<TTo[P]>;\n};\ntype WrapInDecoder<TTo> = {\n    [P in keyof TTo]: Decoder<TTo[P]>;\n};\ntype WrapInCodec<TFrom, TTo extends TFrom> = {\n    [P in keyof TFrom]: Codec<TFrom[P], TTo[P]>;\n};\ntype WrapInFixedSizeCodec<TFrom, TTo extends TFrom> = {\n    [P in keyof TFrom]: FixedSizeCodec<TFrom[P], TTo[P]>;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyArray = any[];\n\n/**\n * Creates a encoder for a tuple-like array.\n *\n * @param items - The encoders to use for each item in the tuple.\n */\nexport function getTupleEncoder<TFrom extends AnyArray>(\n    items: WrapInFixedSizeEncoder<[...TFrom]>,\n): FixedSizeEncoder<TFrom>;\nexport function getTupleEncoder<TFrom extends AnyArray>(items: WrapInEncoder<[...TFrom]>): VariableSizeEncoder<TFrom>;\nexport function getTupleEncoder<TFrom extends AnyArray>(items: WrapInEncoder<[...TFrom]>): Encoder<TFrom> {\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      items.map((item, index) => getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (value: TFrom, bytes, offset) => {\n            assertValidNumberOfItemsForCodec('tuple', items.length, value.length);\n            items.forEach((item, index) => {\n                offset = item.write(value[index], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Creates a decoder for a tuple-like array.\n *\n * @param items - The decoders to use for each item in the tuple.\n */\nexport function getTupleDecoder<TTo extends AnyArray>(items: WrapInFixedSizeDecoder<[...TTo]>): FixedSizeDecoder<TTo>;\nexport function getTupleDecoder<TTo extends AnyArray>(items: WrapInDecoder<[...TTo]>): VariableSizeDecoder<TTo>;\nexport function getTupleDecoder<TTo extends AnyArray>(items: WrapInDecoder<[...TTo]>): Decoder<TTo> {\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: Uint8Array, offset) => {\n            const values = [] as AnyArray as TTo;\n            items.forEach(item => {\n                const [newValue, newOffset] = item.read(bytes, offset);\n                values.push(newValue);\n                offset = newOffset;\n            });\n            return [values, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for a tuple-like array.\n *\n * @param items - The codecs to use for each item in the tuple.\n */\nexport function getTupleCodec<TFrom extends AnyArray, TTo extends TFrom = TFrom>(\n    items: WrapInFixedSizeCodec<[...TFrom], [...TTo]>,\n): FixedSizeCodec<TFrom, TTo>;\nexport function getTupleCodec<TFrom extends AnyArray, TTo extends TFrom = TFrom>(\n    items: WrapInCodec<[...TFrom], [...TTo]>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function getTupleCodec<TFrom extends AnyArray, TTo extends TFrom = TFrom>(\n    items: WrapInCodec<[...TFrom], [...TTo]>,\n): Codec<TFrom, TTo> {\n    return combineCodec(\n        getTupleEncoder(items as WrapInEncoder<[...TFrom]>),\n        getTupleDecoder(items as WrapInDecoder<[...TTo]>),\n    );\n}\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { getMaxSize, sumCodecSizes } from './utils';\n\n/** Defines the config for nullable codecs. */\nexport type NullableCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Whether the item codec should be of fixed size.\n     *\n     * When this is true, a `null` value will skip the bytes that would\n     * have been used for the item. Note that this will only work if the\n     * item codec is of fixed size.\n     * @defaultValue `false`\n     */\n    fixed?: boolean;\n\n    /**\n     * The codec to use for the boolean prefix.\n     * @defaultValue u8 prefix.\n     */\n    prefix?: TPrefix;\n};\n\n/**\n * Creates a encoder for an optional value using `null` as the `None` value.\n *\n * @param item - The encoder to use for the value that may be present.\n * @param config - A set of config for the encoder.\n */\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<FixedSizeNumberEncoder> & { fixed: true },\n): FixedSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom, 0>,\n    config?: NullableCodecConfig<FixedSizeNumberEncoder>,\n): FixedSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: NullableCodecConfig<NumberEncoder> & { fixed?: false },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom | null> {\n    const prefix = config.prefix ?? getU8Encoder();\n    const fixed = config.fixed ?? false;\n\n    const isZeroSizeItem = isFixedSize(item) && isFixedSize(prefix) && item.fixedSize === 0;\n    if (fixed || isZeroSizeItem) {\n        assertIsFixedSize(item);\n        assertIsFixedSize(prefix);\n        const fixedSize = prefix.fixedSize + item.fixedSize;\n        return createEncoder({\n            fixedSize,\n            write: (option: TFrom | null, bytes, offset) => {\n                const prefixOffset = prefix.write(Number(option !== null), bytes, offset);\n                if (option !== null) {\n                    item.write(option, bytes, prefixOffset);\n                }\n                return offset + fixedSize;\n            },\n        });\n    }\n\n    return createEncoder({\n        getSizeFromValue: (option: TFrom | null) =>\n            getEncodedSize(Number(option !== null), prefix) + (option !== null ? getEncodedSize(option, item) : 0),\n        maxSize: sumCodecSizes([prefix, item].map(getMaxSize)) ?? undefined,\n        write: (option: TFrom | null, bytes, offset) => {\n            offset = prefix.write(Number(option !== null), bytes, offset);\n            if (option !== null) {\n                offset = item.write(option, bytes, offset);\n            }\n            return offset;\n        },\n    });\n}\n\n/**\n * Creates a decoder for an optional value using `null` as the `None` value.\n *\n * @param item - The decoder to use for the value that may be present.\n * @param config - A set of config for the decoder.\n */\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<FixedSizeNumberDecoder> & { fixed: true },\n): FixedSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo, 0>,\n    config?: NullableCodecConfig<FixedSizeNumberDecoder>,\n): FixedSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: NullableCodecConfig<NumberDecoder> & { fixed?: false },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> = {},\n): Decoder<TTo | null> {\n    const prefix = config.prefix ?? getU8Decoder();\n    const fixed = config.fixed ?? false;\n\n    let fixedSize: number | null = null;\n    const isZeroSizeItem = isFixedSize(item) && isFixedSize(prefix) && item.fixedSize === 0;\n    if (fixed || isZeroSizeItem) {\n        assertIsFixedSize(item);\n        assertIsFixedSize(prefix);\n        fixedSize = prefix.fixedSize + item.fixedSize;\n    }\n\n    return createDecoder({\n        ...(fixedSize === null\n            ? { maxSize: sumCodecSizes([prefix, item].map(getMaxSize)) ?? undefined }\n            : { fixedSize }),\n        read: (bytes: Uint8Array, offset) => {\n            if (bytes.length - offset <= 0) {\n                return [null, offset];\n            }\n            const [isSome, prefixOffset] = prefix.read(bytes, offset);\n            if (isSome === 0) {\n                return [null, fixedSize !== null ? offset + fixedSize : prefixOffset];\n            }\n            const [value, newOffset] = item.read(bytes, prefixOffset);\n            return [value, fixedSize !== null ? offset + fixedSize : newOffset];\n        },\n    });\n}\n\n/**\n * Creates a codec for an optional value using `null` as the `None` value.\n *\n * @param item - The codec to use for the value that may be present.\n * @param config - A set of config for the codec.\n */\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<FixedSizeNumberCodec> & { fixed: true },\n): FixedSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo, 0>,\n    config?: NullableCodecConfig<FixedSizeNumberCodec>,\n): FixedSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: NullableCodecConfig<NumberCodec> & { fixed?: false },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> = {},\n): Codec<TFrom | null, TTo | null> {\n    const configCast = config as NullableCodecConfig<NumberCodec> & { fixed?: false };\n    return combineCodec(getNullableEncoder<TFrom>(item, configCast), getNullableDecoder<TTo>(item, configCast));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    mapDecoder,\n    mapEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__INVALID_SCALAR_ENUM_VARIANT,\n    SolanaError,\n} from '@solana/errors';\n\n/**\n * Defines the \"lookup object\" of a scalar enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * ```\n */\nexport type ScalarEnum = { [key: string]: number | string };\n\n/**\n * Returns the allowed input for a scalar enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionInput = ScalarEnumFrom<Direction>; // \"Left\" | \"Right\" | 0 | 1\n * ```\n */\nexport type ScalarEnumFrom<TEnum extends ScalarEnum> = TEnum[keyof TEnum] | keyof TEnum;\n\n/**\n * Returns all the available variants of a scalar enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionOutput = ScalarEnumFrom<Direction>; // 0 | 1\n * ```\n */\nexport type ScalarEnumTo<TEnum extends ScalarEnum> = TEnum[keyof TEnum];\n\n/** Defines the config for scalar enum codecs. */\nexport type ScalarEnumCodecConfig<TDiscriminator extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec to use for the enum discriminator.\n     * @defaultValue u8 discriminator.\n     */\n    size?: TDiscriminator;\n};\n\n/**\n * Creates a scalar enum encoder.\n *\n * @param constructor - The constructor of the scalar enum.\n * @param config - A set of config for the encoder.\n */\nexport function getScalarEnumEncoder<TEnum extends ScalarEnum>(\n    constructor: TEnum,\n): FixedSizeEncoder<ScalarEnumFrom<TEnum>, 1>;\nexport function getScalarEnumEncoder<TEnum extends ScalarEnum, TSize extends number>(\n    constructor: TEnum,\n    config: ScalarEnumCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<ScalarEnumFrom<TEnum>, TSize>;\nexport function getScalarEnumEncoder<TEnum extends ScalarEnum>(\n    constructor: TEnum,\n    config?: ScalarEnumCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<ScalarEnumFrom<TEnum>>;\nexport function getScalarEnumEncoder<TEnum extends ScalarEnum>(\n    constructor: TEnum,\n    config: ScalarEnumCodecConfig<NumberEncoder> = {},\n): Encoder<ScalarEnumFrom<TEnum>> {\n    const prefix = config.size ?? getU8Encoder();\n    const { minRange, maxRange, allStringInputs, enumKeys, enumValues } = getScalarEnumStats(constructor);\n    return mapEncoder(prefix, (value: ScalarEnumFrom<TEnum>): number => {\n        const isInvalidNumber = typeof value === 'number' && (value < minRange || value > maxRange);\n        const isInvalidString = typeof value === 'string' && !allStringInputs.includes(value);\n        if (isInvalidNumber || isInvalidString) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_SCALAR_ENUM_VARIANT, {\n                maxRange,\n                minRange,\n                value,\n                variants: allStringInputs,\n            });\n        }\n        if (typeof value === 'number') return value;\n        const valueIndex = enumValues.indexOf(value as string);\n        if (valueIndex >= 0) return valueIndex;\n        return enumKeys.indexOf(value as string);\n    });\n}\n\n/**\n * Creates a scalar enum decoder.\n *\n * @param constructor - The constructor of the scalar enum.\n * @param config - A set of config for the decoder.\n */\nexport function getScalarEnumDecoder<TEnum extends ScalarEnum>(\n    constructor: TEnum,\n): FixedSizeDecoder<ScalarEnumTo<TEnum>, 1>;\nexport function getScalarEnumDecoder<TEnum extends ScalarEnum, TSize extends number>(\n    constructor: TEnum,\n    config: ScalarEnumCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<ScalarEnumTo<TEnum>, TSize>;\nexport function getScalarEnumDecoder<TEnum extends ScalarEnum>(\n    constructor: TEnum,\n    config?: ScalarEnumCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<ScalarEnumTo<TEnum>>;\nexport function getScalarEnumDecoder<TEnum extends ScalarEnum>(\n    constructor: TEnum,\n    config: ScalarEnumCodecConfig<NumberDecoder> = {},\n): Decoder<ScalarEnumTo<TEnum>> {\n    const prefix = config.size ?? getU8Decoder();\n    const { minRange, maxRange, enumKeys } = getScalarEnumStats(constructor);\n    return mapDecoder(prefix, (value: bigint | number): ScalarEnumTo<TEnum> => {\n        const valueAsNumber = Number(value);\n        if (valueAsNumber < minRange || valueAsNumber > maxRange) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator: valueAsNumber,\n                maxRange,\n                minRange,\n            });\n        }\n        return constructor[enumKeys[valueAsNumber]] as ScalarEnumTo<TEnum>;\n    });\n}\n\n/**\n * Creates a scalar enum codec.\n *\n * @param constructor - The constructor of the scalar enum.\n * @param config - A set of config for the codec.\n */\nexport function getScalarEnumCodec<TEnum extends ScalarEnum>(\n    constructor: TEnum,\n): FixedSizeCodec<ScalarEnumFrom<TEnum>, ScalarEnumTo<TEnum>, 1>;\nexport function getScalarEnumCodec<TEnum extends ScalarEnum, TSize extends number>(\n    constructor: TEnum,\n    config: ScalarEnumCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<ScalarEnumFrom<TEnum>, ScalarEnumTo<TEnum>, TSize>;\nexport function getScalarEnumCodec<TEnum extends ScalarEnum>(\n    constructor: TEnum,\n    config?: ScalarEnumCodecConfig<NumberCodec>,\n): VariableSizeCodec<ScalarEnumFrom<TEnum>, ScalarEnumTo<TEnum>>;\nexport function getScalarEnumCodec<TEnum extends ScalarEnum>(\n    constructor: TEnum,\n    config: ScalarEnumCodecConfig<NumberCodec> = {},\n): Codec<ScalarEnumFrom<TEnum>, ScalarEnumTo<TEnum>> {\n    return combineCodec(getScalarEnumEncoder(constructor, config), getScalarEnumDecoder(constructor, config));\n}\n\nfunction getScalarEnumStats<TEnum extends ScalarEnum>(\n    constructor: TEnum,\n): {\n    allStringInputs: string[];\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    maxRange: number;\n    minRange: number;\n} {\n    const numericValues = Object.values(constructor).filter(v => typeof v === 'number') as number[];\n    const deduplicatedConstructor = Object.fromEntries(\n        Object.entries(constructor).slice(numericValues.length),\n    ) as Record<string, number | string>;\n    const enumKeys = Object.keys(deduplicatedConstructor);\n    const enumValues = Object.values(deduplicatedConstructor);\n    const minRange = 0;\n    const maxRange = enumValues.length - 1;\n    const allStringInputs: string[] = [\n        ...new Set([...enumKeys, ...enumValues.filter((v): v is string => typeof v === 'string')]),\n    ];\n\n    return {\n        allStringInputs,\n        enumKeys,\n        enumValues,\n        maxRange,\n        minRange,\n    };\n}\n","/**\n * An implementation of the Rust Option type in JavaScript.\n * It can be one of the following:\n * - <code>{@link Some}<T></code>: Meaning there is a value of type T.\n * - <code>{@link None}</code>: Meaning there is no value.\n */\nexport type Option<T> = None | Some<T>;\n\n/**\n * Defines a looser type that can be used when serializing an {@link Option}.\n * This allows us to pass null or the Option value directly whilst still\n * supporting the Option type for use-cases that need more type safety.\n */\nexport type OptionOrNullable<T> = Option<T> | T | null;\n\n/**\n * Represents an option of type `T` that has a value.\n *\n * @see {@link Option}\n */\nexport type Some<T> = Readonly<{ __option: 'Some'; value: T }>;\n\n/**\n * Represents an option of type `T` that has no value.\n *\n * @see {@link Option}\n */\nexport type None = Readonly<{ __option: 'None' }>;\n\n/**\n * Creates a new {@link Option} of type `T` that has a value.\n *\n * @see {@link Option}\n */\nexport const some = <T>(value: T): Option<T> => ({ __option: 'Some', value });\n\n/**\n * Creates a new {@link Option} of type `T` that has no value.\n *\n * @see {@link Option}\n */\nexport const none = <T>(): Option<T> => ({ __option: 'None' });\n\n/**\n * Whether the given data is an {@link Option}.\n */\nexport const isOption = <T = unknown>(input: unknown): input is Option<T> =>\n    !!(\n        input &&\n        typeof input === 'object' &&\n        '__option' in input &&\n        ((input.__option === 'Some' && 'value' in input) || input.__option === 'None')\n    );\n\n/**\n * Whether the given {@link Option} is a {@link Some}.\n */\nexport const isSome = <T>(option: Option<T>): option is Some<T> => option.__option === 'Some';\n\n/**\n * Whether the given {@link Option} is a {@link None}.\n */\nexport const isNone = <T>(option: Option<T>): option is None => option.__option === 'None';\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { isOption, isSome, none, Option, OptionOrNullable, some } from './option';\nimport { wrapNullable } from './unwrap-option';\n\n/** Defines the config for option codecs. */\nexport type OptionCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Whether the item codec should be of fixed size.\n     *\n     * When this is true, a `None` value will skip the bytes that would\n     * have been used for the item. Note that this will only work if the\n     * item codec is of fixed size.\n     * @defaultValue `false`\n     */\n    fixed?: boolean;\n\n    /**\n     * The codec to use for the boolean prefix.\n     * @defaultValue u8 prefix.\n     */\n    prefix?: TPrefix;\n};\n\n/**\n * Creates a encoder for an optional value using `null` as the `None` value.\n *\n * @param item - The encoder to use for the value that may be present.\n * @param config - A set of config for the encoder.\n */\nexport function getOptionEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: OptionCodecConfig<FixedSizeNumberEncoder> & { fixed: true },\n): FixedSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom, 0>,\n    config?: OptionCodecConfig<FixedSizeNumberEncoder>,\n): FixedSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: OptionCodecConfig<NumberEncoder> & { fixed?: false },\n): VariableSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: OptionCodecConfig<NumberEncoder> = {},\n): Encoder<OptionOrNullable<TFrom>> {\n    const prefix = config.prefix ?? getU8Encoder();\n    const fixed = config.fixed ?? false;\n\n    const isZeroSizeItem = isFixedSize(item) && isFixedSize(prefix) && item.fixedSize === 0;\n    if (fixed || isZeroSizeItem) {\n        assertIsFixedSize(item);\n        assertIsFixedSize(prefix);\n        const fixedSize = prefix.fixedSize + item.fixedSize;\n        return createEncoder({\n            fixedSize,\n            write: (optionOrNullable: OptionOrNullable<TFrom>, bytes, offset) => {\n                const option = isOption<TFrom>(optionOrNullable) ? optionOrNullable : wrapNullable(optionOrNullable);\n                const prefixOffset = prefix.write(Number(isSome(option)), bytes, offset);\n                if (isSome(option)) {\n                    item.write(option.value, bytes, prefixOffset);\n                }\n                return offset + fixedSize;\n            },\n        });\n    }\n\n    return createEncoder({\n        getSizeFromValue: (optionOrNullable: OptionOrNullable<TFrom>) => {\n            const option = isOption<TFrom>(optionOrNullable) ? optionOrNullable : wrapNullable(optionOrNullable);\n            return (\n                getEncodedSize(Number(isSome(option)), prefix) +\n                (isSome(option) ? getEncodedSize(option.value, item) : 0)\n            );\n        },\n        maxSize: sumCodecSizes([prefix, item].map(getMaxSize)) ?? undefined,\n        write: (optionOrNullable: OptionOrNullable<TFrom>, bytes, offset) => {\n            const option = isOption<TFrom>(optionOrNullable) ? optionOrNullable : wrapNullable(optionOrNullable);\n            offset = prefix.write(Number(isSome(option)), bytes, offset);\n            if (isSome(option)) {\n                offset = item.write(option.value, bytes, offset);\n            }\n            return offset;\n        },\n    });\n}\n\n/**\n * Creates a decoder for an optional value using `null` as the `None` value.\n *\n * @param item - The decoder to use for the value that may be present.\n * @param config - A set of config for the decoder.\n */\nexport function getOptionDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: OptionCodecConfig<FixedSizeNumberDecoder> & { fixed: true },\n): FixedSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: FixedSizeDecoder<TTo, 0>,\n    config?: OptionCodecConfig<FixedSizeNumberDecoder>,\n): FixedSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: OptionCodecConfig<NumberDecoder> & { fixed?: false },\n): VariableSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: OptionCodecConfig<NumberDecoder> = {},\n): Decoder<Option<TTo>> {\n    const prefix = config.prefix ?? getU8Decoder();\n    const fixed = config.fixed ?? false;\n\n    let fixedSize: number | null = null;\n    const isZeroSizeItem = isFixedSize(item) && isFixedSize(prefix) && item.fixedSize === 0;\n    if (fixed || isZeroSizeItem) {\n        assertIsFixedSize(item);\n        assertIsFixedSize(prefix);\n        fixedSize = prefix.fixedSize + item.fixedSize;\n    }\n\n    return createDecoder({\n        ...(fixedSize === null\n            ? { maxSize: sumCodecSizes([prefix, item].map(getMaxSize)) ?? undefined }\n            : { fixedSize }),\n        read: (bytes: Uint8Array, offset) => {\n            if (bytes.length - offset <= 0) {\n                return [none(), offset];\n            }\n            const [isSome, prefixOffset] = prefix.read(bytes, offset);\n            if (isSome === 0) {\n                return [none(), fixedSize !== null ? offset + fixedSize : prefixOffset];\n            }\n            const [value, newOffset] = item.read(bytes, prefixOffset);\n            return [some(value), fixedSize !== null ? offset + fixedSize : newOffset];\n        },\n    });\n}\n\n/**\n * Creates a codec for an optional value using `null` as the `None` value.\n *\n * @param item - The codec to use for the value that may be present.\n * @param config - A set of config for the codec.\n */\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: OptionCodecConfig<FixedSizeNumberCodec> & { fixed: true },\n): FixedSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo, 0>,\n    config?: OptionCodecConfig<FixedSizeNumberCodec>,\n): FixedSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: OptionCodecConfig<NumberCodec> & { fixed?: false },\n): VariableSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: OptionCodecConfig<NumberCodec> = {},\n): Codec<OptionOrNullable<TFrom>, Option<TTo>> {\n    return combineCodec(getOptionEncoder<TFrom>(item, config as object), getOptionDecoder<TTo>(item, config as object));\n}\n\nfunction sumCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce((all, size) => (all === null || size === null ? null : all + size), 0 as number | null);\n}\n\nfunction getMaxSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : codec.maxSize ?? null;\n}\n","import { isSome, none, Option, some } from './option';\n\n/**\n * Unwraps the value of an {@link Option} of type `T`\n * or returns a fallback value that defaults to `null`.\n */\nexport function unwrapOption<T>(option: Option<T>): T | null;\nexport function unwrapOption<T, U>(option: Option<T>, fallback: () => U): T | U;\nexport function unwrapOption<T, U = null>(option: Option<T>, fallback?: () => U): T | U {\n    if (isSome(option)) return option.value;\n    return fallback ? fallback() : (null as U);\n}\n\n/**\n * Wraps a nullable value into an {@link Option}.\n */\nexport const wrapNullable = <T>(nullable: T | null): Option<T> => (nullable !== null ? some(nullable) : none<T>());\n","import { isOption, isSome, None, Some } from './option';\n\n/**\n * Lists all types that should not be recursively unwrapped.\n *\n * @see {@link UnwrappedOption}\n */\ntype UnUnwrappables =\n    | Date\n    | Int8Array\n    | Int16Array\n    | Int32Array\n    | Uint8Array\n    | Uint16Array\n    | Uint32Array\n    | bigint\n    | boolean\n    | number\n    | string\n    | symbol\n    | null\n    | undefined;\n\n/**\n * A type that defines the recursive unwrapping of a type `T`\n * such that all nested {@link Option} types are unwrapped.\n *\n * For each nested {@link Option} type, if the option is a {@link Some},\n * it returns the type of its value, otherwise, it returns the provided\n * fallback type `U` which defaults to `null`.\n */\nexport type UnwrappedOption<T, U = null> = T extends Some<infer TValue>\n    ? UnwrappedOption<TValue, U>\n    : T extends None\n      ? U\n      : T extends UnUnwrappables\n        ? T\n        : T extends object\n          ? { [key in keyof T]: UnwrappedOption<T[key], U> }\n          : T extends Array<infer TItem>\n            ? Array<UnwrappedOption<TItem, U>>\n            : T;\n\n/**\n * Recursively go through a type `T` such that all\n * nested {@link Option} types are unwrapped.\n *\n * For each nested {@link Option} type, if the option is a {@link Some},\n * it returns its value, otherwise, it returns the provided fallback value\n * which defaults to `null`.\n */\nexport function unwrapOptionRecursively<T>(input: T): UnwrappedOption<T>;\nexport function unwrapOptionRecursively<T, U>(input: T, fallback: () => U): UnwrappedOption<T, U>;\nexport function unwrapOptionRecursively<T, U = null>(input: T, fallback?: () => U): UnwrappedOption<T, U> {\n    // Types to bypass.\n    if (!input || ArrayBuffer.isView(input)) {\n        return input as UnwrappedOption<T, U>;\n    }\n\n    const next = <X>(x: X) =>\n        (fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x)) as UnwrappedOption<X, U>;\n\n    // Handle Option.\n    if (isOption(input)) {\n        if (isSome(input)) return next(input.value) as UnwrappedOption<T, U>;\n        return (fallback ? fallback() : null) as UnwrappedOption<T, U>;\n    }\n\n    // Walk.\n    if (Array.isArray(input)) {\n        return input.map(next) as UnwrappedOption<T, U>;\n    }\n    if (typeof input === 'object') {\n        return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)])) as UnwrappedOption<T, U>;\n    }\n    return input as UnwrappedOption<T, U>;\n}\n","/**\n * General pipe function.\n * Provide an initial value and a list of functions to pipe it through.\n *\n * Following common implementations of pipe functions that use TypeScript,\n * this function supports a maximum arity of 10 for type safety.\n * @see https://github.com/ramda/ramda/blob/master/source/pipe.js\n * @see https://github.com/darky/rocket-pipes/blob/master/index.ts\n *\n * Note you can use nested pipes to extend this limitation, like so:\n * ```typescript\n * const myValue = pipe(\n *      pipe(\n *          1,\n *          (x) => x + 1,\n *          (x) => x * 2,\n *          (x) => x - 1,\n *      ),\n *      (y) => y / 3,\n *      (y) => y + 1,\n * );\n * ```\n * @param init  The initial value\n * @param fns   Any number of functions to pipe the value through\n * @returns     The final value with all functions applied\n */\nexport function pipe<TInitial>(init: TInitial): TInitial;\nexport function pipe<TInitial, R1>(init: TInitial, init_r1: (init: TInitial) => R1): R1;\nexport function pipe<TInitial, R1, R2>(init: TInitial, init_r1: (init: TInitial) => R1, r1_r2: (r1: R1) => R2): R2;\nexport function pipe<TInitial, R1, R2, R3>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n): R3;\nexport function pipe<TInitial, R1, R2, R3, R4>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n    r3_r4: (r3: R3) => R4,\n): R4;\nexport function pipe<TInitial, R1, R2, R3, R4, R5>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n    r3_r4: (r3: R3) => R4,\n    r4_r5: (r4: R4) => R5,\n): R5;\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n    r3_r4: (r3: R3) => R4,\n    r4_r5: (r4: R4) => R5,\n    r5_r6: (r5: R5) => R6,\n): R6;\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n    r3_r4: (r3: R3) => R4,\n    r4_r5: (r4: R4) => R5,\n    r5_r6: (r5: R5) => R6,\n    r6_r7: (r6: R6) => R7,\n): R7;\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n    r3_r4: (r3: R3) => R4,\n    r4_r5: (r4: R4) => R5,\n    r5_r6: (r5: R5) => R6,\n    r6_r7: (r6: R6) => R7,\n    r7_r8: (r7: R7) => R8,\n): R8;\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8, R9>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n    r3_r4: (r3: R3) => R4,\n    r4_r5: (r4: R4) => R5,\n    r5_r6: (r5: R5) => R6,\n    r6_r7: (r6: R6) => R7,\n    r7_r8: (r7: R7) => R8,\n    r8_r9: (r8: R8) => R9,\n): R9;\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n    r3_r4: (r3: R3) => R4,\n    r4_r5: (r4: R4) => R5,\n    r5_r6: (r5: R5) => R6,\n    r6_r7: (r6: R6) => R7,\n    r7_r8: (r7: R7) => R8,\n    r8_r9: (r8: R8) => R9,\n    r9_r10: (r9: R9) => R10,\n): R10;\nexport function pipe<TInitial>(init: TInitial, ...fns: CallableFunction[]) {\n    return fns.reduce((acc, fn) => fn(acc), init);\n}\n","import { Address } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { IAccountLookupMeta, IAccountMeta } from './accounts';\n\nexport interface IInstruction<\n    TProgramAddress extends string = string,\n    TAccounts extends readonly (IAccountLookupMeta | IAccountMeta)[] = readonly (IAccountLookupMeta | IAccountMeta)[],\n> {\n    readonly accounts?: TAccounts;\n    readonly data?: Uint8Array;\n    readonly programAddress: Address<TProgramAddress>;\n}\n\nexport interface IInstructionWithAccounts<TAccounts extends readonly (IAccountLookupMeta | IAccountMeta)[]>\n    extends IInstruction {\n    readonly accounts: TAccounts;\n}\n\nexport function isInstructionForProgram<TProgramAddress extends string, TInstruction extends IInstruction>(\n    instruction: TInstruction,\n    programAddress: Address<TProgramAddress>,\n): instruction is TInstruction & { programAddress: Address<TProgramAddress> } {\n    return instruction.programAddress === programAddress;\n}\n\nexport function assertIsInstructionForProgram<TProgramAddress extends string, TInstruction extends IInstruction>(\n    instruction: TInstruction,\n    programAddress: Address<TProgramAddress>,\n): asserts instruction is TInstruction & { programAddress: Address<TProgramAddress> } {\n    if (instruction.programAddress !== programAddress) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH, {\n            actualProgramAddress: instruction.programAddress,\n            expectedProgramAddress: programAddress,\n        });\n    }\n}\n\nexport function isInstructionWithAccounts<\n    TAccounts extends readonly (IAccountLookupMeta | IAccountMeta)[] = readonly (IAccountLookupMeta | IAccountMeta)[],\n    TInstruction extends IInstruction = IInstruction,\n>(instruction: TInstruction): instruction is IInstructionWithAccounts<TAccounts> & TInstruction {\n    return instruction.accounts !== undefined;\n}\n\nexport function assertIsInstructionWithAccounts<\n    TAccounts extends readonly (IAccountLookupMeta | IAccountMeta)[] = readonly (IAccountLookupMeta | IAccountMeta)[],\n    TInstruction extends IInstruction = IInstruction,\n>(instruction: TInstruction): asserts instruction is IInstructionWithAccounts<TAccounts> & TInstruction {\n    if (instruction.accounts === undefined) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS, {\n            data: instruction.data,\n            programAddress: instruction.programAddress,\n        });\n    }\n}\n\nexport interface IInstructionWithData<TData extends Uint8Array> extends IInstruction {\n    readonly data: TData;\n}\n\nexport function isInstructionWithData<\n    TData extends Uint8Array = Uint8Array,\n    TInstruction extends IInstruction = IInstruction,\n>(instruction: TInstruction): instruction is IInstructionWithData<TData> & TInstruction {\n    return instruction.data !== undefined;\n}\n\nexport function assertIsInstructionWithData<\n    TData extends Uint8Array = Uint8Array,\n    TInstruction extends IInstruction = IInstruction,\n>(instruction: TInstruction): asserts instruction is IInstructionWithData<TData> & TInstruction {\n    if (instruction.data === undefined) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA, {\n            accountAddresses: instruction.accounts?.map(a => a.address),\n            programAddress: instruction.programAddress,\n        });\n    }\n}\n","/**\n * Quick primer on bitwise operations: https://stackoverflow.com/a/1436448/802047\n */\n\nexport enum AccountRole {\n    // Bitflag guide: is signer ⌄⌄ is writable\n    WRITABLE_SIGNER = /* 3 */ 0b11, // prettier-ignore\n    READONLY_SIGNER = /* 2 */ 0b10, // prettier-ignore\n    WRITABLE =        /* 1 */ 0b01, // prettier-ignore\n    READONLY =        /* 0 */ 0b00, // prettier-ignore\n}\n\nconst IS_SIGNER_BITMASK = 0b10;\nconst IS_WRITABLE_BITMASK = 0b01;\n\nexport function downgradeRoleToNonSigner(role: AccountRole.READONLY_SIGNER): AccountRole.READONLY;\nexport function downgradeRoleToNonSigner(role: AccountRole.WRITABLE_SIGNER): AccountRole.WRITABLE;\nexport function downgradeRoleToNonSigner(role: AccountRole): AccountRole;\nexport function downgradeRoleToNonSigner(role: AccountRole): AccountRole {\n    return role & ~IS_SIGNER_BITMASK;\n}\n\nexport function downgradeRoleToReadonly(role: AccountRole.WRITABLE): AccountRole.READONLY;\nexport function downgradeRoleToReadonly(role: AccountRole.WRITABLE_SIGNER): AccountRole.READONLY_SIGNER;\nexport function downgradeRoleToReadonly(role: AccountRole): AccountRole;\nexport function downgradeRoleToReadonly(role: AccountRole): AccountRole {\n    return role & ~IS_WRITABLE_BITMASK;\n}\n\nexport function isSignerRole(role: AccountRole): role is AccountRole.READONLY_SIGNER | AccountRole.WRITABLE_SIGNER {\n    return role >= AccountRole.READONLY_SIGNER;\n}\n\nexport function isWritableRole(role: AccountRole): role is AccountRole.WRITABLE | AccountRole.WRITABLE_SIGNER {\n    return (role & IS_WRITABLE_BITMASK) !== 0;\n}\n\nexport function mergeRoles(roleA: AccountRole.WRITABLE, roleB: AccountRole.READONLY_SIGNER): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY_SIGNER, roleB: AccountRole.WRITABLE): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.WRITABLE_SIGNER): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.WRITABLE_SIGNER, roleB: AccountRole): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.READONLY_SIGNER): AccountRole.READONLY_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY_SIGNER, roleB: AccountRole): AccountRole.READONLY_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.WRITABLE): AccountRole.WRITABLE; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.WRITABLE, roleB: AccountRole): AccountRole.WRITABLE; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY, roleB: AccountRole.READONLY): AccountRole.READONLY; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole): AccountRole; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole): AccountRole {\n    return roleA | roleB;\n}\n\nexport function upgradeRoleToSigner(role: AccountRole.READONLY): AccountRole.READONLY_SIGNER;\nexport function upgradeRoleToSigner(role: AccountRole.WRITABLE): AccountRole.WRITABLE_SIGNER;\nexport function upgradeRoleToSigner(role: AccountRole): AccountRole;\nexport function upgradeRoleToSigner(role: AccountRole): AccountRole {\n    return role | IS_SIGNER_BITMASK;\n}\n\nexport function upgradeRoleToWritable(role: AccountRole.READONLY): AccountRole.WRITABLE;\nexport function upgradeRoleToWritable(role: AccountRole.READONLY_SIGNER): AccountRole.WRITABLE_SIGNER;\nexport function upgradeRoleToWritable(role: AccountRole): AccountRole;\nexport function upgradeRoleToWritable(role: AccountRole): AccountRole {\n    return role | IS_WRITABLE_BITMASK;\n}\n","import { SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nfunction addPkcs8Header(bytes: Uint8Array): Uint8Array {\n    // prettier-ignore\n    return new Uint8Array([\n        /**\n         * PKCS#8 header\n         */\n        0x30, // ASN.1 sequence tag\n        0x2e, // Length of sequence (46 more bytes)\n\n            0x02, // ASN.1 integer tag\n            0x01, // Length of integer\n                0x00, // Version number\n\n            0x30, // ASN.1 sequence tag\n            0x05, // Length of sequence\n                0x06, // ASN.1 object identifier tag\n                0x03, // Length of object identifier\n                    // Edwards curve algorithms identifier https://oid-rep.orange-labs.fr/get/1.3.101.112\n                        0x2b, // iso(1) / identified-organization(3) (The first node is multiplied by the decimal 40 and the result is added to the value of the second node)\n                        0x65, // thawte(101)\n                    // Ed25519 identifier\n                        0x70, // id-Ed25519(112)\n\n        /**\n         * Private key payload\n         */\n        0x04, // ASN.1 octet string tag\n        0x22, // String length (34 more bytes)\n\n            // Private key bytes as octet string\n            0x04, // ASN.1 octet string tag\n            0x20, // String length (32 bytes)\n\n        ...bytes\n    ]);\n}\n\nexport async function createPrivateKeyFromBytes(bytes: Uint8Array, extractable?: boolean): Promise<CryptoKey> {\n    const actualLength = bytes.byteLength;\n    if (actualLength !== 32) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, {\n            actualLength,\n        });\n    }\n    const privateKeyBytesPkcs8 = addPkcs8Header(bytes);\n    return await crypto.subtle.importKey('pkcs8', privateKeyBytesPkcs8, 'Ed25519', extractable ?? false, ['sign']);\n}\n","import { assertKeyGenerationIsAvailable } from '@solana/assertions';\nimport { SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport { createPrivateKeyFromBytes } from './private-key';\n\nexport async function generateKeyPair(): Promise<CryptoKeyPair> {\n    await assertKeyGenerationIsAvailable();\n    const keyPair = await crypto.subtle.generateKey(\n        /* algorithm */ 'Ed25519', // Native implementation status: https://github.com/WICG/webcrypto-secure-curves/issues/20\n        /* extractable */ false, // Prevents the bytes of the private key from being visible to JS.\n        /* allowed uses */ ['sign', 'verify'],\n    );\n    return keyPair as CryptoKeyPair;\n}\n\nexport async function createKeyPairFromBytes(bytes: Uint8Array, extractable?: boolean): Promise<CryptoKeyPair> {\n    if (bytes.byteLength !== 64) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH, { byteLength: bytes.byteLength });\n    }\n    const [publicKey, privateKey] = await Promise.all([\n        crypto.subtle.importKey('raw', bytes.slice(32), 'Ed25519', /* extractable */ true, ['verify']),\n        createPrivateKeyFromBytes(bytes.slice(0, 32), extractable),\n    ]);\n    return { privateKey, publicKey } as CryptoKeyPair;\n}\n","import { assertSigningCapabilityIsAvailable, assertVerificationCapabilityIsAvailable } from '@solana/assertions';\nimport { Encoder } from '@solana/codecs-core';\nimport { getBase58Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nexport type Signature = string & { readonly __brand: unique symbol };\nexport type SignatureBytes = Uint8Array & { readonly __brand: unique symbol };\n\nlet base58Encoder: Encoder<string> | undefined;\n\nexport function assertIsSignature(putativeSignature: string): asserts putativeSignature is Signature {\n    if (!base58Encoder) base58Encoder = getBase58Encoder();\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (64 bytes of zeroes)\n        putativeSignature.length < 64 ||\n        // Highest value (64 bytes of 255)\n        putativeSignature.length > 88\n    ) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeSignature.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const bytes = base58Encoder.encode(putativeSignature);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 64) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\nexport function isSignature(putativeSignature: string): putativeSignature is Signature {\n    if (!base58Encoder) base58Encoder = getBase58Encoder();\n\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (64 bytes of zeroes)\n        putativeSignature.length < 64 ||\n        // Highest value (64 bytes of 255)\n        putativeSignature.length > 88\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const bytes = base58Encoder.encode(putativeSignature);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 64) {\n        return false;\n    }\n    return true;\n}\n\nexport async function signBytes(key: CryptoKey, data: Uint8Array): Promise<SignatureBytes> {\n    await assertSigningCapabilityIsAvailable();\n    const signedData = await crypto.subtle.sign('Ed25519', key, data);\n    return new Uint8Array(signedData) as SignatureBytes;\n}\n\nexport function signature(putativeSignature: string): Signature {\n    assertIsSignature(putativeSignature);\n    return putativeSignature;\n}\n\nexport async function verifySignature(key: CryptoKey, signature: SignatureBytes, data: Uint8Array): Promise<boolean> {\n    await assertVerificationCapabilityIsAvailable();\n    return await crypto.subtle.verify('Ed25519', key, signature, data);\n}\n","import type { Address } from '@solana/addresses';\nimport type { Transaction } from '@solana/transactions';\n\nimport { Program, ProgramWithErrors } from './program';\n\n/**\n * Resolves a custom program error from a transaction error\n * with logs using the provided list of programs.\n * The original error is returned if the error cannot be\n * resolved from the given programs.\n *\n * @param error The raw error to resolve containing the program logs.\n * @param transaction The transaction that caused the error.\n * @param programs The list of programs to go through when resolving the transaction error.\n * They should ideally contain all programs the transaction is sending instructions to.\n * @returns The resolved program error, or the original transaction error\n * if the error cannot be resolved using the provided programs.\n */\nexport function resolveTransactionError(\n    error: Error & Readonly<{ logs?: readonly string[] }>,\n    transaction: Transaction,\n    programs: Program[],\n): Error {\n    // Compute the full logs from which to parse the instruction index and error code.\n    const fullLogs = error.message + '\\n' + (error.logs ?? []).join('\\n');\n\n    // Parse the instruction number, or return the original error.\n    const instructionRegex = /Error processing Instruction (\\d+)/;\n    const instructionIndexString = fullLogs.match(instructionRegex)?.[1] ?? null;\n    const instructionIndex = instructionIndexString ? parseInt(instructionIndexString, 10) : null;\n    if (instructionIndex === null) return error;\n\n    // Parse the error code, or return the original error.\n    const errorCodeRegex = /Custom program error: (0x[a-f0-9]+)/i;\n    const errorCodeString = fullLogs.match(errorCodeRegex)?.[1] ?? null;\n    const errorCode = errorCodeString ? parseInt(errorCodeString, 16) : null;\n    if (errorCode === null) return error;\n\n    // Get the program address from the instruction in the transaction, or return the original error.\n    const programAddress: Address | null = transaction.instructions[instructionIndex]?.programAddress ?? null;\n    if (!programAddress) return error;\n\n    // Find a matching program with error handling, or return the original error.\n    const program: ProgramWithErrors | null =\n        programs.find(\n            (program): program is Program & ProgramWithErrors =>\n                program.address === programAddress && typeof program.getErrorFromCode !== 'undefined',\n        ) ?? null;\n    if (!program) return error;\n\n    // Resolve the error from the identified program.\n    return program.getErrorFromCode(errorCode, error);\n}\n","let _nextMessageId = 0;\nfunction getNextMessageId() {\n    const id = _nextMessageId;\n    _nextMessageId = (_nextMessageId + 1) % Number.MAX_SAFE_INTEGER;\n    return id;\n}\n\nexport function createRpcMessage<TParams>(method: string, params: TParams) {\n    return {\n        id: getNextMessageId(),\n        jsonrpc: '2.0',\n        method,\n        params,\n    };\n}\n","import { getSolanaErrorFromJsonRpcError } from '@solana/errors';\nimport {\n    Callable,\n    createRpcMessage,\n    Flatten,\n    OverloadImplementations,\n    RpcResponse,\n    UnionToIntersection,\n} from '@solana/rpc-spec-types';\n\nimport { RpcApi } from './rpc-api';\nimport { PendingRpcRequest, RpcRequest, RpcSendOptions } from './rpc-request';\nimport { RpcTransport } from './rpc-transport';\n\nexport type RpcConfig<TRpcMethods, TRpcTransport extends RpcTransport> = Readonly<{\n    api: RpcApi<TRpcMethods>;\n    transport: TRpcTransport;\n}>;\n\nexport type Rpc<TRpcMethods> = {\n    [TMethodName in keyof TRpcMethods]: PendingRpcRequestBuilder<OverloadImplementations<TRpcMethods, TMethodName>>;\n};\n\ntype PendingRpcRequestBuilder<TMethodImplementations> = UnionToIntersection<\n    Flatten<{\n        [P in keyof TMethodImplementations]: PendingRpcRequestReturnTypeMapper<TMethodImplementations[P]>;\n    }>\n>;\n\ntype PendingRpcRequestReturnTypeMapper<TMethodImplementation> =\n    // Check that this property of the TRpcMethods interface is, in fact, a function.\n    TMethodImplementation extends Callable\n        ? (...args: Parameters<TMethodImplementation>) => PendingRpcRequest<ReturnType<TMethodImplementation>>\n        : never;\n\nexport function createRpc<TRpcMethods, TRpcTransport extends RpcTransport>(\n    rpcConfig: RpcConfig<TRpcMethods, TRpcTransport>,\n): Rpc<TRpcMethods> {\n    return makeProxy(rpcConfig) as Rpc<TRpcMethods>;\n}\n\nfunction makeProxy<TRpcMethods, TRpcTransport extends RpcTransport>(\n    rpcConfig: RpcConfig<TRpcMethods, TRpcTransport>,\n): Rpc<TRpcMethods> {\n    return new Proxy(rpcConfig.api, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get(target, p, receiver) {\n            return function (...rawParams: unknown[]) {\n                const methodName = p.toString();\n                const createRpcRequest = Reflect.get(target, methodName, receiver);\n                const newRequest = createRpcRequest\n                    ? createRpcRequest(...rawParams)\n                    : { methodName, params: rawParams };\n                return createPendingRpcRequest(rpcConfig, newRequest);\n            };\n        },\n    }) as Rpc<TRpcMethods>;\n}\n\nfunction createPendingRpcRequest<TRpcMethods, TRpcTransport extends RpcTransport, TResponse>(\n    rpcConfig: RpcConfig<TRpcMethods, TRpcTransport>,\n    pendingRequest: RpcRequest<TResponse>,\n): PendingRpcRequest<TResponse> {\n    return {\n        async send(options?: RpcSendOptions): Promise<TResponse> {\n            const { methodName, params, responseTransformer } = pendingRequest;\n            const payload = createRpcMessage(methodName, params);\n            const response = await rpcConfig.transport<RpcResponse<unknown>>({\n                payload,\n                signal: options?.abortSignal,\n            });\n            if ('error' in response) {\n                throw getSolanaErrorFromJsonRpcError(response.error);\n            }\n            return (\n                responseTransformer ? responseTransformer(response.result, methodName) : response.result\n            ) as TResponse;\n        },\n    };\n}\n","import { Callable } from '@solana/rpc-spec-types';\n\nimport { RpcRequest } from './rpc-request';\n\nexport type RpcApiConfig = Readonly<{\n    parametersTransformer?: <T extends unknown[]>(params: T, methodName: string) => unknown[];\n    responseTransformer?: <T>(response: unknown, methodName: string) => T;\n}>;\n\nexport type RpcApi<TRpcMethods> = {\n    [MethodName in keyof TRpcMethods]: RpcReturnTypeMapper<TRpcMethods[MethodName]>;\n};\n\ntype RpcReturnTypeMapper<TRpcMethod> = TRpcMethod extends Callable\n    ? (...rawParams: unknown[]) => RpcRequest<ReturnType<TRpcMethod>>\n    : never;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RpcApiMethod = (...args: any) => any;\nexport interface RpcApiMethods {\n    [methodName: string]: RpcApiMethod;\n}\n\nexport function createRpcApi<TRpcMethods extends RpcApiMethods>(config?: RpcApiConfig): RpcApi<TRpcMethods> {\n    return new Proxy({} as RpcApi<TRpcMethods>, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get<TMethodName extends keyof RpcApi<TRpcMethods>>(\n            ...args: Parameters<NonNullable<ProxyHandler<RpcApi<TRpcMethods>>['get']>>\n        ) {\n            const [_, p] = args;\n            const methodName = p.toString() as keyof TRpcMethods as string;\n            return function (\n                ...rawParams: Parameters<\n                    TRpcMethods[TMethodName] extends CallableFunction ? TRpcMethods[TMethodName] : never\n                >\n            ): RpcRequest<ReturnType<TRpcMethods[TMethodName]>> {\n                const params = config?.parametersTransformer\n                    ? config?.parametersTransformer(rawParams, methodName)\n                    : rawParams;\n                const responseTransformer = config?.responseTransformer\n                    ? config?.responseTransformer<ReturnType<TRpcMethods[TMethodName]>>\n                    : (rawResponse: unknown) => rawResponse as ReturnType<TRpcMethods[TMethodName]>;\n                return {\n                    methodName,\n                    params,\n                    responseTransformer,\n                };\n            };\n        },\n    });\n}\n","import type { Commitment } from '@solana/rpc-types';\n\ntype Config = Readonly<{\n    commitmentPropertyName: string;\n    optionsObjectPositionInParams: number;\n    overrideCommitment?: Commitment;\n    params: unknown[];\n}>;\n\nexport function applyDefaultCommitment({\n    commitmentPropertyName,\n    params,\n    optionsObjectPositionInParams,\n    overrideCommitment,\n}: Config) {\n    const paramInTargetPosition = params[optionsObjectPositionInParams];\n    if (\n        // There's no config.\n        paramInTargetPosition === undefined ||\n        // There is a config object.\n        (paramInTargetPosition && typeof paramInTargetPosition === 'object' && !Array.isArray(paramInTargetPosition))\n    ) {\n        if (\n            // The config object already has a commitment set.\n            paramInTargetPosition &&\n            commitmentPropertyName in paramInTargetPosition\n        ) {\n            if (\n                !paramInTargetPosition[commitmentPropertyName as keyof typeof paramInTargetPosition] ||\n                paramInTargetPosition[commitmentPropertyName as keyof typeof paramInTargetPosition] === 'finalized'\n            ) {\n                // Delete the commitment property; `finalized` is already the server default.\n                const nextParams = [...params];\n                const {\n                    [commitmentPropertyName as keyof typeof paramInTargetPosition]: _, // eslint-disable-line @typescript-eslint/no-unused-vars\n                    ...rest\n                } = paramInTargetPosition;\n                if (Object.keys(rest).length > 0) {\n                    nextParams[optionsObjectPositionInParams] = rest;\n                } else {\n                    if (optionsObjectPositionInParams === nextParams.length - 1) {\n                        nextParams.length--;\n                    } else {\n                        nextParams[optionsObjectPositionInParams] = undefined;\n                    }\n                }\n                return nextParams;\n            }\n        } else if (overrideCommitment !== 'finalized') {\n            // Apply the default commitment.\n            const nextParams = [...params];\n            nextParams[optionsObjectPositionInParams] = {\n                ...paramInTargetPosition,\n                [commitmentPropertyName]: overrideCommitment,\n            };\n            return nextParams;\n        }\n    }\n    return params;\n}\n","export function downcastNodeToNumberIfBigint(value: bigint): number;\nexport function downcastNodeToNumberIfBigint<T>(value: T): T;\nexport function downcastNodeToNumberIfBigint(value: unknown): unknown {\n    return typeof value === 'bigint'\n        ? // FIXME(solana-labs/solana/issues/30341) Create a data type to represent u64 in the Solana\n          // JSON RPC implementation so that we can throw away this entire patcher instead of unsafely\n          // downcasting `bigints` to `numbers`.\n          Number(value)\n        : value;\n}\n","import { KeyPath, TraversalState } from './tree-traversal';\n\ntype IntegerOverflowHandler = (keyPath: KeyPath, value: bigint) => void;\n\nexport function getIntegerOverflowNodeVisitor(onIntegerOverflow: IntegerOverflowHandler) {\n    return <T>(value: T, { keyPath }: TraversalState): T => {\n        if (typeof value === 'bigint') {\n            if (onIntegerOverflow && (value > Number.MAX_SAFE_INTEGER || value < -Number.MAX_SAFE_INTEGER)) {\n                onIntegerOverflow(keyPath as (number | string)[], value);\n            }\n        }\n        return value;\n    };\n}\n","export const OPTIONS_OBJECT_POSITION_BY_METHOD: Record<string, number> = {\n    accountNotifications: 1,\n    blockNotifications: 1,\n    getAccountInfo: 1,\n    getBalance: 1,\n    getBlock: 1,\n    getBlockHeight: 0,\n    getBlockProduction: 0,\n    getBlocks: 2,\n    getBlocksWithLimit: 2,\n    getConfirmedBlock: 1,\n    getConfirmedBlocks: 1,\n    getConfirmedBlocksWithLimit: 2,\n    getConfirmedSignaturesForAddress2: 1,\n    getConfirmedTransaction: 1,\n    getEpochInfo: 0,\n    getFeeCalculatorForBlockhash: 1,\n    getFeeForMessage: 1,\n    getFees: 1,\n    getInflationGovernor: 0,\n    getInflationReward: 1,\n    getLargestAccounts: 0,\n    getLatestBlockhash: 0,\n    getLeaderSchedule: 1,\n    getMinimumBalanceForRentExemption: 1,\n    getMultipleAccounts: 1,\n    getProgramAccounts: 1,\n    getRecentBlockhash: 1,\n    getSignaturesForAddress: 1,\n    getSlot: 0,\n    getSlotLeader: 0,\n    getStakeActivation: 1,\n    getStakeMinimumDelegation: 0,\n    getSupply: 0,\n    getTokenAccountBalance: 1,\n    getTokenAccountsByDelegate: 2,\n    getTokenAccountsByOwner: 2,\n    getTokenLargestAccounts: 1,\n    getTokenSupply: 1,\n    getTransaction: 1,\n    getTransactionCount: 0,\n    getVoteAccounts: 0,\n    isBlockhashValid: 1,\n    logsNotifications: 1,\n    programNotifications: 1,\n    requestAirdrop: 2,\n    sendTransaction: 1,\n    signatureNotifications: 1,\n    simulateTransaction: 1,\n};\n","export type KeyPathWildcard = { readonly __brand: unique symbol };\nexport type KeyPath = ReadonlyArray<KeyPath | KeyPathWildcard | number | string>;\n\nexport const KEYPATH_WILDCARD = {} as KeyPathWildcard;\n\ntype NodeVisitor = <TState extends TraversalState>(value: unknown, state: TState) => unknown;\nexport type TraversalState = Readonly<{\n    keyPath: KeyPath;\n}>;\n\nexport function getTreeWalker(visitors: NodeVisitor[]) {\n    return function traverse<TState extends TraversalState>(node: unknown, state: TState): unknown {\n        if (Array.isArray(node)) {\n            return node.map((element, ii) => {\n                const nextState = {\n                    ...state,\n                    keyPath: [...state.keyPath, ii],\n                };\n                return traverse(element, nextState);\n            });\n        } else if (typeof node === 'object' && node !== null) {\n            const out: Record<number | string | symbol, unknown> = {};\n            for (const propName in node) {\n                if (!Object.prototype.hasOwnProperty.call(node, propName)) {\n                    continue;\n                }\n                const nextState = {\n                    ...state,\n                    keyPath: [...state.keyPath, propName],\n                };\n                out[propName] = traverse(node[propName as keyof typeof node], nextState);\n            }\n            return out;\n        } else {\n            return visitors.reduce((acc, visitNode) => visitNode(acc, state), node);\n        }\n    };\n}\n","import { Commitment } from '@solana/rpc-types';\n\nimport { applyDefaultCommitment } from './default-commitment';\nimport { downcastNodeToNumberIfBigint } from './params-transformer-bigint-downcast';\nimport { getIntegerOverflowNodeVisitor } from './params-transformer-integer-overflow';\nimport { OPTIONS_OBJECT_POSITION_BY_METHOD } from './params-transformer-options-object-position-config';\nimport { getTreeWalker, KeyPath } from './tree-traversal';\n\nexport type ParamsTransformerConfig = Readonly<{\n    defaultCommitment?: Commitment;\n    onIntegerOverflow?: (methodName: string, keyPath: KeyPath, value: bigint) => void;\n}>;\n\nexport function getDefaultParamsTransformerForSolanaRpc(config?: ParamsTransformerConfig) {\n    const defaultCommitment = config?.defaultCommitment;\n    const handleIntegerOverflow = config?.onIntegerOverflow;\n    return <T>(rawParams: T, methodName: string) => {\n        const traverse = getTreeWalker([\n            ...(handleIntegerOverflow\n                ? [getIntegerOverflowNodeVisitor((...args) => handleIntegerOverflow(methodName, ...args))]\n                : []),\n            downcastNodeToNumberIfBigint,\n        ]);\n        const initialState = {\n            keyPath: [],\n        };\n        const patchedParams = traverse(rawParams, initialState);\n        if (!Array.isArray(patchedParams)) {\n            return patchedParams;\n        }\n        const optionsObjectPositionInParams = OPTIONS_OBJECT_POSITION_BY_METHOD[methodName];\n        if (optionsObjectPositionInParams == null) {\n            return patchedParams;\n        }\n        return applyDefaultCommitment({\n            commitmentPropertyName: methodName === 'sendTransaction' ? 'preflightCommitment' : 'commitment',\n            optionsObjectPositionInParams,\n            overrideCommitment: defaultCommitment,\n            params: patchedParams,\n        });\n    };\n}\n","import { KeyPath, KEYPATH_WILDCARD, TraversalState } from './tree-traversal';\n\nfunction keyPathIsAllowedToBeNumeric(keyPath: KeyPath, allowedNumericKeyPaths: readonly KeyPath[]) {\n    return allowedNumericKeyPaths.some(prohibitedKeyPath => {\n        if (prohibitedKeyPath.length !== keyPath.length) {\n            return false;\n        }\n        for (let ii = keyPath.length - 1; ii >= 0; ii--) {\n            const keyPathPart = keyPath[ii];\n            const prohibitedKeyPathPart = prohibitedKeyPath[ii];\n            if (\n                prohibitedKeyPathPart !== keyPathPart &&\n                (prohibitedKeyPathPart !== KEYPATH_WILDCARD || typeof keyPathPart !== 'number')\n            ) {\n                return false;\n            }\n        }\n        return true;\n    });\n}\n\nexport function getBigIntUpcastVisitor(allowedNumericKeyPaths: readonly KeyPath[]) {\n    return function upcastNodeToBigIntIfNumber(value: unknown, { keyPath }: TraversalState) {\n        if (\n            typeof value === 'number' &&\n            Number.isInteger(value) &&\n            !keyPathIsAllowedToBeNumeric(keyPath, allowedNumericKeyPaths)\n        ) {\n            // FIXME(solana-labs/solana/issues/30341) Create a data type to represent u64 in the\n            // Solana JSON RPC implementation so that we can throw away this entire patcher instead\n            // of unsafely upcasting `numbers` to `bigints`.\n            return BigInt(value);\n        } else {\n            return value;\n        }\n    };\n}\n","import { AllowedNumericKeypaths } from './response-transformer-allowed-numeric-values';\nimport { getBigIntUpcastVisitor } from './response-transformer-bigint-upcast';\nimport { getTreeWalker } from './tree-traversal';\n\nexport type ResponseTransformerConfig<TApi> = Readonly<{\n    allowedNumericKeyPaths?: AllowedNumericKeypaths<TApi>;\n}>;\n\nexport function getDefaultResponseTransformerForSolanaRpc<TApi>(config?: ResponseTransformerConfig<TApi>) {\n    return <T>(rawResponse: unknown, methodName?: keyof TApi): T => {\n        const keyPaths =\n            config?.allowedNumericKeyPaths && methodName ? config.allowedNumericKeyPaths[methodName] : undefined;\n        const traverse = getTreeWalker([getBigIntUpcastVisitor(keyPaths ?? [])]);\n        const initialState = {\n            keyPath: [],\n        };\n        return traverse(rawResponse, initialState) as T;\n    };\n}\n","import { KeyPath, KEYPATH_WILDCARD } from './tree-traversal';\n\nexport type AllowedNumericKeypaths<TApi> = Partial<Record<keyof TApi, readonly KeyPath[]>>;\n\n// Numeric values nested in `jsonParsed` accounts\nexport const jsonParsedTokenAccountsConfigs = [\n    // parsed Token/Token22 token account\n    ['data', 'parsed', 'info', 'tokenAmount', 'decimals'],\n    ['data', 'parsed', 'info', 'tokenAmount', 'uiAmount'],\n    ['data', 'parsed', 'info', 'rentExemptReserve', 'decimals'],\n    ['data', 'parsed', 'info', 'rentExemptReserve', 'uiAmount'],\n    ['data', 'parsed', 'info', 'delegatedAmount', 'decimals'],\n    ['data', 'parsed', 'info', 'delegatedAmount', 'uiAmount'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'olderTransferFee', 'transferFeeBasisPoints'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'newerTransferFee', 'transferFeeBasisPoints'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'preUpdateAverageRate'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'currentRate'],\n];\nexport const jsonParsedAccountsConfigs = [\n    ...jsonParsedTokenAccountsConfigs,\n    // parsed AddressTableLookup account\n    ['data', 'parsed', 'info', 'lastExtendedSlotStartIndex'],\n    // parsed Config account\n    ['data', 'parsed', 'info', 'slashPenalty'],\n    ['data', 'parsed', 'info', 'warmupCooldownRate'],\n    // parsed Token/Token22 mint account\n    ['data', 'parsed', 'info', 'decimals'],\n    // parsed Token/Token22 multisig account\n    ['data', 'parsed', 'info', 'numRequiredSigners'],\n    ['data', 'parsed', 'info', 'numValidSigners'],\n    // parsed Stake account\n    ['data', 'parsed', 'info', 'stake', 'delegation', 'warmupCooldownRate'],\n    // parsed Sysvar rent account\n    ['data', 'parsed', 'info', 'exemptionThreshold'],\n    ['data', 'parsed', 'info', 'burnPercent'],\n    // parsed Vote account\n    ['data', 'parsed', 'info', 'commission'],\n    ['data', 'parsed', 'info', 'votes', KEYPATH_WILDCARD, 'confirmationCount'],\n];\n","import { createRpcApi, RpcApi } from '@solana/rpc-spec';\nimport {\n    AllowedNumericKeypaths,\n    getDefaultParamsTransformerForSolanaRpc,\n    getDefaultResponseTransformerForSolanaRpc,\n    jsonParsedAccountsConfigs,\n    jsonParsedTokenAccountsConfigs,\n    KEYPATH_WILDCARD,\n    ParamsTransformerConfig,\n} from '@solana/rpc-transformers';\n\nimport { GetAccountInfoApi } from './getAccountInfo';\nimport { GetBalanceApi } from './getBalance';\nimport { GetBlockApi } from './getBlock';\nimport { GetBlockCommitmentApi } from './getBlockCommitment';\nimport { GetBlockHeightApi } from './getBlockHeight';\nimport { GetBlockProductionApi } from './getBlockProduction';\nimport { GetBlocksApi } from './getBlocks';\nimport { GetBlocksWithLimitApi } from './getBlocksWithLimit';\nimport { GetBlockTimeApi } from './getBlockTime';\nimport { GetClusterNodesApi } from './getClusterNodes';\nimport { GetEpochInfoApi } from './getEpochInfo';\nimport { GetEpochScheduleApi } from './getEpochSchedule';\nimport { GetFeeForMessageApi } from './getFeeForMessage';\nimport { GetFirstAvailableBlockApi } from './getFirstAvailableBlock';\nimport { GetGenesisHashApi } from './getGenesisHash';\nimport { GetHealthApi } from './getHealth';\nimport { GetHighestSnapshotSlotApi } from './getHighestSnapshotSlot';\nimport { GetIdentityApi } from './getIdentity';\nimport { GetInflationGovernorApi } from './getInflationGovernor';\nimport { GetInflationRateApi } from './getInflationRate';\nimport { GetInflationRewardApi } from './getInflationReward';\nimport { GetLargestAccountsApi } from './getLargestAccounts';\nimport { GetLatestBlockhashApi } from './getLatestBlockhash';\nimport { GetLeaderScheduleApi } from './getLeaderSchedule';\nimport { GetMaxRetransmitSlotApi } from './getMaxRetransmitSlot';\nimport { GetMaxShredInsertSlotApi } from './getMaxShredInsertSlot';\nimport { GetMinimumBalanceForRentExemptionApi } from './getMinimumBalanceForRentExemption';\nimport { GetMultipleAccountsApi } from './getMultipleAccounts';\nimport { GetProgramAccountsApi } from './getProgramAccounts';\nimport { GetRecentPerformanceSamplesApi } from './getRecentPerformanceSamples';\nimport { GetRecentPrioritizationFeesApi } from './getRecentPrioritizationFees';\nimport { GetSignaturesForAddressApi } from './getSignaturesForAddress';\nimport { GetSignatureStatusesApi } from './getSignatureStatuses';\nimport { GetSlotApi } from './getSlot';\nimport { GetSlotLeaderApi } from './getSlotLeader';\nimport { GetSlotLeadersApi } from './getSlotLeaders';\nimport { GetStakeActivationApi } from './getStakeActivation';\nimport { GetStakeMinimumDelegationApi } from './getStakeMinimumDelegation';\nimport { GetSupplyApi } from './getSupply';\nimport { GetTokenAccountBalanceApi } from './getTokenAccountBalance';\nimport { GetTokenAccountsByDelegateApi } from './getTokenAccountsByDelegate';\nimport { GetTokenAccountsByOwnerApi } from './getTokenAccountsByOwner';\nimport { GetTokenLargestAccountsApi } from './getTokenLargestAccounts';\nimport { GetTokenSupplyApi } from './getTokenSupply';\nimport { GetTransactionApi } from './getTransaction';\nimport { GetTransactionCountApi } from './getTransactionCount';\nimport { GetVersionApi } from './getVersion';\nimport { GetVoteAccountsApi } from './getVoteAccounts';\nimport { IsBlockhashValidApi } from './isBlockhashValid';\nimport { MinimumLedgerSlotApi } from './minimumLedgerSlot';\nimport { RequestAirdropApi } from './requestAirdrop';\nimport { SendTransactionApi } from './sendTransaction';\nimport { SimulateTransactionApi } from './simulateTransaction';\n\ntype SolanaRpcApiForAllClusters = GetAccountInfoApi &\n    GetBalanceApi &\n    GetBlockApi &\n    GetBlockCommitmentApi &\n    GetBlockHeightApi &\n    GetBlockProductionApi &\n    GetBlocksApi &\n    GetBlocksWithLimitApi &\n    GetBlockTimeApi &\n    GetClusterNodesApi &\n    GetEpochInfoApi &\n    GetEpochScheduleApi &\n    GetFeeForMessageApi &\n    GetFirstAvailableBlockApi &\n    GetGenesisHashApi &\n    GetHealthApi &\n    GetHighestSnapshotSlotApi &\n    GetIdentityApi &\n    GetInflationGovernorApi &\n    GetInflationRateApi &\n    GetInflationRewardApi &\n    GetLargestAccountsApi &\n    GetLatestBlockhashApi &\n    GetLeaderScheduleApi &\n    GetMaxRetransmitSlotApi &\n    GetMaxShredInsertSlotApi &\n    GetMinimumBalanceForRentExemptionApi &\n    GetMultipleAccountsApi &\n    GetProgramAccountsApi &\n    GetRecentPerformanceSamplesApi &\n    GetRecentPrioritizationFeesApi &\n    GetSignaturesForAddressApi &\n    GetSignatureStatusesApi &\n    GetSlotApi &\n    GetSlotLeaderApi &\n    GetSlotLeadersApi &\n    GetStakeActivationApi &\n    GetStakeMinimumDelegationApi &\n    GetSupplyApi &\n    GetTokenAccountBalanceApi &\n    GetTokenAccountsByDelegateApi &\n    GetTokenAccountsByOwnerApi &\n    GetTokenLargestAccountsApi &\n    GetTokenSupplyApi &\n    GetTransactionApi &\n    GetTransactionCountApi &\n    GetVersionApi &\n    GetVoteAccountsApi &\n    IsBlockhashValidApi &\n    MinimumLedgerSlotApi &\n    SendTransactionApi &\n    SimulateTransactionApi;\ntype SolanaRpcApiForTestClusters = RequestAirdropApi & SolanaRpcApiForAllClusters;\nexport type SolanaRpcApi = SolanaRpcApiForTestClusters;\nexport type SolanaRpcApiDevnet = SolanaRpcApiForTestClusters;\nexport type SolanaRpcApiTestnet = SolanaRpcApiForTestClusters;\nexport type SolanaRpcApiMainnet = SolanaRpcApiForAllClusters;\n\nexport type {\n    GetAccountInfoApi,\n    GetBalanceApi,\n    GetBlockApi,\n    GetBlockCommitmentApi,\n    GetBlockHeightApi,\n    GetBlockProductionApi,\n    GetBlocksApi,\n    GetBlocksWithLimitApi,\n    GetBlockTimeApi,\n    GetClusterNodesApi,\n    GetEpochInfoApi,\n    GetEpochScheduleApi,\n    GetFeeForMessageApi,\n    GetFirstAvailableBlockApi,\n    GetGenesisHashApi,\n    GetHealthApi,\n    GetHighestSnapshotSlotApi,\n    GetIdentityApi,\n    GetInflationGovernorApi,\n    GetInflationRateApi,\n    GetInflationRewardApi,\n    GetLargestAccountsApi,\n    GetLatestBlockhashApi,\n    GetLeaderScheduleApi,\n    GetMaxRetransmitSlotApi,\n    GetMaxShredInsertSlotApi,\n    GetMinimumBalanceForRentExemptionApi,\n    GetMultipleAccountsApi,\n    GetProgramAccountsApi,\n    GetRecentPerformanceSamplesApi,\n    GetRecentPrioritizationFeesApi,\n    GetSignaturesForAddressApi,\n    GetSignatureStatusesApi,\n    GetSlotApi,\n    GetSlotLeaderApi,\n    GetSlotLeadersApi,\n    GetStakeActivationApi,\n    GetStakeMinimumDelegationApi,\n    GetSupplyApi,\n    GetTokenAccountBalanceApi,\n    GetTokenAccountsByDelegateApi,\n    GetTokenAccountsByOwnerApi,\n    GetTokenLargestAccountsApi,\n    GetTokenSupplyApi,\n    GetTransactionApi,\n    GetTransactionCountApi,\n    GetVersionApi,\n    GetVoteAccountsApi,\n    IsBlockhashValidApi,\n    MinimumLedgerSlotApi,\n    RequestAirdropApi,\n    SendTransactionApi,\n    SimulateTransactionApi,\n};\n\ntype Config = ParamsTransformerConfig;\n\nexport function createSolanaRpcApi<\n    TRpcMethods extends SolanaRpcApi | SolanaRpcApiDevnet | SolanaRpcApiMainnet | SolanaRpcApiTestnet = SolanaRpcApi,\n>(config?: Config): RpcApi<TRpcMethods> {\n    return createRpcApi<TRpcMethods>({\n        parametersTransformer: getDefaultParamsTransformerForSolanaRpc(config) as (params: unknown[]) => unknown[],\n        responseTransformer: getDefaultResponseTransformerForSolanaRpc({\n            allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n        }),\n    });\n}\n\nlet memoizedKeypaths: AllowedNumericKeypaths<RpcApi<SolanaRpcApi>>;\n\n/**\n * These are keypaths at the end of which you will find a numeric value that should *not* be upcast\n * to a `bigint`. These are values that are legitimately defined as `u8` or `usize` on the backend.\n */\nfunction getAllowedNumericKeypaths(): AllowedNumericKeypaths<RpcApi<SolanaRpcApi>> {\n    if (!memoizedKeypaths) {\n        memoizedKeypaths = {\n            getAccountInfo: jsonParsedAccountsConfigs.map(c => ['value', ...c]),\n            getBlock: [\n                ['blockTime'],\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'preTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'preTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'postTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'postTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'rewards', KEYPATH_WILDCARD, 'commission'],\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'innerInstructions', KEYPATH_WILDCARD, 'index'],\n                [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'programIdIndex',\n                ],\n                [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'accounts',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'addressTableLookups',\n                    KEYPATH_WILDCARD,\n                    'writableIndexes',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'addressTableLookups',\n                    KEYPATH_WILDCARD,\n                    'readonlyIndexes',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'programIdIndex',\n                ],\n                [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'accounts',\n                    KEYPATH_WILDCARD,\n                ],\n                ['transactions', KEYPATH_WILDCARD, 'transaction', 'message', 'header', 'numReadonlySignedAccounts'],\n                ['transactions', KEYPATH_WILDCARD, 'transaction', 'message', 'header', 'numReadonlyUnsignedAccounts'],\n                ['transactions', KEYPATH_WILDCARD, 'transaction', 'message', 'header', 'numRequiredSignatures'],\n                ['rewards', KEYPATH_WILDCARD, 'commission'],\n            ],\n            getBlockTime: [[]],\n            getClusterNodes: [\n                [KEYPATH_WILDCARD, 'featureSet'],\n                [KEYPATH_WILDCARD, 'shredVersion'],\n            ],\n            getInflationGovernor: [['initial'], ['foundation'], ['foundationTerm'], ['taper'], ['terminal']],\n            getInflationRate: [['foundation'], ['total'], ['validator']],\n            getInflationReward: [[KEYPATH_WILDCARD, 'commission']],\n            getMultipleAccounts: jsonParsedAccountsConfigs.map(c => ['value', KEYPATH_WILDCARD, ...c]),\n            getProgramAccounts: jsonParsedAccountsConfigs.flatMap(c => [\n                ['value', KEYPATH_WILDCARD, 'account', ...c],\n                [KEYPATH_WILDCARD, 'account', ...c],\n            ]),\n            getRecentPerformanceSamples: [[KEYPATH_WILDCARD, 'samplePeriodSecs']],\n            getTokenAccountBalance: [\n                ['value', 'decimals'],\n                ['value', 'uiAmount'],\n            ],\n            getTokenAccountsByDelegate: jsonParsedTokenAccountsConfigs.map(c => [\n                'value',\n                KEYPATH_WILDCARD,\n                'account',\n                ...c,\n            ]),\n            getTokenAccountsByOwner: jsonParsedTokenAccountsConfigs.map(c => [\n                'value',\n                KEYPATH_WILDCARD,\n                'account',\n                ...c,\n            ]),\n            getTokenLargestAccounts: [\n                ['value', KEYPATH_WILDCARD, 'decimals'],\n                ['value', KEYPATH_WILDCARD, 'uiAmount'],\n            ],\n            getTokenSupply: [\n                ['value', 'decimals'],\n                ['value', 'uiAmount'],\n            ],\n            getTransaction: [\n                ['meta', 'preTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                ['meta', 'preTokenBalances', KEYPATH_WILDCARD, 'uiTokenAmount', 'decimals'],\n                ['meta', 'postTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                ['meta', 'postTokenBalances', KEYPATH_WILDCARD, 'uiTokenAmount', 'decimals'],\n                ['meta', 'rewards', KEYPATH_WILDCARD, 'commission'],\n                ['meta', 'innerInstructions', KEYPATH_WILDCARD, 'index'],\n                ['meta', 'innerInstructions', KEYPATH_WILDCARD, 'instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n                [\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'accounts',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'transaction',\n                    'message',\n                    'addressTableLookups',\n                    KEYPATH_WILDCARD,\n                    'writableIndexes',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'transaction',\n                    'message',\n                    'addressTableLookups',\n                    KEYPATH_WILDCARD,\n                    'readonlyIndexes',\n                    KEYPATH_WILDCARD,\n                ],\n                ['transaction', 'message', 'instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n                ['transaction', 'message', 'instructions', KEYPATH_WILDCARD, 'accounts', KEYPATH_WILDCARD],\n                ['transaction', 'message', 'header', 'numReadonlySignedAccounts'],\n                ['transaction', 'message', 'header', 'numReadonlyUnsignedAccounts'],\n                ['transaction', 'message', 'header', 'numRequiredSignatures'],\n            ],\n            getVersion: [['feature-set']],\n            getVoteAccounts: [\n                ['current', KEYPATH_WILDCARD, 'commission'],\n                ['delinquent', KEYPATH_WILDCARD, 'commission'],\n            ],\n            simulateTransaction: jsonParsedAccountsConfigs.map(c => ['value', 'accounts', KEYPATH_WILDCARD, ...c]),\n        };\n    }\n    return memoizedKeypaths;\n}\n","import { SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, SolanaError } from '@solana/errors';\nimport { RpcTransport } from '@solana/rpc-spec';\nimport type Dispatcher from 'undici-types/dispatcher';\n\nimport {\n    AllowedHttpRequestHeaders,\n    assertIsAllowedHttpRequestHeaders,\n    normalizeHeaders,\n} from './http-transport-headers';\n\ntype Config = Readonly<{\n    dispatcher_NODE_ONLY?: Dispatcher;\n    headers?: AllowedHttpRequestHeaders;\n    url: string;\n}>;\n\nlet didWarnDispatcherWasSuppliedInNonNodeEnvironment = false;\nfunction warnDispatcherWasSuppliedInNonNodeEnvironment() {\n    if (didWarnDispatcherWasSuppliedInNonNodeEnvironment) {\n        return;\n    }\n    didWarnDispatcherWasSuppliedInNonNodeEnvironment = true;\n    console.warn(\n        'You have supplied a `Dispatcher` to `createHttpTransport()`. It has been ignored ' +\n            'because Undici dispatchers only work in Node environments. To eliminate this ' +\n            'warning, omit the `dispatcher_NODE_ONLY` property from your config when running in ' +\n            'a non-Node environment.',\n    );\n}\n\nexport function createHttpTransport(config: Config): RpcTransport {\n    if (__DEV__ && !__NODEJS__ && 'dispatcher_NODE_ONLY' in config) {\n        warnDispatcherWasSuppliedInNonNodeEnvironment();\n    }\n    const { headers, url } = config;\n    if (__DEV__ && headers) {\n        assertIsAllowedHttpRequestHeaders(headers);\n    }\n    let dispatcherConfig: { dispatcher: Dispatcher | undefined } | undefined;\n    if (__NODEJS__ && 'dispatcher_NODE_ONLY' in config) {\n        dispatcherConfig = { dispatcher: config.dispatcher_NODE_ONLY };\n    }\n    const customHeaders = headers && normalizeHeaders(headers);\n    return async function makeHttpRequest<TResponse>({\n        payload,\n        signal,\n    }: Parameters<RpcTransport>[0]): Promise<TResponse> {\n        const body = JSON.stringify(payload);\n        const requestInfo = {\n            ...dispatcherConfig,\n            body,\n            headers: {\n                ...customHeaders,\n                // Keep these headers lowercase so they will override any user-supplied headers above.\n                accept: 'application/json',\n                'content-length': body.length.toString(),\n                'content-type': 'application/json; charset=utf-8',\n            },\n            method: 'POST',\n            signal,\n        };\n        const response = await fetch(url, requestInfo);\n        if (!response.ok) {\n            throw new SolanaError(SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, {\n                message: response.statusText,\n                statusCode: response.status,\n            });\n        }\n        return (await response.json()) as TResponse;\n    };\n}\n","import { SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, SolanaError } from '@solana/errors';\n\nexport type AllowedHttpRequestHeaders = Readonly<\n    {\n        // Someone can still sneak a forbidden header past Typescript if they do something like\n        // fOo-BaR, but at that point they deserve the runtime failure.\n        [K in DisallowedHeaders | ForbiddenHeaders as\n            | Capitalize<Lowercase<K>> // `Foo-bar`\n            | K // `Foo-Bar`\n            | Lowercase<K> // `foo-bar`\n            | Uncapitalize<K> // `foo-Bar`\n            // `FOO-BAR`\n            | Uppercase<K>]?: never;\n    } & { [headerName: string]: string }\n>;\n// These are headers that we simply don't allow the developer to override because they're\n// fundamental to the operation of the JSON-RPC transport.\ntype DisallowedHeaders = 'Accept' | 'Content-Length' | 'Content-Type' | 'Solana-Client';\ntype ForbiddenHeaders =\n    | 'Accept-Charset'\n    | 'Accept-Encoding'\n    | 'Access-Control-Request-Headers'\n    | 'Access-Control-Request-Method'\n    | 'Connection'\n    | 'Content-Length'\n    | 'Cookie'\n    | 'Date'\n    | 'DNT'\n    | 'Expect'\n    | 'Host'\n    | 'Keep-Alive'\n    | 'Origin'\n    | 'Permissions-Policy'\n    | 'Referer'\n    | 'TE'\n    | 'Trailer'\n    | 'Transfer-Encoding'\n    | 'Upgrade'\n    | 'Via'\n    | `Proxy-${string}`\n    | `Sec-${string}`;\n\n// These are headers which are fundamental to the JSON-RPC transport, and must not be modified.\nconst DISALLOWED_HEADERS: Record<string, boolean> = {\n    accept: true,\n    'content-length': true,\n    'content-type': true,\n};\n// https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\nconst FORBIDDEN_HEADERS: Record<string, boolean> = {\n    'accept-charset': true,\n    'accept-encoding': true,\n    'access-control-request-headers': true,\n    'access-control-request-method': true,\n    connection: true,\n    'content-length': true,\n    cookie: true,\n    date: true,\n    dnt: true,\n    expect: true,\n    host: true,\n    'keep-alive': true,\n    origin: true,\n    'permissions-policy': true,\n    // Prefix matching is implemented in code, below.\n    // 'proxy-': true,\n    // 'sec-': true,\n    referer: true,\n    te: true,\n    trailer: true,\n    'transfer-encoding': true,\n    upgrade: true,\n    via: true,\n};\n\nexport function assertIsAllowedHttpRequestHeaders(\n    headers: Record<string, string>,\n): asserts headers is AllowedHttpRequestHeaders {\n    const badHeaders = Object.keys(headers).filter(headerName => {\n        const lowercaseHeaderName = headerName.toLowerCase();\n        return (\n            DISALLOWED_HEADERS[headerName.toLowerCase()] === true ||\n            FORBIDDEN_HEADERS[headerName.toLowerCase()] === true ||\n            lowercaseHeaderName.startsWith('proxy-') ||\n            lowercaseHeaderName.startsWith('sec-')\n        );\n    });\n    if (badHeaders.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, {\n            headers: badHeaders,\n        });\n    }\n}\n\n/**\n * Lowercasing header names makes it easier to override user-supplied headers, such as those defined\n * in the `DisallowedHeaders` type.\n */\nexport function normalizeHeaders<T extends Record<string, string>>(\n    headers: T,\n): { [K in string & keyof T as Lowercase<K>]: T[K] } {\n    const out: Record<string, string> = {};\n    for (const headerName in headers) {\n        out[headerName.toLowerCase()] = headers[headerName];\n    }\n    return out as { [K in string & keyof T as Lowercase<K>]: T[K] };\n}\n","import { safeCaptureStackTrace, SOLANA_ERROR__RPC__INTEGER_OVERFLOW, SolanaError } from '@solana/errors';\nimport type { KeyPath } from '@solana/rpc-transformers';\n\nexport function createSolanaJsonRpcIntegerOverflowError(\n    methodName: string,\n    keyPath: KeyPath,\n    value: bigint,\n): SolanaError<typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW> {\n    let argumentLabel = '';\n    if (typeof keyPath[0] === 'number') {\n        const argPosition = keyPath[0] + 1;\n        const lastDigit = argPosition % 10;\n        const lastTwoDigits = argPosition % 100;\n        if (lastDigit == 1 && lastTwoDigits != 11) {\n            argumentLabel = argPosition + 'st';\n        } else if (lastDigit == 2 && lastTwoDigits != 12) {\n            argumentLabel = argPosition + 'nd';\n        } else if (lastDigit == 3 && lastTwoDigits != 13) {\n            argumentLabel = argPosition + 'rd';\n        } else {\n            argumentLabel = argPosition + 'th';\n        }\n    } else {\n        argumentLabel = `\\`${keyPath[0].toString()}\\``;\n    }\n    const path =\n        keyPath.length > 1\n            ? keyPath\n                  .slice(1)\n                  .map(pathPart => (typeof pathPart === 'number' ? `[${pathPart}]` : pathPart))\n                  .join('.')\n            : undefined;\n    const error = new SolanaError(SOLANA_ERROR__RPC__INTEGER_OVERFLOW, {\n        argumentLabel,\n        keyPath: keyPath as readonly (number | string | symbol)[],\n        methodName,\n        optionalPathLabel: path ? ` at path \\`${path}\\`` : '',\n        value,\n        ...(path !== undefined ? { path } : undefined),\n    });\n    safeCaptureStackTrace(error, createSolanaJsonRpcIntegerOverflowError);\n    return error;\n}\n","import type { createSolanaRpcApi } from '@solana/rpc-api';\n\nimport { createSolanaJsonRpcIntegerOverflowError } from './rpc-integer-overflow-error';\n\nexport const DEFAULT_RPC_CONFIG: Partial<Parameters<typeof createSolanaRpcApi>[0]> = {\n    defaultCommitment: 'confirmed',\n    onIntegerOverflow(methodName, keyPath, value) {\n        throw createSolanaJsonRpcIntegerOverflowError(methodName, keyPath, value);\n    },\n};\n","import { pipe } from '@solana/functional';\nimport { createHttpTransport } from '@solana/rpc-transport-http';\nimport type { ClusterUrl } from '@solana/rpc-types';\n\nimport { RpcTransportFromClusterUrl } from './rpc-clusters';\nimport { getRpcTransportWithRequestCoalescing } from './rpc-request-coalescer';\nimport { getSolanaRpcPayloadDeduplicationKey } from './rpc-request-deduplication';\n\ntype RpcTransportConfig = Parameters<typeof createHttpTransport>[0];\nexport interface DefaultRpcTransportConfig<TClusterUrl extends ClusterUrl> extends RpcTransportConfig {\n    url: TClusterUrl;\n}\n\n/**\n * Lowercasing header names makes it easier to override user-supplied headers.\n */\nfunction normalizeHeaders<T extends Record<string, string>>(\n    headers: T,\n): { [K in string & keyof T as Lowercase<K>]: T[K] } {\n    const out: Record<string, string> = {};\n    for (const headerName in headers) {\n        out[headerName.toLowerCase()] = headers[headerName];\n    }\n    return out as { [K in string & keyof T as Lowercase<K>]: T[K] };\n}\n\nexport function createDefaultRpcTransport<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcTransportConfig<TClusterUrl>,\n): RpcTransportFromClusterUrl<TClusterUrl> {\n    return pipe(\n        createHttpTransport({\n            ...config,\n            headers: {\n                ...(config.headers ? normalizeHeaders(config.headers) : undefined),\n                ...({\n                    // Keep these headers lowercase so they will override any user-supplied headers above.\n                    'solana-client': `js/${__VERSION__}` ?? 'UNKNOWN',\n                } as { [overrideHeader: string]: string }),\n            },\n        }) as RpcTransportFromClusterUrl<TClusterUrl>,\n        transport => getRpcTransportWithRequestCoalescing(transport, getSolanaRpcPayloadDeduplicationKey),\n    );\n}\n","import type { RpcTransport } from '@solana/rpc-spec';\n\ntype CoalescedRequest = {\n    readonly abortController: AbortController;\n    numConsumers: number;\n    readonly responsePromise: Promise<unknown>;\n};\n\ntype GetDeduplicationKeyFn = (payload: unknown) => string | undefined;\n\n// This used to be a `Symbol()`, but there's a bug in Node <21 where the `undici` library passes\n// the `reason` property of the `AbortSignal` straight to `Error.captureStackTrace()` without first\n// typechecking it. `Error.captureStackTrace()` fatals when given a `Symbol`.\n// See https://github.com/nodejs/undici/pull/2597\nconst EXPLICIT_ABORT_TOKEN = __DEV__\n    ? {\n          EXPLICIT_ABORT_TOKEN:\n              'This object is thrown from the request that underlies a series of coalesced ' +\n              'requests when the last request in that series aborts',\n      }\n    : {};\n\nexport function getRpcTransportWithRequestCoalescing<TTransport extends RpcTransport>(\n    transport: TTransport,\n    getDeduplicationKey: GetDeduplicationKeyFn,\n): TTransport {\n    let coalescedRequestsByDeduplicationKey: Record<string, CoalescedRequest> | undefined;\n    return async function makeCoalescedHttpRequest<TResponse>(config: Parameters<RpcTransport>[0]): Promise<TResponse> {\n        const { payload, signal } = config;\n        const deduplicationKey = getDeduplicationKey(payload);\n        if (deduplicationKey === undefined) {\n            return await transport(config);\n        }\n        if (!coalescedRequestsByDeduplicationKey) {\n            Promise.resolve().then(() => {\n                coalescedRequestsByDeduplicationKey = undefined;\n            });\n            coalescedRequestsByDeduplicationKey = {};\n        }\n        if (coalescedRequestsByDeduplicationKey[deduplicationKey] == null) {\n            const abortController = new AbortController();\n            const responsePromise = (async () => {\n                try {\n                    return await transport<TResponse>({\n                        ...config,\n                        signal: abortController.signal,\n                    });\n                } catch (e) {\n                    if (e === EXPLICIT_ABORT_TOKEN) {\n                        // We triggered this error when the last subscriber aborted. Letting this\n                        // error bubble up from here would cause runtime fatals where there should\n                        // be none.\n                        return;\n                    }\n                    throw e;\n                }\n            })();\n            coalescedRequestsByDeduplicationKey[deduplicationKey] = {\n                abortController,\n                numConsumers: 0,\n                responsePromise,\n            };\n        }\n        const coalescedRequest = coalescedRequestsByDeduplicationKey[deduplicationKey];\n        coalescedRequest.numConsumers++;\n        if (signal) {\n            const responsePromise = coalescedRequest.responsePromise as Promise<TResponse>;\n            return await new Promise<TResponse>((resolve, reject) => {\n                const handleAbort = (e: AbortSignalEventMap['abort']) => {\n                    signal.removeEventListener('abort', handleAbort);\n                    coalescedRequest.numConsumers -= 1;\n                    if (coalescedRequest.numConsumers === 0) {\n                        const abortController = coalescedRequest.abortController;\n                        abortController.abort(EXPLICIT_ABORT_TOKEN);\n                    }\n                    reject((e.target as AbortSignal).reason);\n                };\n                signal.addEventListener('abort', handleAbort);\n                responsePromise.then(resolve).finally(() => {\n                    signal.removeEventListener('abort', handleAbort);\n                });\n            });\n        } else {\n            return (await coalescedRequest.responsePromise) as TResponse;\n        }\n    } as TTransport;\n}\n","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nimport fastStableStringify from 'fast-stable-stringify';\n\nfunction isJsonRpcPayload(payload: unknown): payload is Readonly<{ method: string; params: unknown }> {\n    if (payload == null || typeof payload !== 'object' || Array.isArray(payload)) {\n        return false;\n    }\n    return (\n        'jsonrpc' in payload &&\n        payload.jsonrpc === '2.0' &&\n        'method' in payload &&\n        typeof payload.method === 'string' &&\n        'params' in payload\n    );\n}\n\nexport function getSolanaRpcPayloadDeduplicationKey(payload: unknown): string | undefined {\n    return isJsonRpcPayload(payload) ? fastStableStringify([payload.method, payload.params]) : undefined;\n}\n","import {\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID,\n    SolanaError,\n} from '@solana/errors';\nimport { getSolanaErrorFromJsonRpcError } from '@solana/errors';\nimport {\n    Callable,\n    createRpcMessage,\n    Flatten,\n    OverloadImplementations,\n    RpcResponse,\n    UnionToIntersection,\n} from '@solana/rpc-spec-types';\n\nimport { RpcSubscriptionsApi } from './rpc-subscriptions-api';\nimport {\n    PendingRpcSubscriptionsRequest,\n    RpcSubscribeOptions,\n    RpcSubscriptionsRequest,\n} from './rpc-subscriptions-request';\nimport { RpcSubscriptionsTransport } from './rpc-subscriptions-transport';\n\nexport type RpcSubscriptionsConfig<\n    TRpcMethods,\n    TRpcSubscriptionsTransport extends RpcSubscriptionsTransport,\n> = Readonly<{\n    api: RpcSubscriptionsApi<TRpcMethods>;\n    transport: TRpcSubscriptionsTransport;\n}>;\n\nexport type RpcSubscriptions<TRpcSubscriptionsMethods> = {\n    [TMethodName in keyof TRpcSubscriptionsMethods]: PendingRpcSubscriptionsRequestBuilder<\n        OverloadImplementations<TRpcSubscriptionsMethods, TMethodName>\n    >;\n};\n\ntype PendingRpcSubscriptionsRequestBuilder<TSubscriptionMethodImplementations> = UnionToIntersection<\n    Flatten<{\n        [P in keyof TSubscriptionMethodImplementations]: PendingRpcSubscriptionsRequestReturnTypeMapper<\n            TSubscriptionMethodImplementations[P]\n        >;\n    }>\n>;\n\ntype PendingRpcSubscriptionsRequestReturnTypeMapper<TSubscriptionMethodImplementation> =\n    // Check that this property of the TRpcSubscriptionMethods interface is, in fact, a function.\n    TSubscriptionMethodImplementation extends Callable\n        ? (\n              ...args: Parameters<TSubscriptionMethodImplementation>\n          ) => PendingRpcSubscriptionsRequest<ReturnType<TSubscriptionMethodImplementation>>\n        : never;\n\ntype RpcNotification<TNotification> = Readonly<{\n    params: Readonly<{\n        result: TNotification;\n        subscription: number;\n    }>;\n}>;\n\ntype RpcSubscriptionId = number;\n\nexport function createSubscriptionRpc<\n    TRpcSubscriptionsApiMethods,\n    TRpcSubscriptionsTransport extends RpcSubscriptionsTransport,\n>(\n    rpcConfig: RpcSubscriptionsConfig<TRpcSubscriptionsApiMethods, TRpcSubscriptionsTransport>,\n): RpcSubscriptions<TRpcSubscriptionsApiMethods> {\n    return makeProxy(rpcConfig);\n}\n\nfunction makeProxy<TRpcSubscriptionsApiMethods, TRpcSubscriptionsTransport extends RpcSubscriptionsTransport>(\n    rpcConfig: RpcSubscriptionsConfig<TRpcSubscriptionsApiMethods, TRpcSubscriptionsTransport>,\n): RpcSubscriptions<TRpcSubscriptionsApiMethods> {\n    return new Proxy(rpcConfig.api, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get(target, p, receiver) {\n            return function (...rawParams: unknown[]) {\n                const notificationName = p.toString();\n                const createRpcSubscription = Reflect.get(target, notificationName, receiver);\n                if (p.toString().endsWith('Notifications') === false && !createRpcSubscription) {\n                    throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST, {\n                        notificationName,\n                    });\n                }\n                const newRequest = createRpcSubscription\n                    ? createRpcSubscription(...rawParams)\n                    : {\n                          params: rawParams,\n                          subscribeMethodName: notificationName.replace(/Notifications$/, 'Subscribe'),\n                          unsubscribeMethodName: notificationName.replace(/Notifications$/, 'Unsubscribe'),\n                      };\n                return createPendingRpcSubscription(rpcConfig, newRequest);\n            };\n        },\n    }) as RpcSubscriptions<TRpcSubscriptionsApiMethods>;\n}\n\nfunction registerIterableCleanup(iterable: AsyncIterable<unknown>, cleanupFn: CallableFunction) {\n    (async () => {\n        try {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            for await (const _ of iterable);\n        } catch {\n            /* empty */\n        } finally {\n            // Run the cleanup function.\n            cleanupFn();\n        }\n    })();\n}\n\nfunction createPendingRpcSubscription<\n    TRpcSubscriptionsApiMethods,\n    TRpcSubscriptionsTransport extends RpcSubscriptionsTransport,\n    TNotification,\n>(\n    rpcConfig: RpcSubscriptionsConfig<TRpcSubscriptionsApiMethods, TRpcSubscriptionsTransport>,\n    { params, subscribeMethodName, unsubscribeMethodName, responseTransformer }: RpcSubscriptionsRequest<TNotification>,\n): PendingRpcSubscriptionsRequest<TNotification> {\n    return {\n        async subscribe({ abortSignal }: RpcSubscribeOptions): Promise<AsyncIterable<TNotification>> {\n            abortSignal.throwIfAborted();\n            let subscriptionId: number | undefined;\n            function handleCleanup() {\n                if (subscriptionId !== undefined) {\n                    const payload = createRpcMessage(unsubscribeMethodName, [subscriptionId]);\n                    connection.send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(payload).finally(() => {\n                        connectionAbortController.abort();\n                    });\n                } else {\n                    connectionAbortController.abort();\n                }\n            }\n            abortSignal.addEventListener('abort', handleCleanup);\n            /**\n             * STEP 1: Send the subscribe message.\n             */\n            const connectionAbortController = new AbortController();\n            const subscribeMessage = createRpcMessage(subscribeMethodName, params);\n            const connection = await rpcConfig.transport({\n                payload: subscribeMessage,\n                signal: connectionAbortController.signal,\n            });\n            function handleConnectionCleanup() {\n                abortSignal.removeEventListener('abort', handleCleanup);\n            }\n            registerIterableCleanup(connection, handleConnectionCleanup);\n            /**\n             * STEP 2: Wait for the acknowledgement from the server with the subscription id.\n             */\n            for await (const message of connection as AsyncIterable<\n                RpcNotification<unknown> | RpcResponse<RpcSubscriptionId>\n            >) {\n                if ('id' in message && message.id === subscribeMessage.id) {\n                    if ('error' in message) {\n                        throw getSolanaErrorFromJsonRpcError(message.error);\n                    } else {\n                        subscriptionId = message.result as RpcSubscriptionId;\n                        break;\n                    }\n                }\n            }\n            if (subscriptionId == null) {\n                throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID);\n            }\n            /**\n             * STEP 3: Return an iterable that yields notifications for this subscription id.\n             */\n            return {\n                async *[Symbol.asyncIterator]() {\n                    for await (const message of connection as AsyncIterable<\n                        RpcNotification<unknown> | RpcResponse<RpcSubscriptionId>\n                    >) {\n                        if (!('params' in message) || message.params.subscription !== subscriptionId) {\n                            continue;\n                        }\n                        const notification = message.params.result as TNotification;\n                        yield responseTransformer\n                            ? responseTransformer(notification, subscribeMethodName)\n                            : notification;\n                    }\n                },\n            };\n        },\n    };\n}\n","import { Callable } from '@solana/rpc-spec-types';\n\nimport { RpcSubscriptionsRequest } from './rpc-subscriptions-request';\n\nexport type RpcSubscriptionsApiConfig = Readonly<{\n    parametersTransformer?: <T extends unknown[]>(params: T, notificationName: string) => unknown[];\n    responseTransformer?: <T>(response: unknown, notificationName: string) => T;\n    subscribeNotificationNameTransformer?: (notificationName: string) => string;\n    unsubscribeNotificationNameTransformer?: (notificationName: string) => string;\n}>;\n\nexport type RpcSubscriptionsApi<TRpcSubscriptionMethods> = {\n    [MethodName in keyof TRpcSubscriptionMethods]: RpcSubscriptionsReturnTypeMapper<\n        TRpcSubscriptionMethods[MethodName]\n    >;\n};\n\ntype RpcSubscriptionsReturnTypeMapper<TRpcMethod> = TRpcMethod extends Callable\n    ? (...rawParams: unknown[]) => RpcSubscriptionsRequest<ReturnType<TRpcMethod>>\n    : never;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RpcSubscriptionsApiMethod = (...args: any) => any;\nexport interface RpcSubscriptionsApiMethods {\n    [methodName: string]: RpcSubscriptionsApiMethod;\n}\n\nexport function createRpcSubscriptionsApi<TRpcSubscriptionsApiMethods extends RpcSubscriptionsApiMethods>(\n    config?: RpcSubscriptionsApiConfig,\n): RpcSubscriptionsApi<TRpcSubscriptionsApiMethods> {\n    return new Proxy({} as RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get<TNotificationName extends keyof RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>>(\n            ...args: Parameters<NonNullable<ProxyHandler<RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>>['get']>>\n        ) {\n            const [_, p] = args;\n            const notificationName = p.toString() as keyof TRpcSubscriptionsApiMethods as string;\n            return function (\n                ...rawParams: Parameters<\n                    TRpcSubscriptionsApiMethods[TNotificationName] extends CallableFunction\n                        ? TRpcSubscriptionsApiMethods[TNotificationName]\n                        : never\n                >\n            ): RpcSubscriptionsRequest<ReturnType<TRpcSubscriptionsApiMethods[TNotificationName]>> {\n                const params = config?.parametersTransformer\n                    ? config?.parametersTransformer(rawParams, notificationName)\n                    : rawParams;\n                const responseTransformer = config?.responseTransformer\n                    ? config?.responseTransformer<ReturnType<TRpcSubscriptionsApiMethods[TNotificationName]>>\n                    : (rawResponse: unknown) =>\n                          rawResponse as ReturnType<TRpcSubscriptionsApiMethods[TNotificationName]>;\n                const subscribeMethodName = config?.subscribeNotificationNameTransformer\n                    ? config?.subscribeNotificationNameTransformer(notificationName)\n                    : notificationName;\n                const unsubscribeMethodName = config?.unsubscribeNotificationNameTransformer\n                    ? config?.unsubscribeNotificationNameTransformer(notificationName)\n                    : notificationName;\n                return {\n                    params,\n                    responseTransformer,\n                    subscribeMethodName,\n                    unsubscribeMethodName,\n                };\n            };\n        },\n    });\n}\n","import {\n    createRpcSubscriptionsApi,\n    RpcSubscriptionsApi,\n    RpcSubscriptionsApiMethods,\n} from '@solana/rpc-subscriptions-spec';\nimport {\n    AllowedNumericKeypaths,\n    getDefaultParamsTransformerForSolanaRpc,\n    getDefaultResponseTransformerForSolanaRpc,\n    jsonParsedAccountsConfigs,\n    KEYPATH_WILDCARD,\n    ParamsTransformerConfig,\n} from '@solana/rpc-transformers';\n\nimport { AccountNotificationsApi } from './account-notifications';\nimport { BlockNotificationsApi } from './block-notifications';\nimport { LogsNotificationsApi } from './logs-notifications';\nimport { ProgramNotificationsApi } from './program-notifications';\nimport { RootNotificationsApi } from './root-notifications';\nimport { SignatureNotificationsApi } from './signature-notifications';\nimport { SlotNotificationsApi } from './slot-notifications';\nimport { SlotsUpdatesNotificationsApi } from './slots-updates-notifications';\nimport { VoteNotificationsApi } from './vote-notifications';\n\nexport type SolanaRpcSubscriptionsApi = AccountNotificationsApi &\n    LogsNotificationsApi &\n    ProgramNotificationsApi &\n    RootNotificationsApi &\n    SignatureNotificationsApi &\n    SlotNotificationsApi;\nexport type SolanaRpcSubscriptionsApiUnstable = BlockNotificationsApi &\n    SlotsUpdatesNotificationsApi &\n    VoteNotificationsApi;\n\nexport type {\n    AccountNotificationsApi,\n    BlockNotificationsApi,\n    LogsNotificationsApi,\n    ProgramNotificationsApi,\n    RootNotificationsApi,\n    SignatureNotificationsApi,\n    SlotNotificationsApi,\n    SlotsUpdatesNotificationsApi,\n    VoteNotificationsApi,\n};\n\ntype Config = ParamsTransformerConfig;\n\nfunction createSolanaRpcSubscriptionsApi_INTERNAL<TApi extends RpcSubscriptionsApiMethods>(\n    config?: Config,\n): RpcSubscriptionsApi<TApi> {\n    return createRpcSubscriptionsApi<TApi>({\n        parametersTransformer: getDefaultParamsTransformerForSolanaRpc(config) as (params: unknown[]) => unknown[],\n        responseTransformer: getDefaultResponseTransformerForSolanaRpc({\n            allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n        }),\n        subscribeNotificationNameTransformer: (notificationName: string) =>\n            notificationName.replace(/Notifications$/, 'Subscribe'),\n        unsubscribeNotificationNameTransformer: (notificationName: string) =>\n            notificationName.replace(/Notifications$/, 'Unsubscribe'),\n    });\n}\n\nexport function createSolanaRpcSubscriptionsApi<TApi extends RpcSubscriptionsApiMethods = SolanaRpcSubscriptionsApi>(\n    config?: Config,\n): RpcSubscriptionsApi<TApi> {\n    return createSolanaRpcSubscriptionsApi_INTERNAL<TApi>(config);\n}\n\nexport function createSolanaRpcSubscriptionsApi_UNSTABLE(config?: Config) {\n    return createSolanaRpcSubscriptionsApi_INTERNAL<SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>(\n        config,\n    );\n}\n\nlet memoizedKeypaths: AllowedNumericKeypaths<\n    RpcSubscriptionsApi<SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>\n>;\n\n/**\n * These are keypaths at the end of which you will find a numeric value that should *not* be upcast\n * to a `bigint`. These are values that are legitimately defined as `u8` or `usize` on the backend.\n */\nfunction getAllowedNumericKeypaths(): AllowedNumericKeypaths<\n    RpcSubscriptionsApi<SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>\n> {\n    if (!memoizedKeypaths) {\n        memoizedKeypaths = {\n            accountNotifications: jsonParsedAccountsConfigs.map(c => ['value', ...c]),\n            blockNotifications: [\n                ['value', 'block', 'blockTime'],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'preTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'accountIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'preTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'postTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'accountIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'postTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                ['value', 'block', 'transactions', KEYPATH_WILDCARD, 'meta', 'rewards', KEYPATH_WILDCARD, 'commission'],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    'index',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'programIdIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'accounts',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'addressTableLookups',\n                    KEYPATH_WILDCARD,\n                    'writableIndexes',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'addressTableLookups',\n                    KEYPATH_WILDCARD,\n                    'readonlyIndexes',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'programIdIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'accounts',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'header',\n                    'numReadonlySignedAccounts',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'header',\n                    'numReadonlyUnsignedAccounts',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'header',\n                    'numRequiredSignatures',\n                ],\n                ['value', 'block', 'rewards', KEYPATH_WILDCARD, 'commission'],\n            ],\n            programNotifications: jsonParsedAccountsConfigs.flatMap(c => [\n                ['value', KEYPATH_WILDCARD, 'account', ...c],\n                [KEYPATH_WILDCARD, 'account', ...c],\n            ]),\n        };\n    }\n    return memoizedKeypaths;\n}\n","export * from '@solana/rpc-subscriptions-api';\nexport * from '@solana/rpc-subscriptions-spec';\n\nexport * from './rpc-subscriptions';\nexport * from './rpc-subscriptions-clusters';\nexport * from './rpc-subscriptions-transport';\n","import {\n    SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT,\n    SolanaError,\n} from '@solana/errors';\nimport WebSocket from '@solana/ws-impl';\n\ntype Config = Readonly<{\n    sendBufferHighWatermark: number;\n    signal: AbortSignal;\n    url: string;\n}>;\ntype IteratorKey = symbol;\ntype IteratorState =\n    | {\n          __hasPolled: false;\n          queuedMessages: unknown[];\n      }\n    | {\n          __hasPolled: true;\n          onError: Parameters<ConstructorParameters<typeof Promise>[0]>[1];\n          onMessage: Parameters<ConstructorParameters<typeof Promise>[0]>[0];\n      };\nexport type RpcWebSocketConnection = Readonly<{\n    send(payload: unknown): Promise<void>;\n    [Symbol.asyncIterator](): AsyncGenerator<unknown>;\n}>;\n\nconst EXPLICIT_ABORT_TOKEN = Symbol(\n    __DEV__\n        ? \"This symbol is thrown from a socket's iterator when the connection is explicitly aborted by the user\"\n        : undefined,\n);\n\nexport async function createWebSocketConnection({\n    sendBufferHighWatermark,\n    signal,\n    url,\n}: Config): Promise<RpcWebSocketConnection> {\n    return new Promise((resolve, reject) => {\n        signal.addEventListener('abort', handleAbort, { once: true });\n        const iteratorState: Map<IteratorKey, IteratorState> = new Map();\n        function errorAndClearAllIteratorStates(reason: unknown) {\n            const errorCallbacks = [...iteratorState.values()]\n                .filter((state): state is Extract<IteratorState, { __hasPolled: true }> => state.__hasPolled)\n                .map(({ onError }) => onError);\n            iteratorState.clear();\n            errorCallbacks.forEach(cb => {\n                try {\n                    cb(reason);\n                } catch {\n                    /* empty */\n                }\n            });\n        }\n        function handleAbort() {\n            errorAndClearAllIteratorStates(EXPLICIT_ABORT_TOKEN);\n            if (webSocket.readyState !== WebSocket.CLOSED && webSocket.readyState !== WebSocket.CLOSING) {\n                webSocket.close(1000);\n            }\n        }\n        function handleClose(ev: CloseEvent) {\n            bufferDrainWatcher?.onCancel();\n            signal.removeEventListener('abort', handleAbort);\n            webSocket.removeEventListener('close', handleClose);\n            webSocket.removeEventListener('error', handleError);\n            webSocket.removeEventListener('open', handleOpen);\n            webSocket.removeEventListener('message', handleMessage);\n            errorAndClearAllIteratorStates(ev);\n        }\n        function handleError(ev: Event) {\n            if (!hasConnected) {\n                reject(\n                    new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT, {\n                        errorEvent: ev,\n                    }),\n                );\n            }\n        }\n        let hasConnected = false;\n        let bufferDrainWatcher: Readonly<{ onCancel(): void; promise: Promise<void> }> | undefined;\n        function handleOpen() {\n            hasConnected = true;\n            resolve({\n                async send(payload: unknown) {\n                    const message = JSON.stringify(payload);\n                    if (\n                        !bufferDrainWatcher &&\n                        webSocket.readyState === WebSocket.OPEN &&\n                        webSocket.bufferedAmount > sendBufferHighWatermark\n                    ) {\n                        let onCancel: () => void;\n                        const promise = new Promise<void>((resolve, reject) => {\n                            const intervalId = setInterval(() => {\n                                if (\n                                    webSocket.readyState !== WebSocket.OPEN ||\n                                    !(webSocket.bufferedAmount > sendBufferHighWatermark)\n                                ) {\n                                    clearInterval(intervalId);\n                                    bufferDrainWatcher = undefined;\n                                    resolve();\n                                }\n                            }, 16);\n                            onCancel = () => {\n                                bufferDrainWatcher = undefined;\n                                clearInterval(intervalId);\n                                reject(\n                                    new SolanaError(\n                                        SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED,\n                                    ),\n                                );\n                            };\n                        });\n                        bufferDrainWatcher = {\n                            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                            // @ts-ignore\n                            onCancel,\n                            promise,\n                        };\n                    }\n                    if (bufferDrainWatcher) {\n                        await bufferDrainWatcher.promise;\n                    }\n                    webSocket.send(message);\n                },\n                async *[Symbol.asyncIterator]() {\n                    const iteratorKey = Symbol();\n                    iteratorState.set(iteratorKey, { __hasPolled: false, queuedMessages: [] });\n                    try {\n                        while (true) {\n                            const state = iteratorState.get(iteratorKey);\n                            if (!state) {\n                                // There should always be state by now.\n                                throw new SolanaError(\n                                    SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING,\n                                );\n                            }\n                            if (state.__hasPolled) {\n                                // You should never be able to poll twice in a row.\n                                throw new SolanaError(\n                                    SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n                                );\n                            }\n                            const queuedMessages = state.queuedMessages;\n                            if (queuedMessages.length) {\n                                state.queuedMessages = [];\n                                yield* queuedMessages;\n                            } else {\n                                try {\n                                    yield await new Promise((resolve, reject) => {\n                                        iteratorState.set(iteratorKey, {\n                                            __hasPolled: true,\n                                            onError: reject,\n                                            onMessage: resolve,\n                                        });\n                                    });\n                                } catch (e) {\n                                    if (e === EXPLICIT_ABORT_TOKEN) {\n                                        return;\n                                    } else {\n                                        throw new SolanaError(\n                                            SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED,\n                                            {\n                                                cause: e,\n                                            },\n                                        );\n                                    }\n                                }\n                            }\n                        }\n                    } finally {\n                        iteratorState.delete(iteratorKey);\n                    }\n                },\n            });\n        }\n        function handleMessage({ data }: MessageEvent) {\n            const message = JSON.parse(data);\n            iteratorState.forEach((state, iteratorKey) => {\n                if (state.__hasPolled) {\n                    const { onMessage } = state;\n                    iteratorState.set(iteratorKey, { __hasPolled: false, queuedMessages: [] });\n                    onMessage(message);\n                } else {\n                    state.queuedMessages.push(message);\n                }\n            });\n        }\n        const webSocket = new WebSocket(url);\n        webSocket.addEventListener('close', handleClose);\n        webSocket.addEventListener('error', handleError);\n        webSocket.addEventListener('open', handleOpen);\n        webSocket.addEventListener('message', handleMessage);\n    });\n}\n","export default globalThis.WebSocket;\n","import { RpcSubscriptionsTransport } from '@solana/rpc-subscriptions-spec';\n\nimport { createWebSocketConnection } from './websocket-connection';\n\ntype Config = Readonly<{\n    sendBufferHighWatermark: number;\n    url: string;\n}>;\n\nexport function createWebSocketTransport({ sendBufferHighWatermark, url }: Config): RpcSubscriptionsTransport {\n    if (/^wss?:/i.test(url) === false) {\n        const protocolMatch = url.match(/^([^:]+):/);\n        throw new DOMException(\n            protocolMatch\n                ? `Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or 'wss'. '${protocolMatch[1]}:' is not allowed.`\n                : `Failed to construct 'WebSocket': The URL '${url}' is invalid.`,\n        );\n    }\n    return async function sendWebSocketMessage({ payload, signal }: Parameters<RpcSubscriptionsTransport>[0]) {\n        signal?.throwIfAborted();\n        const connection = await createWebSocketConnection({\n            sendBufferHighWatermark,\n            signal,\n            url,\n        });\n        signal?.throwIfAborted();\n        await connection.send(payload);\n        return {\n            [Symbol.asyncIterator]: connection[Symbol.asyncIterator].bind(connection),\n            send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: connection.send.bind(connection),\n        };\n    };\n}\n","import { pipe } from '@solana/functional';\nimport type { SolanaRpcSubscriptionsApi, SolanaRpcSubscriptionsApiUnstable } from '@solana/rpc-subscriptions-api';\nimport { createSolanaRpcSubscriptionsApi } from '@solana/rpc-subscriptions-api';\nimport {\n    createSubscriptionRpc,\n    RpcSubscriptionsApiMethods,\n    type RpcSubscriptionsTransport,\n} from '@solana/rpc-subscriptions-spec';\nimport { ClusterUrl } from '@solana/rpc-types';\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nimport fastStableStringify from 'fast-stable-stringify';\n\nimport { DEFAULT_RPC_CONFIG } from './rpc-default-config';\nimport type { RpcSubscriptionsFromTransport } from './rpc-subscriptions-clusters';\nimport { getRpcSubscriptionsWithSubscriptionCoalescing } from './rpc-subscriptions-coalescer';\nimport {\n    createDefaultRpcSubscriptionsTransport,\n    DefaultRpcSubscriptionsTransportConfig,\n} from './rpc-subscriptions-transport';\n\nexport function createSolanaRpcSubscriptions<\n    TClusterUrl extends ClusterUrl,\n    TApi extends RpcSubscriptionsApiMethods = SolanaRpcSubscriptionsApi,\n>(clusterUrl: TClusterUrl, config?: Omit<DefaultRpcSubscriptionsTransportConfig<TClusterUrl>, 'url'>) {\n    const transport = createDefaultRpcSubscriptionsTransport({ url: clusterUrl, ...config });\n    return createSolanaRpcSubscriptionsFromTransport<typeof transport, TApi>(transport);\n}\n\nexport function createSolanaRpcSubscriptions_UNSTABLE<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<DefaultRpcSubscriptionsTransportConfig<TClusterUrl>, 'url'>,\n) {\n    return createSolanaRpcSubscriptions<TClusterUrl, SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>(\n        clusterUrl,\n        config,\n    );\n}\n\nexport function createSolanaRpcSubscriptionsFromTransport<\n    TTransport extends RpcSubscriptionsTransport,\n    TApi extends RpcSubscriptionsApiMethods = SolanaRpcSubscriptionsApi,\n>(transport: TTransport) {\n    return pipe(\n        createSubscriptionRpc({\n            api: createSolanaRpcSubscriptionsApi<TApi>(DEFAULT_RPC_CONFIG),\n            transport,\n        }),\n        rpcSubscriptions =>\n            getRpcSubscriptionsWithSubscriptionCoalescing({\n                getDeduplicationKey: (...args) => fastStableStringify(args),\n                rpcSubscriptions,\n            }),\n    ) as RpcSubscriptionsFromTransport<TApi, TTransport>;\n}\n\nexport function createSolanaRpcSubscriptionsFromTransport_UNSTABLE<TTransport extends RpcSubscriptionsTransport>(\n    transport: TTransport,\n) {\n    return createSolanaRpcSubscriptionsFromTransport<\n        TTransport,\n        SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable\n    >(transport);\n}\n","import { safeCaptureStackTrace, SOLANA_ERROR__RPC__INTEGER_OVERFLOW, SolanaError } from '@solana/errors';\nimport type { KeyPath } from '@solana/rpc-transformers';\n\nexport function createSolanaJsonRpcIntegerOverflowError(\n    methodName: string,\n    keyPath: KeyPath,\n    value: bigint,\n): SolanaError<typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW> {\n    let argumentLabel = '';\n    if (typeof keyPath[0] === 'number') {\n        const argPosition = keyPath[0] + 1;\n        const lastDigit = argPosition % 10;\n        const lastTwoDigits = argPosition % 100;\n        if (lastDigit == 1 && lastTwoDigits != 11) {\n            argumentLabel = argPosition + 'st';\n        } else if (lastDigit == 2 && lastTwoDigits != 12) {\n            argumentLabel = argPosition + 'nd';\n        } else if (lastDigit == 3 && lastTwoDigits != 13) {\n            argumentLabel = argPosition + 'rd';\n        } else {\n            argumentLabel = argPosition + 'th';\n        }\n    } else {\n        argumentLabel = `\\`${keyPath[0].toString()}\\``;\n    }\n    const path =\n        keyPath.length > 1\n            ? keyPath\n                  .slice(1)\n                  .map(pathPart => (typeof pathPart === 'number' ? `[${pathPart}]` : pathPart))\n                  .join('.')\n            : undefined;\n    const error = new SolanaError(SOLANA_ERROR__RPC__INTEGER_OVERFLOW, {\n        argumentLabel,\n        keyPath: keyPath as readonly (number | string | symbol)[],\n        methodName,\n        optionalPathLabel: path ? ` at path \\`${path}\\`` : '',\n        value,\n        ...(path !== undefined ? { path } : undefined),\n    });\n    safeCaptureStackTrace(error, createSolanaJsonRpcIntegerOverflowError);\n    return error;\n}\n","import type { createSolanaRpcSubscriptionsApi } from '@solana/rpc-subscriptions-api';\n\nimport { createSolanaJsonRpcIntegerOverflowError } from './rpc-integer-overflow-error';\n\nexport const DEFAULT_RPC_CONFIG: Partial<Parameters<typeof createSolanaRpcSubscriptionsApi>[0]> = {\n    defaultCommitment: 'confirmed',\n    onIntegerOverflow(methodName, keyPath, value) {\n        throw createSolanaJsonRpcIntegerOverflowError(methodName, keyPath, value);\n    },\n};\n","import {\n    SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING,\n    SolanaError,\n} from '@solana/errors';\n\ntype CacheEntry<TIterable extends AsyncIterable<unknown>> = {\n    abortController: AbortController;\n    iterable: Promise<TIterable> | TIterable;\n    purgeScheduled: boolean;\n    referenceCount: number;\n};\ntype CacheKey = string | symbol;\ntype Config<TInput extends unknown[], TIterable extends AsyncIterable<unknown>> = Readonly<{\n    getAbortSignalFromInputArgs: (...args: TInput) => AbortSignal;\n    getCacheKeyFromInputArgs: (...args: TInput) =>\n        | CacheKey\n        // `undefined` implies 'do not cache'\n        | undefined;\n    onCacheHit: (iterable: TIterable, ...args: TInput) => Promise<void>;\n    onCreateIterable: (abortSignal: AbortSignal, ...args: TInput) => Promise<TIterable>;\n}>;\n\nfunction registerIterableCleanup(iterable: AsyncIterable<unknown>, cleanupFn: CallableFunction) {\n    (async () => {\n        try {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            for await (const _ of iterable);\n        } catch {\n            /* empty */\n        } finally {\n            // Run the cleanup function.\n            cleanupFn();\n        }\n    })();\n}\n\nexport function getCachedAbortableIterableFactory<TInput extends unknown[], TIterable extends AsyncIterable<unknown>>({\n    getAbortSignalFromInputArgs,\n    getCacheKeyFromInputArgs,\n    onCacheHit,\n    onCreateIterable,\n}: Config<TInput, TIterable>): (...args: TInput) => Promise<TIterable> {\n    const cache = new Map<CacheKey, CacheEntry<TIterable>>();\n    function getCacheEntryOrThrow(cacheKey: CacheKey) {\n        const currentCacheEntry = cache.get(cacheKey);\n        if (!currentCacheEntry) {\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING, {\n                cacheKey: cacheKey.toString(),\n            });\n        }\n        return currentCacheEntry;\n    }\n    return async (...args: TInput) => {\n        const cacheKey = getCacheKeyFromInputArgs(...args);\n        const signal = getAbortSignalFromInputArgs(...args);\n        if (cacheKey === undefined) {\n            return await onCreateIterable(signal, ...args);\n        }\n        const cleanup = () => {\n            cache.delete(cacheKey);\n            signal.removeEventListener('abort', handleAbort);\n        };\n        const handleAbort = () => {\n            const cacheEntry = getCacheEntryOrThrow(cacheKey);\n            if (cacheEntry.purgeScheduled !== true) {\n                cacheEntry.purgeScheduled = true;\n                globalThis.queueMicrotask(() => {\n                    cacheEntry.purgeScheduled = false;\n                    if (cacheEntry.referenceCount === 0) {\n                        cacheEntry.abortController.abort();\n                        cleanup();\n                    }\n                });\n            }\n            cacheEntry.referenceCount--;\n        };\n        signal.addEventListener('abort', handleAbort);\n        try {\n            const cacheEntry = cache.get(cacheKey);\n            if (!cacheEntry) {\n                const singletonAbortController = new AbortController();\n                const newIterablePromise = onCreateIterable(singletonAbortController.signal, ...args);\n                const newCacheEntry: CacheEntry<TIterable> = {\n                    abortController: singletonAbortController,\n                    iterable: newIterablePromise,\n                    purgeScheduled: false,\n                    referenceCount: 1,\n                };\n                cache.set(cacheKey, newCacheEntry);\n                const newIterable = await newIterablePromise;\n                registerIterableCleanup(newIterable, cleanup);\n                newCacheEntry.iterable = newIterable;\n                return newIterable;\n            } else {\n                cacheEntry.referenceCount++;\n                const iterableOrIterablePromise = cacheEntry.iterable;\n                const cachedIterable =\n                    'then' in iterableOrIterablePromise ? await iterableOrIterablePromise : iterableOrIterablePromise;\n                await onCacheHit(cachedIterable, ...args);\n                return cachedIterable;\n            }\n        } catch (e) {\n            cleanup();\n            throw e;\n        }\n    };\n}\n","import { PendingRpcSubscriptionsRequest, RpcSubscriptions } from '@solana/rpc-subscriptions-spec';\n\nimport { getCachedAbortableIterableFactory } from './cached-abortable-iterable';\n\ntype CacheKey = string | undefined;\ntype Config<TRpcSubscriptionsMethods> = Readonly<{\n    getDeduplicationKey: GetDeduplicationKeyFn;\n    rpcSubscriptions: RpcSubscriptions<TRpcSubscriptionsMethods>;\n}>;\ntype GetDeduplicationKeyFn = (subscriptionMethod: string | symbol, payload: unknown) => CacheKey;\n\nconst EXPLICIT_ABORT_TOKEN = Symbol(\n    __DEV__\n        ? \"This symbol is thrown from a subscription's iterator when the subscription is \" +\n              'explicitly aborted by the user'\n        : undefined,\n);\n\nfunction registerIterableCleanup(iterable: AsyncIterable<unknown>, cleanupFn: CallableFunction) {\n    (async () => {\n        try {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            for await (const _ of iterable);\n        } catch {\n            /* empty */\n        } finally {\n            // Run the cleanup function.\n            cleanupFn();\n        }\n    })();\n}\n\nexport function getRpcSubscriptionsWithSubscriptionCoalescing<TRpcSubscriptionsMethods>({\n    getDeduplicationKey,\n    rpcSubscriptions,\n}: Config<TRpcSubscriptionsMethods>): RpcSubscriptions<TRpcSubscriptionsMethods> {\n    const cache = new Map<CacheKey, PendingRpcSubscriptionsRequest<unknown>>();\n    return new Proxy(rpcSubscriptions, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get(target, p, receiver) {\n            const subscriptionMethod = Reflect.get(target, p, receiver);\n            if (typeof subscriptionMethod !== 'function') {\n                return subscriptionMethod;\n            }\n            return function (...rawParams: unknown[]) {\n                const deduplicationKey = getDeduplicationKey(p, rawParams);\n                if (deduplicationKey === undefined) {\n                    return (subscriptionMethod as CallableFunction)(...rawParams);\n                }\n                if (cache.has(deduplicationKey)) {\n                    return cache.get(deduplicationKey)!;\n                }\n                const iterableFactory = getCachedAbortableIterableFactory<\n                    Parameters<PendingRpcSubscriptionsRequest<unknown>['subscribe']>,\n                    AsyncIterable<unknown>\n                >({\n                    getAbortSignalFromInputArgs: ({ abortSignal }) => abortSignal,\n                    getCacheKeyFromInputArgs: () => deduplicationKey,\n                    async onCacheHit(_iterable, _config) {\n                        /**\n                         * This transport's goal is to prevent duplicate subscriptions from\n                         * being made. If a cached iterable] is found, do not send the subscribe\n                         * message again.\n                         */\n                    },\n                    async onCreateIterable(abortSignal, config) {\n                        const pendingSubscription = (subscriptionMethod as CallableFunction)(\n                            ...rawParams,\n                        ) as PendingRpcSubscriptionsRequest<unknown>;\n                        const iterable = await pendingSubscription.subscribe({\n                            ...config,\n                            abortSignal,\n                        });\n                        registerIterableCleanup(iterable, () => {\n                            cache.delete(deduplicationKey);\n                        });\n                        return iterable;\n                    },\n                });\n                const pendingSubscription: PendingRpcSubscriptionsRequest<unknown> = {\n                    async subscribe(...args) {\n                        const iterable = await iterableFactory(...args);\n                        const { abortSignal } = args[0];\n                        let abortPromise;\n                        return {\n                            ...iterable,\n                            async *[Symbol.asyncIterator]() {\n                                abortPromise ||= abortSignal.aborted\n                                    ? Promise.reject(EXPLICIT_ABORT_TOKEN)\n                                    : new Promise<never>((_, reject) => {\n                                          abortSignal.addEventListener('abort', () => {\n                                              reject(EXPLICIT_ABORT_TOKEN);\n                                          });\n                                      });\n                                try {\n                                    const iterator = iterable[Symbol.asyncIterator]();\n                                    while (true) {\n                                        const iteratorResult = await Promise.race([iterator.next(), abortPromise]);\n                                        if (iteratorResult.done) {\n                                            return;\n                                        } else {\n                                            yield iteratorResult.value;\n                                        }\n                                    }\n                                } catch (e) {\n                                    if (e === EXPLICIT_ABORT_TOKEN) {\n                                        return;\n                                    }\n                                    cache.delete(deduplicationKey);\n                                    throw e;\n                                }\n                            },\n                        };\n                    },\n                };\n                cache.set(deduplicationKey, pendingSubscription);\n                return pendingSubscription;\n            };\n        },\n    });\n}\n","import { pipe } from '@solana/functional';\nimport { createWebSocketTransport } from '@solana/rpc-subscriptions-transport-websocket';\nimport type { ClusterUrl } from '@solana/rpc-types';\n\nimport { getWebSocketTransportWithAutoping } from './rpc-subscriptions-autopinger';\nimport { RpcSubscriptionsTransportFromClusterUrl } from './rpc-subscriptions-clusters';\nimport { getWebSocketTransportWithConnectionSharding } from './rpc-subscriptions-connection-sharding';\n\nexport type DefaultRpcSubscriptionsTransportConfig<TClusterUrl extends ClusterUrl> = Readonly<{\n    /**\n     * You might like to open more subscriptions per connection than your RPC provider allows\n     * for. Using the initial payload as input, return a shard key from this method to assign\n     * subscriptions to separate connections. One socket will be opened per shard key.\n     */\n    getShard?: (payload: unknown) => string;\n    intervalMs?: number;\n    sendBufferHighWatermark?: number;\n    url: TClusterUrl;\n}>;\n\nexport function createDefaultRpcSubscriptionsTransport<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcSubscriptionsTransportConfig<TClusterUrl>,\n): RpcSubscriptionsTransportFromClusterUrl<TClusterUrl> {\n    const { getShard, intervalMs, ...rest } = config;\n    return pipe(\n        createWebSocketTransport({\n            ...rest,\n            sendBufferHighWatermark:\n                config.sendBufferHighWatermark ??\n                // Let 128KB of data into the WebSocket buffer before buffering it in the app.\n                131_072,\n        }) as RpcSubscriptionsTransportFromClusterUrl<TClusterUrl>,\n        transport =>\n            getWebSocketTransportWithAutoping({\n                intervalMs: intervalMs ?? 5_000,\n                transport,\n            }),\n        transport =>\n            getWebSocketTransportWithConnectionSharding({\n                getShard,\n                transport,\n            }),\n    );\n}\n","import type { RpcSubscriptionsTransport } from '@solana/rpc-subscriptions-spec';\n\ntype Config<TTransport extends RpcSubscriptionsTransport> = Readonly<{\n    intervalMs: number;\n    transport: TTransport;\n}>;\n\nconst PING_PAYLOAD = {\n    jsonrpc: '2.0',\n    method: 'ping',\n} as const;\n\nexport function getWebSocketTransportWithAutoping<TTransport extends RpcSubscriptionsTransport>({\n    intervalMs,\n    transport,\n}: Config<TTransport>): TTransport {\n    const pingableConnections = new Map<\n        Awaited<ReturnType<RpcSubscriptionsTransport>>,\n        Awaited<ReturnType<RpcSubscriptionsTransport>>\n    >();\n    return (async (...args) => {\n        const connection = await transport(...args);\n        let intervalId: ReturnType<typeof setInterval> | undefined;\n        function sendPing() {\n            connection.send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(PING_PAYLOAD);\n        }\n        function restartPingTimer() {\n            clearInterval(intervalId);\n            intervalId = setInterval(sendPing, intervalMs);\n        }\n        if (pingableConnections.has(connection) === false) {\n            pingableConnections.set(connection, {\n                [Symbol.asyncIterator]: connection[Symbol.asyncIterator].bind(connection),\n                send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: (\n                    ...args: Parameters<typeof connection.send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED>\n                ) => {\n                    restartPingTimer();\n                    return connection.send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(...args);\n                },\n            });\n            (async () => {\n                try {\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    for await (const _ of connection) {\n                        restartPingTimer();\n                    }\n                } catch {\n                    /* empty */\n                } finally {\n                    pingableConnections.delete(connection);\n                    clearInterval(intervalId);\n                    if (handleOffline) {\n                        globalThis.window.removeEventListener('offline', handleOffline);\n                    }\n                    if (handleOnline) {\n                        globalThis.window.removeEventListener('online', handleOnline);\n                    }\n                }\n            })();\n            if (!__BROWSER__ || globalThis.navigator.onLine) {\n                restartPingTimer();\n            }\n            let handleOffline;\n            let handleOnline;\n            if (__BROWSER__) {\n                handleOffline = () => {\n                    clearInterval(intervalId);\n                };\n                handleOnline = () => {\n                    sendPing();\n                    restartPingTimer();\n                };\n                globalThis.window.addEventListener('offline', handleOffline);\n                globalThis.window.addEventListener('online', handleOnline);\n            }\n        }\n        return pingableConnections.get(connection)!;\n    }) as TTransport;\n}\n","import type { RpcSubscriptionsTransport } from '@solana/rpc-subscriptions-spec';\n\nimport { getCachedAbortableIterableFactory } from './cached-abortable-iterable';\n\ntype Config<TTransport extends RpcSubscriptionsTransport> = Readonly<{\n    /**\n     * You might like to open more subscriptions per connection than your RPC provider allows for.\n     * Using the initial payload as input, return a shard key from this method to assign\n     * subscriptions to separate connections. One socket will be opened per shard key.\n     */\n    getShard?: (payload: unknown) => string | symbol;\n    transport: TTransport;\n}>;\n\nconst NULL_SHARD_CACHE_KEY = Symbol(\n    __DEV__ ? 'Cache key to use when there is no connection sharding strategy' : undefined,\n);\n\nexport function getWebSocketTransportWithConnectionSharding<TTransport extends RpcSubscriptionsTransport>({\n    getShard,\n    transport,\n}: Config<TTransport>): TTransport {\n    return getCachedAbortableIterableFactory({\n        getAbortSignalFromInputArgs: ({ signal }) => signal,\n        getCacheKeyFromInputArgs: ({ payload }) => (getShard ? getShard(payload) : NULL_SHARD_CACHE_KEY),\n        onCacheHit: (connection, { payload }) => connection.send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(payload),\n        onCreateIterable: (abortSignal, config) =>\n            transport({\n                ...config,\n                signal: abortSignal,\n            }),\n    }) as TTransport;\n}\n","import {\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    mapEncoder,\n} from '@solana/codecs-core';\nimport { getBase58Decoder, getBase58Encoder, getStringDecoder, getStringEncoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\nexport type Blockhash = string & { readonly __brand: unique symbol };\n\nlet memoizedBase58Encoder: Encoder<string> | undefined;\nlet memoizedBase58Decoder: Decoder<string> | undefined;\n\nfunction getMemoizedBase58Encoder(): Encoder<string> {\n    if (!memoizedBase58Encoder) memoizedBase58Encoder = getBase58Encoder();\n    return memoizedBase58Encoder;\n}\n\nfunction getMemoizedBase58Decoder(): Decoder<string> {\n    if (!memoizedBase58Decoder) memoizedBase58Decoder = getBase58Decoder();\n    return memoizedBase58Decoder;\n}\n\nexport function isBlockhash(putativeBlockhash: string): putativeBlockhash is Blockhash {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (32 bytes of zeroes)\n        putativeBlockhash.length < 32 ||\n        // Highest value (32 bytes of 255)\n        putativeBlockhash.length > 44\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeBlockhash);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        return false;\n    }\n    return true;\n}\n\nexport function assertIsBlockhash(putativeBlockhash: string): asserts putativeBlockhash is Blockhash {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (32 bytes of zeroes)\n        putativeBlockhash.length < 32 ||\n        // Highest value (32 bytes of 255)\n        putativeBlockhash.length > 44\n    ) {\n        throw new SolanaError(SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeBlockhash.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeBlockhash);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        throw new SolanaError(SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\nexport function blockhash(putativeBlockhash: string): Blockhash {\n    assertIsBlockhash(putativeBlockhash);\n    return putativeBlockhash as Blockhash;\n}\n\nexport function getBlockhashEncoder(): FixedSizeEncoder<Blockhash, 32> {\n    return mapEncoder(getStringEncoder({ encoding: getMemoizedBase58Encoder(), size: 32 }), putativeBlockhash =>\n        blockhash(putativeBlockhash),\n    );\n}\n\nexport function getBlockhashDecoder(): FixedSizeDecoder<Blockhash, 32> {\n    return getStringDecoder({ encoding: getMemoizedBase58Decoder(), size: 32 }) as FixedSizeDecoder<Blockhash, 32>;\n}\n\nexport function getBlockhashCodec(): FixedSizeCodec<Blockhash, Blockhash, 32> {\n    return combineCodec(getBlockhashEncoder(), getBlockhashDecoder());\n}\n\nexport function getBlockhashComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n","export type MainnetUrl = string & { '~cluster': 'mainnet' };\nexport type DevnetUrl = string & { '~cluster': 'devnet' };\nexport type TestnetUrl = string & { '~cluster': 'testnet' };\nexport type ClusterUrl = DevnetUrl | MainnetUrl | TestnetUrl | string;\n\nexport function mainnet(putativeString: string): MainnetUrl {\n    return putativeString as MainnetUrl;\n}\nexport function devnet(putativeString: string): DevnetUrl {\n    return putativeString as DevnetUrl;\n}\nexport function testnet(putativeString: string): TestnetUrl {\n    return putativeString as TestnetUrl;\n}\n","import { SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, SolanaError } from '@solana/errors';\n\nexport type Commitment = 'confirmed' | 'finalized' | 'processed';\n\nfunction getCommitmentScore(commitment: Commitment): number {\n    switch (commitment) {\n        case 'finalized':\n            return 2;\n        case 'confirmed':\n            return 1;\n        case 'processed':\n            return 0;\n        default:\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                unexpectedValue: commitment satisfies never,\n            });\n    }\n}\n\nexport function commitmentComparator(a: Commitment, b: Commitment): -1 | 0 | 1 {\n    if (a === b) {\n        return 0;\n    }\n    return getCommitmentScore(a) < getCommitmentScore(b) ? -1 : 1;\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder, mapDecoder } from '@solana/codecs-core';\nimport { getU64Decoder, getU64Encoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\n// FIXME(solana-labs/solana/issues/30341) Beware that any value above 9007199254740991 may be\n// truncated or rounded because of a downcast to JavaScript `number` between your calling code and\n// the JSON-RPC transport.\nexport type LamportsUnsafeBeyond2Pow53Minus1 = bigint & { readonly __brand: unique symbol };\n\n// Largest possible value to be represented by a u64\nconst maxU64Value = 18446744073709551615n; // 2n ** 64n - 1n\n\nlet memoizedU64Encoder: FixedSizeEncoder<bigint, 8> | undefined;\nlet memoizedU64Decoder: FixedSizeDecoder<bigint, 8> | undefined;\n\nfunction getMemoizedU64Encoder(): FixedSizeEncoder<bigint, 8> {\n    if (!memoizedU64Encoder) memoizedU64Encoder = getU64Encoder();\n    return memoizedU64Encoder;\n}\n\nfunction getMemoizedU64Decoder(): FixedSizeDecoder<bigint, 8> {\n    if (!memoizedU64Decoder) memoizedU64Decoder = getU64Decoder();\n    return memoizedU64Decoder;\n}\n\nexport function isLamports(putativeLamports: bigint): putativeLamports is LamportsUnsafeBeyond2Pow53Minus1 {\n    return putativeLamports >= 0 && putativeLamports <= maxU64Value;\n}\n\nexport function assertIsLamports(\n    putativeLamports: bigint,\n): asserts putativeLamports is LamportsUnsafeBeyond2Pow53Minus1 {\n    if (putativeLamports < 0 || putativeLamports > maxU64Value) {\n        throw new SolanaError(SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE);\n    }\n}\n\nexport function lamports(putativeLamports: bigint): LamportsUnsafeBeyond2Pow53Minus1 {\n    assertIsLamports(putativeLamports);\n    return putativeLamports;\n}\n\nexport function getLamportsEncoder(): FixedSizeEncoder<LamportsUnsafeBeyond2Pow53Minus1, 8> {\n    return getMemoizedU64Encoder();\n}\n\nexport function getLamportsDecoder(): FixedSizeDecoder<LamportsUnsafeBeyond2Pow53Minus1, 8> {\n    return mapDecoder(getMemoizedU64Decoder(), lamports);\n}\n\nexport function getLamportsCodec(): FixedSizeCodec<\n    LamportsUnsafeBeyond2Pow53Minus1,\n    LamportsUnsafeBeyond2Pow53Minus1,\n    8\n> {\n    return combineCodec(getLamportsEncoder(), getLamportsDecoder());\n}\n","import { SOLANA_ERROR__MALFORMED_BIGINT_STRING, SolanaError } from '@solana/errors';\n\nexport type StringifiedBigInt = string & { readonly __brand: unique symbol };\n\nexport function isStringifiedBigInt(putativeBigInt: string): putativeBigInt is StringifiedBigInt {\n    try {\n        BigInt(putativeBigInt);\n        return true;\n    } catch (_) {\n        return false;\n    }\n}\n\nexport function assertIsStringifiedBigInt(putativeBigInt: string): asserts putativeBigInt is StringifiedBigInt {\n    try {\n        BigInt(putativeBigInt);\n    } catch {\n        throw new SolanaError(SOLANA_ERROR__MALFORMED_BIGINT_STRING, {\n            value: putativeBigInt,\n        });\n    }\n}\n\nexport function stringifiedBigInt(putativeBigInt: string): StringifiedBigInt {\n    assertIsStringifiedBigInt(putativeBigInt);\n    return putativeBigInt;\n}\n","import { SOLANA_ERROR__MALFORMED_NUMBER_STRING, SolanaError } from '@solana/errors';\n\nexport type StringifiedNumber = string & { readonly __brand: unique symbol };\n\nexport function isStringifiedNumber(putativeNumber: string): putativeNumber is StringifiedNumber {\n    return !Number.isNaN(Number(putativeNumber));\n}\n\nexport function assertIsStringifiedNumber(putativeNumber: string): asserts putativeNumber is StringifiedNumber {\n    if (Number.isNaN(Number(putativeNumber))) {\n        throw new SolanaError(SOLANA_ERROR__MALFORMED_NUMBER_STRING, {\n            value: putativeNumber,\n        });\n    }\n}\n\nexport function stringifiedNumber(putativeNumber: string): StringifiedNumber {\n    assertIsStringifiedNumber(putativeNumber);\n    return putativeNumber;\n}\n","import { ITransactionWithSignatures } from '.';\nimport { BaseTransaction } from './types';\n\nexport function getUnsignedTransaction<TTransaction extends BaseTransaction>(\n    transaction: TTransaction | (ITransactionWithSignatures & TTransaction),\n): Omit<ITransactionWithSignatures & TTransaction, keyof ITransactionWithSignatures> | TTransaction {\n    if ('signatures' in transaction) {\n        // The implication of the lifetime constraint changing is that any existing signatures are invalid.\n        const {\n            signatures: _, // eslint-disable-line @typescript-eslint/no-unused-vars\n            ...unsignedTransaction\n        } = transaction;\n        return unsignedTransaction;\n    } else {\n        return transaction;\n    }\n}\n","import { SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME, SolanaError } from '@solana/errors';\nimport { assertIsBlockhash, type Blockhash } from '@solana/rpc-types';\n\nimport { IDurableNonceTransaction } from './durable-nonce';\nimport { ITransactionWithSignatures } from './signatures';\nimport { BaseTransaction } from './types';\nimport { getUnsignedTransaction } from './unsigned-transaction';\n\ntype BlockhashLifetimeConstraint = Readonly<{\n    blockhash: Blockhash;\n    lastValidBlockHeight: bigint;\n}>;\n\nexport interface ITransactionWithBlockhashLifetime {\n    readonly lifetimeConstraint: BlockhashLifetimeConstraint;\n}\n\nfunction isTransactionWithBlockhashLifetime(\n    transaction: BaseTransaction | (BaseTransaction & ITransactionWithBlockhashLifetime),\n): transaction is BaseTransaction & ITransactionWithBlockhashLifetime {\n    const lifetimeConstraintShapeMatches =\n        'lifetimeConstraint' in transaction &&\n        typeof transaction.lifetimeConstraint.blockhash === 'string' &&\n        typeof transaction.lifetimeConstraint.lastValidBlockHeight === 'bigint';\n    if (!lifetimeConstraintShapeMatches) return false;\n    try {\n        assertIsBlockhash(transaction.lifetimeConstraint.blockhash);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\nexport function assertIsTransactionWithBlockhashLifetime(\n    transaction: BaseTransaction | (BaseTransaction & ITransactionWithBlockhashLifetime),\n): asserts transaction is BaseTransaction & ITransactionWithBlockhashLifetime {\n    if (!isTransactionWithBlockhashLifetime(transaction)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n    }\n}\n\nexport function setTransactionLifetimeUsingBlockhash<TTransaction extends BaseTransaction & IDurableNonceTransaction>(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transaction: TTransaction | (ITransactionWithSignatures & TTransaction),\n): ITransactionWithBlockhashLifetime & Omit<TTransaction, keyof ITransactionWithSignatures | 'lifetimeConstraint'>;\n\nexport function setTransactionLifetimeUsingBlockhash<\n    TTransaction extends BaseTransaction | (BaseTransaction & ITransactionWithBlockhashLifetime),\n>(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transaction: TTransaction | (ITransactionWithSignatures & TTransaction),\n): ITransactionWithBlockhashLifetime & Omit<TTransaction, keyof ITransactionWithSignatures>;\n\nexport function setTransactionLifetimeUsingBlockhash(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transaction: BaseTransaction | (BaseTransaction & ITransactionWithBlockhashLifetime),\n) {\n    if (\n        'lifetimeConstraint' in transaction &&\n        transaction.lifetimeConstraint.blockhash === blockhashLifetimeConstraint.blockhash &&\n        transaction.lifetimeConstraint.lastValidBlockHeight === blockhashLifetimeConstraint.lastValidBlockHeight\n    ) {\n        return transaction;\n    }\n    const out = {\n        ...getUnsignedTransaction(transaction),\n        lifetimeConstraint: blockhashLifetimeConstraint,\n    };\n    Object.freeze(out);\n    return out;\n}\n","import { Transaction, TransactionVersion } from './types';\n\ntype TransactionConfig<TVersion extends TransactionVersion> = Readonly<{\n    version: TVersion;\n}>;\n\nexport function createTransaction<TVersion extends TransactionVersion>(\n    config: TransactionConfig<TVersion>,\n): Extract<Transaction, { version: TVersion }>;\nexport function createTransaction<TVersion extends TransactionVersion>({\n    version,\n}: TransactionConfig<TVersion>): Transaction {\n    const out: Transaction = {\n        instructions: [],\n        version,\n    };\n    Object.freeze(out);\n    return out;\n}\n","import { Address, assertIsAddress } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\nimport { pipe } from '@solana/functional';\nimport { AccountRole, IAccountLookupMeta, IAccountMeta, IInstruction } from '@solana/instructions';\nimport { SignatureBytes } from '@solana/keys';\nimport type { Blockhash } from '@solana/rpc-types';\n\nimport { setTransactionLifetimeUsingBlockhash } from './blockhash';\nimport { CompilableTransaction } from './compilable-transaction';\nimport type { getCompiledAddressTableLookups } from './compile-address-table-lookups';\nimport { CompiledTransaction } from './compile-transaction';\nimport { createTransaction } from './create-transaction';\nimport { isAdvanceNonceAccountInstruction, Nonce, setTransactionLifetimeUsingDurableNonce } from './durable-nonce';\nimport { setTransactionFeePayer } from './fee-payer';\nimport { appendTransactionInstruction } from './instructions';\nimport { CompiledMessage } from './message';\nimport { ITransactionWithSignatures } from './signatures';\nimport { TransactionVersion } from './types';\n\nfunction getAccountMetas(message: CompiledMessage): IAccountMeta[] {\n    const { header } = message;\n    const numWritableSignerAccounts = header.numSignerAccounts - header.numReadonlySignerAccounts;\n    const numWritableNonSignerAccounts =\n        message.staticAccounts.length - header.numSignerAccounts - header.numReadonlyNonSignerAccounts;\n\n    const accountMetas: IAccountMeta[] = [];\n\n    let accountIndex = 0;\n    for (let i = 0; i < numWritableSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlySignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < numWritableNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlyNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY,\n        });\n        accountIndex++;\n    }\n\n    return accountMetas;\n}\n\nexport type AddressesByLookupTableAddress = { [lookupTableAddress: Address]: Address[] };\n\nfunction getAddressLookupMetas(\n    compiledAddressTableLookups: ReturnType<typeof getCompiledAddressTableLookups>,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): IAccountLookupMeta[] {\n    // check that all message lookups are known\n    const compiledAddressTableLookupAddresses = compiledAddressTableLookups.map(l => l.lookupTableAddress);\n    const missing = compiledAddressTableLookupAddresses.filter(a => addressesByLookupTableAddress[a] === undefined);\n    if (missing.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, {\n            lookupTableAddresses: missing,\n        });\n    }\n\n    const readOnlyMetas: IAccountLookupMeta[] = [];\n    const writableMetas: IAccountLookupMeta[] = [];\n\n    // we know that for each lookup, knownLookups[lookup.lookupTableAddress] is defined\n    for (const lookup of compiledAddressTableLookups) {\n        const addresses = addressesByLookupTableAddress[lookup.lookupTableAddress];\n\n        const highestIndex = Math.max(...lookup.readableIndices, ...lookup.writableIndices);\n        if (highestIndex >= addresses.length) {\n            throw new SolanaError(\n                SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n                {\n                    highestKnownIndex: addresses.length - 1,\n                    highestRequestedIndex: highestIndex,\n                    lookupTableAddress: lookup.lookupTableAddress,\n                },\n            );\n        }\n\n        const readOnlyForLookup: IAccountLookupMeta[] = lookup.readableIndices.map(r => ({\n            address: addresses[r],\n            addressIndex: r,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.READONLY,\n        }));\n        readOnlyMetas.push(...readOnlyForLookup);\n\n        const writableForLookup: IAccountLookupMeta[] = lookup.writableIndices.map(w => ({\n            address: addresses[w],\n            addressIndex: w,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.WRITABLE,\n        }));\n        writableMetas.push(...writableForLookup);\n    }\n\n    return [...writableMetas, ...readOnlyMetas];\n}\n\nfunction convertInstruction(\n    instruction: CompiledMessage['instructions'][0],\n    accountMetas: IAccountMeta[],\n): IInstruction {\n    const programAddress = accountMetas[instruction.programAddressIndex]?.address;\n    if (!programAddress) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, {\n            index: instruction.programAddressIndex,\n        });\n    }\n\n    const accounts = instruction.accountIndices?.map(accountIndex => accountMetas[accountIndex]);\n    const { data } = instruction;\n\n    return {\n        programAddress,\n        ...(accounts && accounts.length ? { accounts } : {}),\n        ...(data && data.length ? { data } : {}),\n    };\n}\n\ntype LifetimeConstraint =\n    | {\n          blockhash: Blockhash;\n          lastValidBlockHeight: bigint;\n      }\n    | {\n          nonce: Nonce;\n          nonceAccountAddress: Address;\n          nonceAuthorityAddress: Address;\n      };\n\nfunction getLifetimeConstraint(\n    messageLifetimeToken: string,\n    firstInstruction?: IInstruction,\n    lastValidBlockHeight?: bigint,\n): LifetimeConstraint {\n    if (!firstInstruction || !isAdvanceNonceAccountInstruction(firstInstruction)) {\n        // first instruction is not advance durable nonce, so use blockhash lifetime constraint\n        return {\n            blockhash: messageLifetimeToken as Blockhash,\n            lastValidBlockHeight: lastValidBlockHeight ?? 2n ** 64n - 1n, // U64 MAX\n        };\n    } else {\n        // We know these accounts are defined because we checked `isAdvanceNonceAccountInstruction`\n        const nonceAccountAddress = firstInstruction.accounts![0].address;\n        assertIsAddress(nonceAccountAddress);\n\n        const nonceAuthorityAddress = firstInstruction.accounts![2].address;\n        assertIsAddress(nonceAuthorityAddress);\n\n        return {\n            nonce: messageLifetimeToken as Nonce,\n            nonceAccountAddress,\n            nonceAuthorityAddress,\n        };\n    }\n}\n\nfunction convertSignatures(compiledTransaction: CompiledTransaction): ITransactionWithSignatures['signatures'] {\n    const {\n        compiledMessage: { staticAccounts },\n        signatures,\n    } = compiledTransaction;\n    return signatures.reduce((acc, sig, index) => {\n        // compiled transaction includes a fake all 0 signature if it hasn't been signed\n        // we don't store those for the new tx model. So just skip if it's all 0s\n        const allZeros = sig.every(byte => byte === 0);\n        if (allZeros) return acc;\n\n        const address = staticAccounts[index];\n        return { ...acc, [address]: sig as SignatureBytes };\n    }, {});\n}\n\nexport type DecompileTransactionConfig = {\n    addressesByLookupTableAddress?: AddressesByLookupTableAddress;\n    lastValidBlockHeight?: bigint;\n};\n\nexport function decompileTransaction(\n    compiledTransaction: CompiledTransaction,\n    config?: DecompileTransactionConfig,\n): CompilableTransaction | (CompilableTransaction & ITransactionWithSignatures) {\n    const { compiledMessage } = compiledTransaction;\n\n    const feePayer = compiledMessage.staticAccounts[0];\n    if (!feePayer) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING);\n    }\n\n    const accountMetas = getAccountMetas(compiledMessage);\n    const accountLookupMetas =\n        'addressTableLookups' in compiledMessage &&\n        compiledMessage.addressTableLookups !== undefined &&\n        compiledMessage.addressTableLookups.length > 0\n            ? getAddressLookupMetas(compiledMessage.addressTableLookups, config?.addressesByLookupTableAddress ?? {})\n            : [];\n    const transactionMetas = [...accountMetas, ...accountLookupMetas];\n\n    const instructions: IInstruction[] = compiledMessage.instructions.map(compiledInstruction =>\n        convertInstruction(compiledInstruction, transactionMetas),\n    );\n\n    const firstInstruction = instructions[0];\n    const lifetimeConstraint = getLifetimeConstraint(\n        compiledMessage.lifetimeToken,\n        firstInstruction,\n        config?.lastValidBlockHeight,\n    );\n\n    const signatures = convertSignatures(compiledTransaction);\n\n    return pipe(\n        createTransaction({ version: compiledMessage.version as TransactionVersion }),\n        tx => setTransactionFeePayer(feePayer, tx),\n        tx =>\n            instructions.reduce((acc, instruction) => {\n                return appendTransactionInstruction(instruction, acc);\n            }, tx),\n        tx =>\n            'blockhash' in lifetimeConstraint\n                ? setTransactionLifetimeUsingBlockhash(lifetimeConstraint, tx)\n                : setTransactionLifetimeUsingDurableNonce(lifetimeConstraint, tx),\n        tx => (Object.keys(signatures).length > 0 ? { ...tx, signatures } : tx),\n    );\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME, SolanaError } from '@solana/errors';\nimport {\n    AccountRole,\n    IInstruction,\n    IInstructionWithAccounts,\n    IInstructionWithData,\n    isSignerRole,\n    ReadonlyAccount,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableSignerAccount,\n} from '@solana/instructions';\n\nimport { ITransactionWithSignatures } from './signatures';\nimport { BaseTransaction } from './types';\nimport { getUnsignedTransaction } from './unsigned-transaction';\n\ntype AdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n> = IInstruction<'11111111111111111111111111111111'> &\n    IInstructionWithAccounts<\n        readonly [\n            WritableAccount<TNonceAccountAddress>,\n            ReadonlyAccount<'SysvarRecentB1ockHashes11111111111111111111'>,\n            ReadonlySignerAccount<TNonceAuthorityAddress> | WritableSignerAccount<TNonceAuthorityAddress>,\n        ]\n    > &\n    IInstructionWithData<AdvanceNonceAccountInstructionData>;\ntype AdvanceNonceAccountInstructionData = Uint8Array & {\n    readonly __brand: unique symbol;\n};\ntype DurableNonceConfig<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = Readonly<{\n    readonly nonce: Nonce<TNonceValue>;\n    readonly nonceAccountAddress: Address<TNonceAccountAddress>;\n    readonly nonceAuthorityAddress: Address<TNonceAuthorityAddress>;\n}>;\nexport type Nonce<TNonceValue extends string = string> = TNonceValue & { readonly __brand: unique symbol };\ntype NonceLifetimeConstraint<TNonceValue extends string = string> = Readonly<{\n    nonce: Nonce<TNonceValue>;\n}>;\n\nconst RECENT_BLOCKHASHES_SYSVAR_ADDRESS =\n    'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\nconst SYSTEM_PROGRAM_ADDRESS = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n\nexport interface IDurableNonceTransaction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> {\n    readonly instructions: readonly [\n        // The first instruction *must* be the system program's `AdvanceNonceAccount` instruction.\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...IInstruction[],\n    ];\n    readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n}\n\nexport function assertIsDurableNonceTransaction(\n    transaction: BaseTransaction | (BaseTransaction & IDurableNonceTransaction),\n): asserts transaction is BaseTransaction & IDurableNonceTransaction {\n    if (!isDurableNonceTransaction(transaction)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n    }\n}\n\nfunction createAdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n>(\n    nonceAccountAddress: Address<TNonceAccountAddress>,\n    nonceAuthorityAddress: Address<TNonceAuthorityAddress>,\n): AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return {\n        accounts: [\n            { address: nonceAccountAddress, role: AccountRole.WRITABLE },\n            {\n                address: RECENT_BLOCKHASHES_SYSVAR_ADDRESS,\n                role: AccountRole.READONLY,\n            },\n            { address: nonceAuthorityAddress, role: AccountRole.READONLY_SIGNER },\n        ],\n        data: new Uint8Array([4, 0, 0, 0]) as AdvanceNonceAccountInstructionData,\n        programAddress: SYSTEM_PROGRAM_ADDRESS,\n    };\n}\n\nexport function isAdvanceNonceAccountInstruction(\n    instruction: IInstruction,\n): instruction is AdvanceNonceAccountInstruction {\n    return (\n        instruction.programAddress === SYSTEM_PROGRAM_ADDRESS &&\n        // Test for `AdvanceNonceAccount` instruction data\n        instruction.data != null &&\n        isAdvanceNonceAccountInstructionData(instruction.data) &&\n        // Test for exactly 3 accounts\n        instruction.accounts?.length === 3 &&\n        // First account is nonce account address\n        instruction.accounts[0].address != null &&\n        instruction.accounts[0].role === AccountRole.WRITABLE &&\n        // Second account is recent blockhashes sysvar\n        instruction.accounts[1].address === RECENT_BLOCKHASHES_SYSVAR_ADDRESS &&\n        instruction.accounts[1].role === AccountRole.READONLY &&\n        // Third account is nonce authority account\n        instruction.accounts[2].address != null &&\n        isSignerRole(instruction.accounts[2].role)\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionData(data: Uint8Array): data is AdvanceNonceAccountInstructionData {\n    // AdvanceNonceAccount is the fifth instruction in the System Program (index 4)\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n\nfunction isDurableNonceTransaction(\n    transaction: BaseTransaction | (BaseTransaction & IDurableNonceTransaction),\n): transaction is BaseTransaction & IDurableNonceTransaction {\n    return (\n        'lifetimeConstraint' in transaction &&\n        typeof transaction.lifetimeConstraint.nonce === 'string' &&\n        transaction.instructions[0] != null &&\n        isAdvanceNonceAccountInstruction(transaction.instructions[0])\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionForNonce<\n    TNonceAccountAddress extends Address = Address,\n    TNonceAuthorityAddress extends Address = Address,\n>(\n    instruction: AdvanceNonceAccountInstruction,\n    nonceAccountAddress: TNonceAccountAddress,\n    nonceAuthorityAddress: TNonceAuthorityAddress,\n): instruction is AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return (\n        instruction.accounts[0].address === nonceAccountAddress &&\n        instruction.accounts[2].address === nonceAuthorityAddress\n    );\n}\n\nexport function setTransactionLifetimeUsingDurableNonce<\n    TTransaction extends BaseTransaction,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n>(\n    {\n        nonce,\n        nonceAccountAddress,\n        nonceAuthorityAddress,\n    }: DurableNonceConfig<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue>,\n    transaction: TTransaction | (IDurableNonceTransaction & TTransaction),\n): IDurableNonceTransaction<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue> &\n    Omit<TTransaction, keyof ITransactionWithSignatures> {\n    let newInstructions: [\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...IInstruction[],\n    ];\n\n    const firstInstruction = transaction.instructions[0];\n    if (firstInstruction && isAdvanceNonceAccountInstruction(firstInstruction)) {\n        if (isAdvanceNonceAccountInstructionForNonce(firstInstruction, nonceAccountAddress, nonceAuthorityAddress)) {\n            if (isDurableNonceTransaction(transaction) && transaction.lifetimeConstraint.nonce === nonce) {\n                return transaction as IDurableNonceTransaction<\n                    TNonceAccountAddress,\n                    TNonceAuthorityAddress,\n                    TNonceValue\n                > &\n                    TTransaction;\n            } else {\n                // we already have the right first instruction, leave it as-is\n                newInstructions = [firstInstruction, ...transaction.instructions.slice(1)];\n            }\n        } else {\n            // we have a different advance nonce instruction as the first instruction, replace it\n            newInstructions = [\n                createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress),\n                ...transaction.instructions.slice(1),\n            ];\n        }\n    } else {\n        // we don't have an existing advance nonce instruction as the first instruction, prepend one\n        newInstructions = [\n            createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress),\n            ...transaction.instructions,\n        ];\n    }\n\n    const out = {\n        ...getUnsignedTransaction(transaction),\n        instructions: newInstructions,\n        lifetimeConstraint: {\n            nonce,\n        },\n    } as IDurableNonceTransaction<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue> & TTransaction;\n    Object.freeze(out);\n    return out;\n}\n","import { Address } from '@solana/addresses';\n\nimport { ITransactionWithSignatures } from './signatures';\nimport { BaseTransaction } from './types';\nimport { getUnsignedTransaction } from './unsigned-transaction';\n\nexport interface ITransactionWithFeePayer<TAddress extends string = string> {\n    readonly feePayer: Address<TAddress>;\n}\n\nexport function setTransactionFeePayer<TFeePayerAddress extends string, TTransaction extends BaseTransaction>(\n    feePayer: Address<TFeePayerAddress>,\n    transaction:\n        | (ITransactionWithFeePayer<string> & ITransactionWithSignatures & TTransaction)\n        | (ITransactionWithSignatures & TTransaction),\n): ITransactionWithFeePayer<TFeePayerAddress> & Omit<TTransaction, keyof ITransactionWithSignatures>;\n\nexport function setTransactionFeePayer<TFeePayerAddress extends string, TTransaction extends BaseTransaction>(\n    feePayer: Address<TFeePayerAddress>,\n    transaction: TTransaction | (ITransactionWithFeePayer<string> & TTransaction),\n): ITransactionWithFeePayer<TFeePayerAddress> & TTransaction;\n\nexport function setTransactionFeePayer<TFeePayerAddress extends string, TTransaction extends BaseTransaction>(\n    feePayer: Address<TFeePayerAddress>,\n    transaction:\n        | TTransaction\n        | (ITransactionWithFeePayer<string> & ITransactionWithSignatures & TTransaction)\n        | (ITransactionWithFeePayer<string> & TTransaction)\n        | (ITransactionWithSignatures & TTransaction),\n) {\n    if ('feePayer' in transaction && feePayer === transaction.feePayer) {\n        return transaction;\n    }\n    const out = {\n        ...getUnsignedTransaction(transaction),\n        feePayer,\n    };\n    Object.freeze(out);\n    return out;\n}\n","import { ITransactionWithSignatures } from './signatures';\nimport { BaseTransaction } from './types';\nimport { getUnsignedTransaction } from './unsigned-transaction';\n\nexport function appendTransactionInstruction<TTransaction extends BaseTransaction>(\n    instruction: TTransaction['instructions'][number],\n    transaction: TTransaction | (ITransactionWithSignatures & TTransaction),\n): Omit<TTransaction, keyof ITransactionWithSignatures> | TTransaction {\n    return appendTransactionInstructions([instruction], transaction);\n}\n\nexport function appendTransactionInstructions<TTransaction extends BaseTransaction>(\n    instructions: ReadonlyArray<TTransaction['instructions'][number]>,\n    transaction: TTransaction | (ITransactionWithSignatures & TTransaction),\n): Omit<TTransaction, keyof ITransactionWithSignatures> | TTransaction {\n    const out = {\n        ...getUnsignedTransaction(transaction),\n        instructions: [...transaction.instructions, ...instructions],\n    };\n    Object.freeze(out);\n    return out;\n}\n\nexport function prependTransactionInstruction<TTransaction extends BaseTransaction>(\n    instruction: TTransaction['instructions'][number],\n    transaction: TTransaction | (ITransactionWithSignatures & TTransaction),\n): Omit<TTransaction, keyof ITransactionWithSignatures> | TTransaction {\n    return prependTransactionInstructions([instruction], transaction);\n}\n\nexport function prependTransactionInstructions<TTransaction extends BaseTransaction>(\n    instructions: ReadonlyArray<TTransaction['instructions'][number]>,\n    transaction: TTransaction | (ITransactionWithSignatures & TTransaction),\n): Omit<TTransaction, keyof ITransactionWithSignatures> | TTransaction {\n    const out = {\n        ...getUnsignedTransaction(transaction),\n        instructions: [...instructions, ...transaction.instructions],\n    };\n    Object.freeze(out);\n    return out;\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SolanaError,\n} from '@solana/errors';\nimport {\n    AccountRole,\n    IAccountLookupMeta,\n    IAccountMeta,\n    IInstruction,\n    isSignerRole,\n    isWritableRole,\n    mergeRoles,\n    ReadonlyAccount,\n    ReadonlyAccountLookup,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableAccountLookup,\n    WritableSignerAccount,\n} from '@solana/instructions';\n\nexport const enum AddressMapEntryType {\n    FEE_PAYER,\n    LOOKUP_TABLE,\n    STATIC,\n}\n\ntype AddressMap = {\n    [address: string]: FeePayerAccountEntry | LookupTableAccountEntry | StaticAccountEntry;\n};\ntype FeePayerAccountEntry = Omit<WritableSignerAccount, 'address'> & {\n    [TYPE]: AddressMapEntryType.FEE_PAYER;\n};\ntype LookupTableAccountEntry = Omit<ReadonlyAccountLookup | WritableAccountLookup, 'address'> & {\n    [TYPE]: AddressMapEntryType.LOOKUP_TABLE;\n};\nexport type OrderedAccounts = (IAccountLookupMeta | IAccountMeta)[] & { readonly __brand: unique symbol };\ntype StaticAccountEntry = Omit<\n    ReadonlyAccount | ReadonlySignerAccount | WritableAccount | WritableSignerAccount,\n    'address'\n> & { [TYPE]: AddressMapEntryType.STATIC };\n\nfunction upsert(\n    addressMap: AddressMap,\n    address: Address,\n    update: (\n        entry: FeePayerAccountEntry | LookupTableAccountEntry | Record<never, never> | StaticAccountEntry,\n    ) => AddressMap[Address],\n) {\n    addressMap[address] = update(addressMap[address] ?? { role: AccountRole.READONLY });\n}\n\nconst TYPE = Symbol('AddressMapTypeProperty');\nexport const ADDRESS_MAP_TYPE_PROPERTY: typeof TYPE = TYPE;\n\nexport function getAddressMapFromInstructions(feePayer: Address, instructions: readonly IInstruction[]): AddressMap {\n    const addressMap: AddressMap = {\n        [feePayer]: { [TYPE]: AddressMapEntryType.FEE_PAYER, role: AccountRole.WRITABLE_SIGNER },\n    };\n    const addressesOfInvokedPrograms = new Set<Address>();\n    for (const instruction of instructions) {\n        upsert(addressMap, instruction.programAddress, entry => {\n            addressesOfInvokedPrograms.add(instruction.programAddress);\n            if (TYPE in entry) {\n                if (isWritableRole(entry.role)) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, {\n                                programAddress: instruction.programAddress,\n                            });\n                        default:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, {\n                                programAddress: instruction.programAddress,\n                            });\n                    }\n                }\n                if (entry[TYPE] === AddressMapEntryType.STATIC) {\n                    return entry;\n                }\n            }\n            return { [TYPE]: AddressMapEntryType.STATIC, role: AccountRole.READONLY };\n        });\n        let addressComparator: ReturnType<typeof getAddressComparator>;\n        if (!instruction.accounts) {\n            continue;\n        }\n        for (const account of instruction.accounts) {\n            upsert(addressMap, account.address, entry => {\n                const {\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    address: _,\n                    ...accountMeta\n                } = account;\n                if (TYPE in entry) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            // The fee payer already has the highest rank -- it is by definition\n                            // writable-signer. Return it, no matter how `account` is configured\n                            return entry as FeePayerAccountEntry;\n                        case AddressMapEntryType.LOOKUP_TABLE: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if ('lookupTableAddress' in accountMeta) {\n                                const shouldReplaceEntry =\n                                    // Consider using the new LOOKUP_TABLE if its address is different...\n                                    entry.lookupTableAddress !== accountMeta.lookupTableAddress &&\n                                    // ...and sorts before the existing one.\n                                    (addressComparator ||= getAddressComparator())(\n                                        accountMeta.lookupTableAddress,\n                                        entry.lookupTableAddress,\n                                    ) < 0;\n                                if (shouldReplaceEntry) {\n                                    return {\n                                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                        ...accountMeta,\n                                        role: nextRole,\n                                    } as LookupTableAccountEntry;\n                                }\n                            } else if (isSignerRole(accountMeta.role)) {\n                                // Upgrade this LOOKUP_TABLE entry to a static entry if it must sign.\n                                return {\n                                    [TYPE]: AddressMapEntryType.STATIC,\n                                    role: nextRole,\n                                } as StaticAccountEntry;\n                            }\n                            if (entry.role !== nextRole) {\n                                return {\n                                    ...entry,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                return entry as LookupTableAccountEntry;\n                            }\n                        }\n                        case AddressMapEntryType.STATIC: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if (\n                                // Check to see if this address represents a program that is invoked\n                                // in this transaction.\n                                addressesOfInvokedPrograms.has(account.address)\n                            ) {\n                                if (isWritableRole(accountMeta.role)) {\n                                    throw new SolanaError(\n                                        SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n                                        {\n                                            programAddress: account.address,\n                                        },\n                                    );\n                                }\n                                if (entry.role !== nextRole) {\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry as StaticAccountEntry;\n                                }\n                            } else if (\n                                'lookupTableAddress' in accountMeta &&\n                                // Static accounts can be 'upgraded' to lookup table accounts as\n                                // long as they are not require to sign the transaction.\n                                !isSignerRole(entry.role)\n                            ) {\n                                return {\n                                    ...accountMeta,\n                                    [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                if (entry.role !== nextRole) {\n                                    // The account's role ranks higher than the current entry's.\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry as StaticAccountEntry;\n                                }\n                            }\n                        }\n                    }\n                }\n                if ('lookupTableAddress' in accountMeta) {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                    };\n                } else {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.STATIC,\n                    };\n                }\n            });\n        }\n    }\n    return addressMap;\n}\n\nexport function getOrderedAccountsFromAddressMap(addressMap: AddressMap): OrderedAccounts {\n    let addressComparator: ReturnType<typeof getAddressComparator>;\n    const orderedAccounts: (IAccountLookupMeta | IAccountMeta)[] = Object.entries(addressMap)\n        .sort(([leftAddress, leftEntry], [rightAddress, rightEntry]) => {\n            // STEP 1: Rapid precedence check. Fee payer, then static addresses, then lookups.\n            if (leftEntry[TYPE] !== rightEntry[TYPE]) {\n                if (leftEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return 1;\n                } else if (leftEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return 1;\n                }\n            }\n            // STEP 2: Sort by signer-writability.\n            const leftIsSigner = isSignerRole(leftEntry.role);\n            if (leftIsSigner !== isSignerRole(rightEntry.role)) {\n                return leftIsSigner ? -1 : 1;\n            }\n            const leftIsWritable = isWritableRole(leftEntry.role);\n            if (leftIsWritable !== isWritableRole(rightEntry.role)) {\n                return leftIsWritable ? -1 : 1;\n            }\n            // STEP 3: Sort by address.\n            addressComparator ||= getAddressComparator();\n            if (\n                leftEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                rightEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                leftEntry.lookupTableAddress !== rightEntry.lookupTableAddress\n            ) {\n                return addressComparator(leftEntry.lookupTableAddress, rightEntry.lookupTableAddress);\n            } else {\n                return addressComparator(leftAddress, rightAddress);\n            }\n        })\n        .map(([address, addressMeta]) => ({\n            address: address as Address<typeof address>,\n            ...addressMeta,\n        }));\n    return orderedAccounts as unknown as OrderedAccounts;\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport { AccountRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from './accounts';\n\ntype AddressTableLookup = Readonly<{\n    lookupTableAddress: Address;\n    readableIndices: readonly number[];\n    writableIndices: readonly number[];\n}>;\n\nexport function getCompiledAddressTableLookups(orderedAccounts: OrderedAccounts): AddressTableLookup[] {\n    const index: Record<Address, { readonly readableIndices: number[]; readonly writableIndices: number[] }> = {};\n    for (const account of orderedAccounts) {\n        if (!('lookupTableAddress' in account)) {\n            continue;\n        }\n        const entry = (index[account.lookupTableAddress] ||= {\n            readableIndices: [],\n            writableIndices: [],\n        });\n        if (account.role === AccountRole.WRITABLE) {\n            entry.writableIndices.push(account.addressIndex);\n        } else {\n            entry.readableIndices.push(account.addressIndex);\n        }\n    }\n    return Object.keys(index)\n        .sort(getAddressComparator())\n        .map(lookupTableAddress => ({\n            lookupTableAddress: lookupTableAddress as Address,\n            ...index[lookupTableAddress as unknown as Address],\n        }));\n}\n","import { isSignerRole, isWritableRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from './accounts';\n\ntype MessageHeader = Readonly<{\n    numReadonlyNonSignerAccounts: number;\n    numReadonlySignerAccounts: number;\n    numSignerAccounts: number;\n}>;\n\nexport function getCompiledMessageHeader(orderedAccounts: OrderedAccounts): MessageHeader {\n    let numReadonlyNonSignerAccounts = 0;\n    let numReadonlySignerAccounts = 0;\n    let numSignerAccounts = 0;\n    for (const account of orderedAccounts) {\n        if ('lookupTableAddress' in account) {\n            break;\n        }\n        const accountIsWritable = isWritableRole(account.role);\n        if (isSignerRole(account.role)) {\n            numSignerAccounts++;\n            if (!accountIsWritable) {\n                numReadonlySignerAccounts++;\n            }\n        } else if (!accountIsWritable) {\n            numReadonlyNonSignerAccounts++;\n        }\n    }\n    return {\n        numReadonlyNonSignerAccounts,\n        numReadonlySignerAccounts,\n        numSignerAccounts,\n    };\n}\n","import { Address } from '@solana/addresses';\nimport { IInstruction } from '@solana/instructions';\n\nimport { OrderedAccounts } from './accounts';\n\ntype CompiledInstruction = Readonly<{\n    accountIndices?: number[];\n    data?: Uint8Array;\n    programAddressIndex: number;\n}>;\n\nfunction getAccountIndex(orderedAccounts: OrderedAccounts) {\n    const out: Record<Address, number> = {};\n    for (const [index, account] of orderedAccounts.entries()) {\n        out[account.address] = index;\n    }\n    return out;\n}\n\nexport function getCompiledInstructions(\n    instructions: readonly IInstruction[],\n    orderedAccounts: OrderedAccounts,\n): CompiledInstruction[] {\n    const accountIndex = getAccountIndex(orderedAccounts);\n    return instructions.map(({ accounts, data, programAddress }) => {\n        return {\n            programAddressIndex: accountIndex[programAddress],\n            ...(accounts ? { accountIndices: accounts.map(({ address }) => accountIndex[address]) } : null),\n            ...(data ? { data } : null),\n        };\n    });\n}\n","import { IDurableNonceTransaction, ITransactionWithBlockhashLifetime } from './index';\n\nexport function getCompiledLifetimeToken(\n    lifetimeConstraint: (IDurableNonceTransaction | ITransactionWithBlockhashLifetime)['lifetimeConstraint'],\n): string {\n    if ('nonce' in lifetimeConstraint) {\n        return lifetimeConstraint.nonce;\n    }\n    return lifetimeConstraint.blockhash;\n}\n","import { Address } from '@solana/addresses';\n\nimport { OrderedAccounts } from './accounts';\n\nexport function getCompiledStaticAccounts(orderedAccounts: OrderedAccounts): Address[] {\n    const firstLookupTableAccountIndex = orderedAccounts.findIndex(account => 'lookupTableAddress' in account);\n    const orderedStaticAccounts =\n        firstLookupTableAccountIndex === -1 ? orderedAccounts : orderedAccounts.slice(0, firstLookupTableAccountIndex);\n    return orderedStaticAccounts.map(({ address }) => address);\n}\n","import { getAddressMapFromInstructions, getOrderedAccountsFromAddressMap } from './accounts';\nimport { CompilableTransaction } from './compilable-transaction';\nimport { getCompiledAddressTableLookups } from './compile-address-table-lookups';\nimport { getCompiledMessageHeader } from './compile-header';\nimport { getCompiledInstructions } from './compile-instructions';\nimport { getCompiledLifetimeToken } from './compile-lifetime-token';\nimport { getCompiledStaticAccounts } from './compile-static-accounts';\n\ntype BaseCompiledMessage = Readonly<{\n    header: ReturnType<typeof getCompiledMessageHeader>;\n    instructions: ReturnType<typeof getCompiledInstructions>;\n    lifetimeToken: ReturnType<typeof getCompiledLifetimeToken>;\n    staticAccounts: ReturnType<typeof getCompiledStaticAccounts>;\n}>;\n\nexport type CompiledMessage = LegacyCompiledMessage | VersionedCompiledMessage;\n\ntype LegacyCompiledMessage = BaseCompiledMessage &\n    Readonly<{\n        version: 'legacy';\n    }>;\n\ntype VersionedCompiledMessage = BaseCompiledMessage &\n    Readonly<{\n        addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups>;\n        version: number;\n    }>;\n\nexport function compileMessage(\n    transaction: CompilableTransaction & Readonly<{ version: 'legacy' }>,\n): LegacyCompiledMessage;\nexport function compileMessage(transaction: CompilableTransaction): VersionedCompiledMessage;\nexport function compileMessage(transaction: CompilableTransaction): CompiledMessage {\n    const addressMap = getAddressMapFromInstructions(transaction.feePayer, transaction.instructions);\n    const orderedAccounts = getOrderedAccountsFromAddressMap(addressMap);\n    return {\n        ...(transaction.version !== 'legacy'\n            ? { addressTableLookups: getCompiledAddressTableLookups(orderedAccounts) }\n            : null),\n        header: getCompiledMessageHeader(orderedAccounts),\n        instructions: getCompiledInstructions(transaction.instructions, orderedAccounts),\n        lifetimeToken: getCompiledLifetimeToken(transaction.lifetimeConstraint),\n        staticAccounts: getCompiledStaticAccounts(orderedAccounts),\n        version: transaction.version,\n    };\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    createEncoder,\n    Decoder,\n    mapDecoder,\n    mapEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder } from '@solana/codecs-numbers';\nimport { getBase58Decoder, getBase58Encoder, getStringDecoder, getStringEncoder } from '@solana/codecs-strings';\n\nimport type { getCompiledAddressTableLookups } from '../compile-address-table-lookups';\nimport { CompiledMessage } from '../message';\nimport { getAddressTableLookupDecoder, getAddressTableLookupEncoder } from './address-table-lookup';\nimport { getMessageHeaderDecoder, getMessageHeaderEncoder } from './header';\nimport { getInstructionDecoder, getInstructionEncoder } from './instruction';\nimport { getTransactionVersionDecoder, getTransactionVersionEncoder } from './transaction-version';\n\nfunction getCompiledMessageLegacyEncoder(): VariableSizeEncoder<CompiledMessage> {\n    return getStructEncoder(getPreludeStructEncoderTuple()) as VariableSizeEncoder<CompiledMessage>;\n}\n\nfunction getCompiledMessageVersionedEncoder(): VariableSizeEncoder<CompiledMessage> {\n    return mapEncoder(\n        getStructEncoder([\n            ...getPreludeStructEncoderTuple(),\n            ['addressTableLookups', getAddressTableLookupArrayEncoder()],\n        ]) as VariableSizeEncoder<CompiledMessage>,\n        (value: CompiledMessage) => {\n            if (value.version === 'legacy') {\n                return value;\n            }\n            return {\n                ...value,\n                addressTableLookups: value.addressTableLookups ?? [],\n            } as Exclude<CompiledMessage, { readonly version: 'legacy' }>;\n        },\n    ) as VariableSizeEncoder<CompiledMessage>;\n}\n\nfunction getPreludeStructEncoderTuple() {\n    return [\n        ['version', getTransactionVersionEncoder()],\n        ['header', getMessageHeaderEncoder()],\n        ['staticAccounts', getArrayEncoder(getAddressEncoder(), { size: getShortU16Encoder() })],\n        ['lifetimeToken', getStringEncoder({ encoding: getBase58Encoder(), size: 32 })],\n        ['instructions', getArrayEncoder(getInstructionEncoder(), { size: getShortU16Encoder() })],\n    ] as const;\n}\n\nfunction getPreludeStructDecoderTuple() {\n    return [\n        ['version', getTransactionVersionDecoder() as Decoder<number>],\n        ['header', getMessageHeaderDecoder()],\n        ['staticAccounts', getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() })],\n        ['lifetimeToken', getStringDecoder({ encoding: getBase58Decoder(), size: 32 })],\n        ['instructions', getArrayDecoder(getInstructionDecoder(), { size: getShortU16Decoder() })],\n        ['addressTableLookups', getAddressTableLookupArrayDecoder()],\n    ] as const;\n}\n\nfunction getAddressTableLookupArrayEncoder() {\n    return getArrayEncoder(getAddressTableLookupEncoder(), { size: getShortU16Encoder() });\n}\n\nfunction getAddressTableLookupArrayDecoder() {\n    return getArrayDecoder(getAddressTableLookupDecoder(), { size: getShortU16Decoder() });\n}\n\nexport function getCompiledMessageEncoder(): VariableSizeEncoder<CompiledMessage> {\n    return createEncoder({\n        getSizeFromValue: (compiledMessage: CompiledMessage) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().getSizeFromValue(compiledMessage);\n            } else {\n                return getCompiledMessageVersionedEncoder().getSizeFromValue(compiledMessage);\n            }\n        },\n        write: (compiledMessage, bytes, offset) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().write(compiledMessage, bytes, offset);\n            } else {\n                return getCompiledMessageVersionedEncoder().write(compiledMessage, bytes, offset);\n            }\n        },\n    });\n}\n\nexport function getCompiledMessageDecoder(): VariableSizeDecoder<CompiledMessage> {\n    return mapDecoder(\n        getStructDecoder(getPreludeStructDecoderTuple()) as VariableSizeDecoder<\n            CompiledMessage & { addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups> }\n        >,\n        ({ addressTableLookups, ...restOfMessage }) => {\n            if (restOfMessage.version === 'legacy' || !addressTableLookups?.length) {\n                return restOfMessage;\n            }\n            return { ...restOfMessage, addressTableLookups } as Exclude<\n                CompiledMessage,\n                { readonly version: 'legacy' }\n            >;\n        },\n    );\n}\n\nexport function getCompiledMessageCodec(): VariableSizeCodec<CompiledMessage> {\n    return combineCodec(getCompiledMessageEncoder(), getCompiledMessageDecoder());\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    type Encoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport type { getCompiledAddressTableLookups } from '../compile-address-table-lookups';\n\ntype AddressTableLookup = ReturnType<typeof getCompiledAddressTableLookups>[number];\n\nlet memoizedAddressTableLookupEncoder: VariableSizeEncoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupEncoder(): VariableSizeEncoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupEncoder) {\n        memoizedAddressTableLookupEncoder = getStructEncoder([\n            ['lookupTableAddress', getAddressEncoder()],\n            [\n                'writableIndices',\n                getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() }) as Encoder<readonly number[]>,\n            ],\n            [\n                'readableIndices',\n                getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() }) as Encoder<readonly number[]>,\n            ],\n        ]);\n    }\n\n    return memoizedAddressTableLookupEncoder;\n}\n\nlet memoizedAddressTableLookupDecoder: VariableSizeDecoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupDecoder(): VariableSizeDecoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupDecoder) {\n        memoizedAddressTableLookupDecoder = getStructDecoder([\n            ['lookupTableAddress', getAddressDecoder()],\n            ['writableIndices', getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],\n            ['readableIndices', getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],\n        ]);\n    }\n\n    return memoizedAddressTableLookupDecoder;\n}\n\nexport function getAddressTableLookupCodec(): VariableSizeCodec<AddressTableLookup> {\n    return combineCodec(getAddressTableLookupEncoder(), getAddressTableLookupDecoder());\n}\n","import { FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport { getStructCodec, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getU8Codec, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledMessageHeader } from '../compile-header';\n\ntype MessageHeader = ReturnType<typeof getCompiledMessageHeader>;\n\nlet memoizedU8Encoder: FixedSizeEncoder<number, 1> | undefined;\nfunction getMemoizedU8Encoder(): FixedSizeEncoder<number, 1> {\n    if (!memoizedU8Encoder) memoizedU8Encoder = getU8Encoder();\n    return memoizedU8Encoder;\n}\n\nlet memoizedU8Decoder: FixedSizeDecoder<number, 1> | undefined;\nfunction getMemoizedU8Decoder(): FixedSizeDecoder<number, 1> {\n    if (!memoizedU8Decoder) memoizedU8Decoder = getU8Decoder();\n    return memoizedU8Decoder;\n}\n\nlet memoizedU8Codec: FixedSizeCodec<number, number, 1> | undefined;\nfunction getMemoizedU8Codec(): FixedSizeCodec<number, number, 1> {\n    if (!memoizedU8Codec) memoizedU8Codec = getU8Codec();\n    return memoizedU8Codec;\n}\n\nexport function getMessageHeaderEncoder(): FixedSizeEncoder<MessageHeader, 3> {\n    return getStructEncoder([\n        ['numSignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Encoder()],\n    ]) as FixedSizeEncoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderDecoder(): FixedSizeDecoder<MessageHeader, 3> {\n    return getStructDecoder([\n        ['numSignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Decoder()],\n    ]) as FixedSizeDecoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderCodec(): FixedSizeCodec<MessageHeader, MessageHeader, 3> {\n    return getStructCodec([\n        ['numSignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlySignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Codec()],\n    ]) as FixedSizeCodec<MessageHeader, MessageHeader, 3>;\n}\n","import {\n    combineCodec,\n    mapDecoder,\n    mapEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledInstructions } from '../compile-instructions';\n\ntype Instruction = ReturnType<typeof getCompiledInstructions>[number];\n\nlet memoizedGetInstructionEncoder: VariableSizeEncoder<Instruction> | undefined;\nexport function getInstructionEncoder(): VariableSizeEncoder<Instruction> {\n    if (!memoizedGetInstructionEncoder) {\n        memoizedGetInstructionEncoder = mapEncoder<Required<Instruction>, Instruction>(\n            getStructEncoder([\n                ['programAddressIndex', getU8Encoder()],\n                ['accountIndices', getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() })],\n                ['data', getBytesEncoder({ size: getShortU16Encoder() })],\n            ]),\n            // Convert an instruction to have all fields defined\n            (instruction: Instruction): Required<Instruction> => {\n                if (instruction.accountIndices !== undefined && instruction.data !== undefined) {\n                    return instruction as Required<Instruction>;\n                }\n                return {\n                    ...instruction,\n                    accountIndices: instruction.accountIndices ?? [],\n                    data: instruction.data ?? new Uint8Array(0),\n                } as Required<Instruction>;\n            },\n        );\n    }\n\n    return memoizedGetInstructionEncoder;\n}\n\nlet memoizedGetInstructionDecoder: VariableSizeDecoder<Instruction> | undefined;\nexport function getInstructionDecoder(): VariableSizeDecoder<Instruction> {\n    if (!memoizedGetInstructionDecoder) {\n        memoizedGetInstructionDecoder = mapDecoder<Required<Instruction>, Instruction>(\n            getStructDecoder([\n                ['programAddressIndex', getU8Decoder()],\n                ['accountIndices', getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],\n                ['data', getBytesDecoder({ size: getShortU16Decoder() })],\n            ]),\n            // Convert an instruction to exclude optional fields if they are empty\n            (instruction: Required<Instruction>): Instruction => {\n                if (instruction.accountIndices.length && instruction.data.byteLength) {\n                    return instruction;\n                }\n                const { accountIndices, data, ...rest } = instruction;\n                return {\n                    ...rest,\n                    ...(accountIndices.length ? { accountIndices } : null),\n                    ...(data.byteLength ? { data } : null),\n                };\n            },\n        );\n    }\n    return memoizedGetInstructionDecoder;\n}\n\nexport function getInstructionCodec(): VariableSizeCodec<Instruction> {\n    return combineCodec(getInstructionEncoder(), getInstructionDecoder());\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nimport { TransactionVersion } from '../types';\n\nconst VERSION_FLAG_MASK = 0x80;\n\nexport function getTransactionVersionEncoder(): VariableSizeEncoder<TransactionVersion> {\n    return createEncoder({\n        getSizeFromValue: value => (value === 'legacy' ? 0 : 1),\n        maxSize: 1,\n        write: (value, bytes, offset) => {\n            if (value === 'legacy') {\n                return offset;\n            }\n            if (value < 0 || value > 127) {\n                throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, {\n                    actualVersion: value,\n                });\n            }\n            bytes.set([value | VERSION_FLAG_MASK], offset);\n            return offset + 1;\n        },\n    });\n}\n\nexport function getTransactionVersionDecoder(): VariableSizeDecoder<TransactionVersion> {\n    return createDecoder({\n        maxSize: 1,\n        read: (bytes, offset) => {\n            const firstByte = bytes[offset];\n            if ((firstByte & VERSION_FLAG_MASK) === 0) {\n                // No version flag set; it's a legacy (unversioned) transaction.\n                return ['legacy', offset];\n            } else {\n                const version = (firstByte ^ VERSION_FLAG_MASK) as TransactionVersion;\n                return [version, offset + 1];\n            }\n        },\n    });\n}\n\nexport function getTransactionVersionCodec(): VariableSizeCodec<TransactionVersion> {\n    return combineCodec(getTransactionVersionEncoder(), getTransactionVersionDecoder());\n}\n","import {\n    combineCodec,\n    FixedSizeDecoder,\n    mapDecoder,\n    mapEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder } from '@solana/codecs-numbers';\nimport { SignatureBytes } from '@solana/keys';\n\nimport { CompilableTransaction } from '../compilable-transaction';\nimport { CompiledTransaction, getCompiledTransaction } from '../compile-transaction';\nimport { decompileTransaction, DecompileTransactionConfig } from '../decompile-transaction';\nimport { ITransactionWithSignatures } from '../signatures';\nimport { getCompiledMessageDecoder, getCompiledMessageEncoder } from './message';\n\nfunction getCompiledTransactionEncoder(): VariableSizeEncoder<CompiledTransaction> {\n    return getStructEncoder([\n        ['signatures', getArrayEncoder(getBytesEncoder({ size: 64 }), { size: getShortU16Encoder() })],\n        ['compiledMessage', getCompiledMessageEncoder()],\n    ]);\n}\n\nexport function getCompiledTransactionDecoder(): VariableSizeDecoder<CompiledTransaction> {\n    return getStructDecoder([\n        [\n            'signatures',\n            getArrayDecoder(getBytesDecoder({ size: 64 }) as FixedSizeDecoder<SignatureBytes, 64>, {\n                size: getShortU16Decoder(),\n            }),\n        ],\n        ['compiledMessage', getCompiledMessageDecoder()],\n    ]);\n}\n\nexport function getTransactionEncoder(): VariableSizeEncoder<\n    CompilableTransaction | (CompilableTransaction & ITransactionWithSignatures)\n> {\n    return mapEncoder(getCompiledTransactionEncoder(), getCompiledTransaction);\n}\n\nexport function getTransactionDecoder(\n    config?: DecompileTransactionConfig,\n): VariableSizeDecoder<CompilableTransaction | (CompilableTransaction & ITransactionWithSignatures)> {\n    return mapDecoder(getCompiledTransactionDecoder(), compiledTransaction =>\n        decompileTransaction(compiledTransaction, config),\n    );\n}\n\nexport function getTransactionCodec(\n    config?: DecompileTransactionConfig,\n): VariableSizeCodec<CompilableTransaction | (CompilableTransaction & ITransactionWithSignatures)> {\n    return combineCodec(getTransactionEncoder(), getTransactionDecoder(config));\n}\n","import { SignatureBytes } from '@solana/keys';\n\nimport { CompilableTransaction } from './compilable-transaction';\nimport { CompiledMessage, compileMessage } from './message';\nimport { ITransactionWithSignatures } from './signatures';\n\nexport type CompiledTransaction = Readonly<{\n    compiledMessage: CompiledMessage;\n    signatures: SignatureBytes[];\n}>;\n\nexport function getCompiledTransaction(\n    transaction: CompilableTransaction | (CompilableTransaction & ITransactionWithSignatures),\n): CompiledTransaction {\n    const compiledMessage = compileMessage(transaction);\n    let signatures;\n    if ('signatures' in transaction) {\n        signatures = [];\n        for (let ii = 0; ii < compiledMessage.header.numSignerAccounts; ii++) {\n            signatures[ii] =\n                transaction.signatures[compiledMessage.staticAccounts[ii]] ?? new Uint8Array(Array(64).fill(0));\n        }\n    } else {\n        signatures = Array(compiledMessage.header.numSignerAccounts).fill(new Uint8Array(Array(64).fill(0)));\n    }\n    return {\n        compiledMessage,\n        signatures,\n    };\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, SolanaError } from '@solana/errors';\n\nimport { MessageSigner } from './message-signer';\nimport { TransactionSigner } from './transaction-signer';\n\n/** Removes all duplicated signers from a provided array by comparing their addresses. */\nexport function deduplicateSigners<TSigner extends MessageSigner | TransactionSigner>(\n    signers: readonly TSigner[],\n): readonly TSigner[] {\n    const deduplicated: Record<Address, TSigner> = {};\n    signers.forEach(signer => {\n        if (!deduplicated[signer.address]) {\n            deduplicated[signer.address] = signer;\n        } else if (deduplicated[signer.address] !== signer) {\n            throw new SolanaError(SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, {\n                address: signer.address,\n            });\n        }\n    });\n    return Object.values(deduplicated);\n}\n","import { AccountRole, IAccountLookupMeta, IAccountMeta, IInstruction } from '@solana/instructions';\nimport { BaseTransaction, TransactionVersion } from '@solana/transactions';\n\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { TransactionSigner } from './transaction-signer';\n\n/** An extension of the IAccountMeta type that keeps track of its transaction signer. */\nexport interface IAccountSignerMeta<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n> extends IAccountMeta<TAddress> {\n    readonly role: AccountRole.READONLY_SIGNER | AccountRole.WRITABLE_SIGNER;\n    readonly signer: TSigner;\n}\n\ntype IAccountMetaWithSigner<TSigner extends TransactionSigner = TransactionSigner> =\n    | IAccountLookupMeta\n    | IAccountMeta\n    | IAccountSignerMeta<string, TSigner>;\n\n/** A variation of the instruction type that allows IAccountSignerMeta in its account metas. */\nexport type IInstructionWithSigners<\n    TSigner extends TransactionSigner = TransactionSigner,\n    TAccounts extends readonly IAccountMetaWithSigner<TSigner>[] = readonly IAccountMetaWithSigner<TSigner>[],\n> = Pick<IInstruction<string, TAccounts>, 'accounts'>;\n\n/** A variation of the transaction type that allows IAccountSignerMeta in its account metas. */\nexport type ITransactionWithSigners<\n    TSigner extends TransactionSigner = TransactionSigner,\n    TAccounts extends readonly IAccountMetaWithSigner<TSigner>[] = readonly IAccountMetaWithSigner<TSigner>[],\n> = Pick<\n    BaseTransaction<TransactionVersion, IInstruction & IInstructionWithSigners<TSigner, TAccounts>>,\n    'instructions'\n> & { feePayerSigner?: TSigner };\n\n/** Extract all signers from an instruction that may contain IAccountSignerMeta accounts. */\nexport function getSignersFromInstruction<TSigner extends TransactionSigner = TransactionSigner>(\n    instruction: IInstructionWithSigners<TSigner>,\n): readonly TSigner[] {\n    return deduplicateSigners(\n        (instruction.accounts ?? []).flatMap(account => ('signer' in account ? account.signer : [])),\n    );\n}\n\n/** Extract all signers from a transaction that may contain IAccountSignerMeta accounts. */\nexport function getSignersFromTransaction<\n    TSigner extends TransactionSigner = TransactionSigner,\n    TTransaction extends ITransactionWithSigners<TSigner> = ITransactionWithSigners<TSigner>,\n>(transaction: TTransaction): readonly TSigner[] {\n    return deduplicateSigners([\n        ...(transaction.feePayerSigner ? [transaction.feePayerSigner] : []),\n        ...transaction.instructions.flatMap(getSignersFromInstruction),\n    ]);\n}\n","import { IInstruction, isSignerRole } from '@solana/instructions';\nimport { BaseTransaction } from '@solana/transactions';\n\nimport { IAccountSignerMeta, IInstructionWithSigners, ITransactionWithSigners } from './account-signer-meta';\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { TransactionSigner } from './transaction-signer';\n\n/** Attaches the provided signers to the account metas of an instruction when applicable. */\nexport function addSignersToInstruction<TInstruction extends IInstruction>(\n    signers: TransactionSigner[],\n    instruction: TInstruction | (IInstructionWithSigners & TInstruction),\n): IInstructionWithSigners & TInstruction {\n    if (!instruction.accounts || instruction.accounts.length === 0) {\n        return instruction as IInstructionWithSigners & TInstruction;\n    }\n\n    const signerByAddress = new Map(deduplicateSigners(signers).map(signer => [signer.address, signer]));\n    return Object.freeze({\n        ...instruction,\n        accounts: instruction.accounts.map(account => {\n            const signer = signerByAddress.get(account.address);\n            if (!isSignerRole(account.role) || 'signer' in account || !signer) {\n                return account;\n            }\n            return Object.freeze({ ...account, signer } as IAccountSignerMeta);\n        }),\n    });\n}\n\n/** Attaches the provided signers to the account metas of a transaction when applicable. */\nexport function addSignersToTransaction<TTransaction extends BaseTransaction>(\n    signers: TransactionSigner[],\n    transaction: TTransaction | (ITransactionWithSigners & TTransaction),\n): ITransactionWithSigners & TTransaction {\n    if (transaction.instructions.length === 0) {\n        return transaction as ITransactionWithSigners & TTransaction;\n    }\n\n    return Object.freeze({\n        ...transaction,\n        instructions: transaction.instructions.map(instruction => addSignersToInstruction(signers, instruction)),\n    });\n}\n","import { Address } from '@solana/addresses';\nimport {\n    BaseTransaction,\n    getUnsignedTransaction,\n    ITransactionWithFeePayer,\n    ITransactionWithSignatures,\n} from '@solana/transactions';\n\nimport { TransactionSigner } from './transaction-signer';\n\nexport interface ITransactionWithFeePayerSigner<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n> {\n    readonly feePayer: Address<TAddress>;\n    readonly feePayerSigner: TSigner;\n}\n\nexport function setTransactionFeePayerSigner<TFeePayerAddress extends string, TTransaction extends BaseTransaction>(\n    feePayerSigner: TransactionSigner<TFeePayerAddress>,\n    transaction:\n        | (ITransactionWithFeePayer<string> & ITransactionWithSignatures & TTransaction)\n        | (ITransactionWithSignatures & TTransaction),\n): ITransactionWithFeePayerSigner<TFeePayerAddress> & Omit<TTransaction, keyof ITransactionWithSignatures>;\n\nexport function setTransactionFeePayerSigner<TFeePayerAddress extends string, TTransaction extends BaseTransaction>(\n    feePayerSigner: TransactionSigner<TFeePayerAddress>,\n    transaction: TTransaction | (ITransactionWithFeePayer<string> & TTransaction),\n): ITransactionWithFeePayerSigner<TFeePayerAddress> & TTransaction;\n\nexport function setTransactionFeePayerSigner<TFeePayerAddress extends string, TTransaction extends BaseTransaction>(\n    feePayerSigner: TransactionSigner<TFeePayerAddress>,\n    transaction:\n        | TTransaction\n        | (ITransactionWithFeePayer<string> & ITransactionWithSignatures & TTransaction)\n        | (ITransactionWithFeePayer<string> & TTransaction)\n        | (ITransactionWithSignatures & TTransaction),\n) {\n    if ('feePayer' in transaction && feePayerSigner.address === transaction.feePayer) {\n        if ('feePayerSigner' in transaction) return transaction;\n        const out = { ...transaction, feePayerSigner };\n        Object.freeze(out);\n        return out;\n    }\n    const out = {\n        ...getUnsignedTransaction(transaction),\n        feePayer: feePayerSigner.address,\n        feePayerSigner,\n    };\n    Object.freeze(out);\n    return out;\n}\n","import { Address, getAddressFromPublicKey } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, SolanaError } from '@solana/errors';\nimport { createKeyPairFromBytes, generateKeyPair, signBytes } from '@solana/keys';\nimport { partiallySignTransaction } from '@solana/transactions';\n\nimport { isMessagePartialSigner, MessagePartialSigner } from './message-partial-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\n\n/** Defines a signer capable of signing messages and transactions using a CryptoKeyPair. */\nexport type KeyPairSigner<TAddress extends string = string> = MessagePartialSigner<TAddress> &\n    TransactionPartialSigner<TAddress> & { keyPair: CryptoKeyPair };\n\n/** Checks whether the provided value implements the {@link KeyPairSigner} interface. */\nexport function isKeyPairSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is KeyPairSigner<TAddress> {\n    return (\n        'keyPair' in value &&\n        typeof value.keyPair === 'object' &&\n        isMessagePartialSigner(value) &&\n        isTransactionPartialSigner(value)\n    );\n}\n\n/** Asserts that the provided value implements the {@link KeyPairSigner} interface. */\nexport function assertIsKeyPairSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is KeyPairSigner<TAddress> {\n    if (!isKeyPairSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n\n/** Creates a KeyPairSigner from the provided Crypto KeyPair. */\nexport async function createSignerFromKeyPair(keyPair: CryptoKeyPair): Promise<KeyPairSigner> {\n    const address = await getAddressFromPublicKey(keyPair.publicKey);\n    const out: KeyPairSigner = {\n        address,\n        keyPair,\n        signMessages: messages =>\n            Promise.all(\n                messages.map(async message =>\n                    Object.freeze({ [address]: await signBytes(keyPair.privateKey, message.content) }),\n                ),\n            ),\n        signTransactions: transactions =>\n            Promise.all(\n                transactions.map(async transaction => {\n                    const signedTransaction = await partiallySignTransaction([keyPair], transaction);\n                    return Object.freeze({ [address]: signedTransaction.signatures[address] });\n                }),\n            ),\n    };\n\n    return Object.freeze(out);\n}\n\n/** Securely generates a signer capable of signing messages and transactions using a Crypto KeyPair. */\nexport async function generateKeyPairSigner(): Promise<KeyPairSigner> {\n    return createSignerFromKeyPair(await generateKeyPair());\n}\n\n/** Creates a signer capable of signing messages and transactions using the 64 bytes of a KeyPair. */\nexport async function createKeyPairSignerFromBytes(bytes: Uint8Array, extractable?: boolean): Promise<KeyPairSigner> {\n    return createSignerFromKeyPair(await createKeyPairFromBytes(bytes, extractable));\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, SolanaError } from '@solana/errors';\n\nimport { SignableMessage } from './signable-message';\nimport { BaseSignerConfig, SignatureDictionary } from './types';\n\nexport type MessagePartialSignerConfig = BaseSignerConfig;\n\n/** Defines a signer capable of signing messages. */\nexport type MessagePartialSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signMessages(\n        messages: readonly SignableMessage[],\n        config?: MessagePartialSignerConfig,\n    ): Promise<readonly SignatureDictionary[]>;\n}>;\n\n/** Checks whether the provided value implements the {@link MessagePartialSigner} interface. */\nexport function isMessagePartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessagePartialSigner<TAddress> {\n    return 'signMessages' in value && typeof value.signMessages === 'function';\n}\n\n/** Asserts that the provided value implements the {@link MessagePartialSigner} interface. */\nexport function assertIsMessagePartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessagePartialSigner<TAddress> {\n    if (!isMessagePartialSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, SolanaError } from '@solana/errors';\nimport { CompilableTransaction } from '@solana/transactions';\n\nimport { BaseSignerConfig, SignatureDictionary } from './types';\n\nexport type TransactionPartialSignerConfig = BaseSignerConfig;\n\n/** Defines a signer capable of signing transactions. */\nexport type TransactionPartialSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signTransactions(\n        transactions: readonly CompilableTransaction[],\n        config?: TransactionPartialSignerConfig,\n    ): Promise<readonly SignatureDictionary[]>;\n}>;\n\n/** Checks whether the provided value implements the {@link TransactionPartialSigner} interface. */\nexport function isTransactionPartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionPartialSigner<TAddress> {\n    return 'signTransactions' in value && typeof value.signTransactions === 'function';\n}\n\n/** Asserts that the provided value implements the {@link TransactionPartialSigner} interface. */\nexport function assertIsTransactionPartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionPartialSigner<TAddress> {\n    if (!isTransactionPartialSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address, isAddress } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, SolanaError } from '@solana/errors';\n\nimport { SignableMessage } from './signable-message';\nimport { BaseSignerConfig } from './types';\n\nexport type MessageModifyingSignerConfig = BaseSignerConfig;\n\n/** Defines a signer capable of signing messages. */\nexport type MessageModifyingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    modifyAndSignMessages(\n        messages: readonly SignableMessage[],\n        config?: MessageModifyingSignerConfig,\n    ): Promise<readonly SignableMessage[]>;\n}>;\n\n/** Checks whether the provided value implements the {@link MessageModifyingSigner} interface. */\nexport function isMessageModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessageModifyingSigner<TAddress> {\n    return (\n        isAddress(value.address) &&\n        'modifyAndSignMessages' in value &&\n        typeof value.modifyAndSignMessages === 'function'\n    );\n}\n\n/** Asserts that the provided value implements the {@link MessageModifyingSigner} interface. */\nexport function assertIsMessageModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessageModifyingSigner<TAddress> {\n    if (!isMessageModifyingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, SolanaError } from '@solana/errors';\n\nimport { isMessageModifyingSigner, MessageModifyingSigner } from './message-modifying-signer';\nimport { isMessagePartialSigner, MessagePartialSigner } from './message-partial-signer';\n\n/** Defines a signer capable of signing messages. */\nexport type MessageSigner<TAddress extends string = string> =\n    | MessageModifyingSigner<TAddress>\n    | MessagePartialSigner<TAddress>;\n\n/** Checks whether the provided value implements the {@link MessageSigner} interface. */\nexport function isMessageSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessageSigner<TAddress> {\n    return isMessagePartialSigner(value) || isMessageModifyingSigner(value);\n}\n\n/** Asserts that the provided value implements the {@link MessageSigner} interface. */\nexport function assertIsMessageSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessageSigner<TAddress> {\n    if (!isMessageSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\n\nimport { MessagePartialSigner } from './message-partial-signer';\nimport { TransactionPartialSigner } from './transaction-partial-signer';\n\n/** Defines a no-operation signer that pretends to partially sign messages and transactions. */\nexport type NoopSigner<TAddress extends string = string> = MessagePartialSigner<TAddress> &\n    TransactionPartialSigner<TAddress>;\n\n/** Creates a NoopSigner from the provided Address. */\nexport function createNoopSigner(address: Address): NoopSigner {\n    const out: NoopSigner = {\n        address,\n        signMessages: async messages => messages.map(() => Object.freeze({})),\n        signTransactions: async transactions => transactions.map(() => Object.freeze({})),\n    };\n\n    return Object.freeze(out);\n}\n","import { SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport {\n    assertTransactionIsFullySigned,\n    CompilableTransaction,\n    IFullySignedTransaction,\n    ITransactionWithSignatures,\n} from '@solana/transactions';\n\nimport { getSignersFromTransaction, ITransactionWithSigners } from './account-signer-meta';\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { isTransactionModifyingSigner, TransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner, TransactionSendingSigner } from './transaction-sending-signer';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\nimport { ITransactionWithSingleSendingSigner } from './transaction-with-single-sending-signer';\n\ntype CompilableTransactionWithSigners = CompilableTransaction &\n    ITransactionWithSigners &\n    Partial<ITransactionWithSignatures>;\n\n/**\n * Signs a transaction using any signers that may be stored in IAccountSignerMeta instruction accounts\n * as well as any signers provided explicitly to this function.\n * It will ignore TransactionSendingSigners since this function does not send the transaction.\n */\nexport async function partiallySignTransactionWithSigners<\n    TTransaction extends CompilableTransactionWithSigners = CompilableTransactionWithSigners,\n>(\n    transaction: TTransaction,\n    config: { abortSignal?: AbortSignal } = {},\n): Promise<ITransactionWithSignatures & TTransaction> {\n    const { partialSigners, modifyingSigners } = categorizeTransactionSigners(\n        deduplicateSigners(getSignersFromTransaction(transaction).filter(isTransactionSigner)),\n        { identifySendingSigner: false },\n    );\n\n    return signModifyingAndPartialTransactionSigners(transaction, modifyingSigners, partialSigners, config.abortSignal);\n}\n\n/**\n * Signs a transaction using any signers that may be stored in IAccountSignerMeta instruction accounts\n * as well as any signers provided explicitly to this function.\n * It will assert that the transaction is fully signed before returning.\n * It will ignore TransactionSendingSigners since this function does not send the transaction.\n */\nexport async function signTransactionWithSigners<\n    TTransaction extends CompilableTransactionWithSigners = CompilableTransactionWithSigners,\n>(\n    transaction: TTransaction,\n    config: { abortSignal?: AbortSignal } = {},\n): Promise<IFullySignedTransaction & TTransaction> {\n    const signedTransaction = await partiallySignTransactionWithSigners(transaction, config);\n    assertTransactionIsFullySigned(signedTransaction);\n    return signedTransaction;\n}\n\n/**\n * Signs and sends a transaction using any signers that may be stored in IAccountSignerMeta\n * instruction accounts as well as any signers provided explicitly to this function.\n * It will identify a single TransactionSendingSigners to use for sending the transaction, if any.\n * Otherwise, it will send the transaction using the provided fallbackSender.\n */\nexport async function signAndSendTransactionWithSigners<\n    TTransaction extends CompilableTransactionWithSigners &\n        ITransactionWithSingleSendingSigner = CompilableTransactionWithSigners & ITransactionWithSingleSendingSigner,\n>(transaction: TTransaction, config: { abortSignal?: AbortSignal } = {}): Promise<SignatureBytes> {\n    const abortSignal = config.abortSignal;\n    const { partialSigners, modifyingSigners, sendingSigner } = categorizeTransactionSigners(\n        deduplicateSigners(getSignersFromTransaction(transaction).filter(isTransactionSigner)),\n    );\n\n    abortSignal?.throwIfAborted();\n    const signedTransaction = await signModifyingAndPartialTransactionSigners(\n        transaction,\n        modifyingSigners,\n        partialSigners,\n        abortSignal,\n    );\n\n    if (!sendingSigner) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n\n    abortSignal?.throwIfAborted();\n    const [signature] = await sendingSigner.signAndSendTransactions([signedTransaction], { abortSignal });\n    abortSignal?.throwIfAborted();\n\n    return signature;\n}\n\n/**\n * Identifies each provided TransactionSigner and categorizes them into their respective types.\n * When a signer implements multiple interface, it will try to used to most powerful interface\n * but fallback to the least powerful interface when necessary.\n * For instance, if a signer implements TransactionSendingSigner and TransactionModifyingSigner,\n * it will be categorized as a TransactionSendingSigner if and only if no other signers implement\n * the TransactionSendingSigner interface.\n */\nfunction categorizeTransactionSigners(\n    signers: readonly TransactionSigner[],\n    config: { identifySendingSigner?: boolean } = {},\n): Readonly<{\n    modifyingSigners: readonly TransactionModifyingSigner[];\n    partialSigners: readonly TransactionPartialSigner[];\n    sendingSigner: TransactionSendingSigner | null;\n}> {\n    // Identify the unique sending signer that should be used.\n    const identifySendingSigner = config.identifySendingSigner ?? true;\n    const sendingSigner = identifySendingSigner ? identifyTransactionSendingSigner(signers) : null;\n\n    // Now, focus on the other signers.\n    // I.e. the modifying or partial signers that are not the identified sending signer.\n    // Note that any other sending only signers will be discarded.\n    const otherSigners = signers.filter(\n        (signer): signer is TransactionModifyingSigner | TransactionPartialSigner =>\n            signer !== sendingSigner && (isTransactionModifyingSigner(signer) || isTransactionPartialSigner(signer)),\n    );\n\n    // Identify the modifying signers from the other signers.\n    const modifyingSigners = identifyTransactionModifyingSigners(otherSigners);\n\n    // Use any remaining signers as partial signers.\n    const partialSigners = otherSigners\n        .filter(isTransactionPartialSigner)\n        .filter(signer => !(modifyingSigners as typeof otherSigners).includes(signer));\n\n    return Object.freeze({ modifyingSigners, partialSigners, sendingSigner });\n}\n\n/** Identifies the best signer to use as a TransactionSendingSigner, if any */\nfunction identifyTransactionSendingSigner(signers: readonly TransactionSigner[]): TransactionSendingSigner | null {\n    // Ensure there are any TransactionSendingSigners in the first place.\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n    if (sendingSigners.length === 0) return null;\n\n    // Prefer sending signers that do not offer other interfaces.\n    const sendingOnlySigners = sendingSigners.filter(\n        signer => !isTransactionModifyingSigner(signer) && !isTransactionPartialSigner(signer),\n    );\n    if (sendingOnlySigners.length > 0) {\n        return sendingOnlySigners[0];\n    }\n\n    // Otherwise, choose any sending signer.\n    return sendingSigners[0];\n}\n\n/** Identifies the best signers to use as TransactionModifyingSigners, if any */\nfunction identifyTransactionModifyingSigners(\n    signers: readonly (TransactionModifyingSigner | TransactionPartialSigner)[],\n): readonly TransactionModifyingSigner[] {\n    // Ensure there are any TransactionModifyingSigner in the first place.\n    const modifyingSigners = signers.filter(isTransactionModifyingSigner);\n    if (modifyingSigners.length === 0) return [];\n\n    // Prefer modifying signers that do not offer partial signing.\n    const nonPartialSigners = modifyingSigners.filter(signer => !isTransactionPartialSigner(signer));\n    if (nonPartialSigners.length > 0) return nonPartialSigners;\n\n    // Otherwise, choose only one modifying signer (whichever).\n    return [modifyingSigners[0]];\n}\n\n/**\n * Signs a transaction using the provided TransactionModifyingSigners\n * sequentially followed by the TransactionPartialSigners in parallel.\n */\nasync function signModifyingAndPartialTransactionSigners<\n    TTransaction extends CompilableTransactionWithSigners = CompilableTransactionWithSigners,\n>(\n    transaction: TTransaction,\n    modifyingSigners: readonly TransactionModifyingSigner[] = [],\n    partialSigners: readonly TransactionPartialSigner[] = [],\n    abortSignal?: AbortSignal,\n): Promise<ITransactionWithSignatures & TTransaction> {\n    // Handle modifying signers sequentially.\n    const modifiedTransaction = await modifyingSigners.reduce(\n        async (transaction, modifyingSigner) => {\n            abortSignal?.throwIfAborted();\n            const [tx] = await modifyingSigner.modifyAndSignTransactions([await transaction], { abortSignal });\n            return Object.freeze(tx);\n        },\n        Promise.resolve(transaction) as Promise<TTransaction>,\n    );\n\n    // Handle partial signers in parallel.\n    abortSignal?.throwIfAborted();\n    const signatureDictionaries = await Promise.all(\n        partialSigners.map(async partialSigner => {\n            const [signatures] = await partialSigner.signTransactions([modifiedTransaction], { abortSignal });\n            return signatures;\n        }),\n    );\n    const signedTransaction: ITransactionWithSignatures & TTransaction = {\n        ...modifiedTransaction,\n        signatures: Object.freeze(\n            signatureDictionaries.reduce((signatures, signatureDictionary) => {\n                return { ...signatures, ...signatureDictionary };\n            }, modifiedTransaction.signatures ?? {}),\n        ),\n    };\n\n    return Object.freeze(signedTransaction);\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, SolanaError } from '@solana/errors';\nimport { CompilableTransaction } from '@solana/transactions';\n\nimport { BaseSignerConfig } from './types';\n\nexport type TransactionModifyingSignerConfig = BaseSignerConfig;\n\n/** Defines a signer capable of signing transactions. */\nexport type TransactionModifyingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    modifyAndSignTransactions<TTransaction extends CompilableTransaction>(\n        transactions: readonly TTransaction[],\n        config?: TransactionModifyingSignerConfig,\n    ): Promise<readonly TTransaction[]>;\n}>;\n\n/** Checks whether the provided value implements the {@link TransactionModifyingSigner} interface. */\nexport function isTransactionModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionModifyingSigner<TAddress> {\n    return 'modifyAndSignTransactions' in value && typeof value.modifyAndSignTransactions === 'function';\n}\n\n/** Asserts that the provided value implements the {@link TransactionModifyingSigner} interface. */\nexport function assertIsTransactionModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionModifyingSigner<TAddress> {\n    if (!isTransactionModifyingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { CompilableTransaction } from '@solana/transactions';\n\nimport { BaseSignerConfig } from './types';\n\nexport type TransactionSendingSignerConfig = BaseSignerConfig;\n\n/** Defines a signer capable of signing and sending transactions simultaneously. */\nexport type TransactionSendingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signAndSendTransactions(\n        transactions: readonly CompilableTransaction[],\n        config?: TransactionSendingSignerConfig,\n    ): Promise<readonly SignatureBytes[]>;\n}>;\n\n/** Checks whether the provided value implements the {@link TransactionSendingSigner} interface. */\nexport function isTransactionSendingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionSendingSigner<TAddress> {\n    return 'signAndSendTransactions' in value && typeof value.signAndSendTransactions === 'function';\n}\n\n/** Asserts that the provided value implements the {@link TransactionSendingSigner} interface. */\nexport function assertIsTransactionSendingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionSendingSigner<TAddress> {\n    if (!isTransactionSendingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, SolanaError } from '@solana/errors';\n\nimport { isTransactionModifyingSigner, TransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner, TransactionSendingSigner } from './transaction-sending-signer';\n\n/** Defines a signer capable of signing transactions. */\nexport type TransactionSigner<TAddress extends string = string> =\n    | TransactionModifyingSigner<TAddress>\n    | TransactionPartialSigner<TAddress>\n    | TransactionSendingSigner<TAddress>;\n\n/** Checks whether the provided value implements the {@link TransactionSigner} interface. */\nexport function isTransactionSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionSigner<TAddress> {\n    return (\n        isTransactionPartialSigner(value) || isTransactionModifyingSigner(value) || isTransactionSendingSigner(value)\n    );\n}\n\n/** Asserts that the provided value implements the {@link TransactionSigner} interface. */\nexport function assertIsTransactionSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionSigner<TAddress> {\n    if (!isTransactionSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import type { Signature } from '@solana/keys';\nimport type { GetSignatureStatusesApi, RequestAirdropApi, Rpc } from '@solana/rpc';\nimport type { RpcSubscriptions, SignatureNotificationsApi } from '@solana/rpc-subscriptions';\nimport {\n    createRecentSignatureConfirmationPromiseFactory,\n    getTimeoutPromise,\n    waitForRecentTransactionConfirmationUntilTimeout,\n} from '@solana/transaction-confirmation';\n\nimport { requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT } from './airdrop-internal';\n\ntype AirdropFunction = (\n    config: Omit<\n        Parameters<typeof requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT>[0],\n        'confirmSignatureOnlyTransaction' | 'rpc'\n    >,\n) => Promise<Signature>;\n\ntype AirdropFactoryConfig = Readonly<{\n    rpc: Rpc<GetSignatureStatusesApi & RequestAirdropApi>;\n    rpcSubscriptions: RpcSubscriptions<SignatureNotificationsApi>;\n}>;\n\nexport function airdropFactory({ rpc, rpcSubscriptions }: AirdropFactoryConfig): AirdropFunction {\n    const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory(\n        rpc,\n        rpcSubscriptions,\n    );\n    async function confirmSignatureOnlyTransaction(\n        config: Omit<\n            Parameters<typeof waitForRecentTransactionConfirmationUntilTimeout>[0],\n            'getRecentSignatureConfirmationPromise' | 'getTimeoutPromise'\n        >,\n    ) {\n        await waitForRecentTransactionConfirmationUntilTimeout({\n            ...config,\n            getRecentSignatureConfirmationPromise,\n            getTimeoutPromise,\n        });\n    }\n    return async function airdrop(config) {\n        return await requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            confirmSignatureOnlyTransaction,\n            rpc,\n        });\n    };\n}\n","import { SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED, SolanaError } from '@solana/errors';\nimport type { GetEpochInfoApi, Rpc } from '@solana/rpc';\nimport type { RpcSubscriptions, SlotNotificationsApi } from '@solana/rpc-subscriptions';\nimport type { Commitment } from '@solana/rpc-types';\n\ntype GetBlockHeightExceedencePromiseFn = (config: {\n    abortSignal: AbortSignal;\n    commitment?: Commitment;\n    lastValidBlockHeight: bigint;\n}) => Promise<void>;\n\nexport function createBlockHeightExceedencePromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: Readonly<{\n    rpc: Rpc<GetEpochInfoApi>;\n    rpcSubscriptions: RpcSubscriptions<SlotNotificationsApi>;\n}>): GetBlockHeightExceedencePromiseFn {\n    return async function getBlockHeightExceedencePromise({\n        abortSignal: callerAbortSignal,\n        commitment,\n        lastValidBlockHeight,\n    }) {\n        const abortController = new AbortController();\n        const handleAbort = () => {\n            abortController.abort();\n        };\n        callerAbortSignal.addEventListener('abort', handleAbort, { signal: abortController.signal });\n        async function getBlockHeightAndDifferenceBetweenSlotHeightAndBlockHeight() {\n            const { absoluteSlot, blockHeight } = await rpc\n                .getEpochInfo({ commitment })\n                .send({ abortSignal: abortController.signal });\n            return {\n                blockHeight,\n                differenceBetweenSlotHeightAndBlockHeight: absoluteSlot - blockHeight,\n            };\n        }\n        try {\n            const [slotNotifications, { blockHeight: initialBlockHeight, differenceBetweenSlotHeightAndBlockHeight }] =\n                await Promise.all([\n                    rpcSubscriptions.slotNotifications().subscribe({ abortSignal: abortController.signal }),\n                    getBlockHeightAndDifferenceBetweenSlotHeightAndBlockHeight(),\n                ]);\n            let currentBlockHeight = initialBlockHeight;\n            if (currentBlockHeight <= lastValidBlockHeight) {\n                let lastKnownDifferenceBetweenSlotHeightAndBlockHeight = differenceBetweenSlotHeightAndBlockHeight;\n                for await (const slotNotification of slotNotifications) {\n                    const { slot } = slotNotification;\n                    if (slot - lastKnownDifferenceBetweenSlotHeightAndBlockHeight > lastValidBlockHeight) {\n                        // Before making a final decision, recheck the actual block height.\n                        const {\n                            blockHeight: recheckedBlockHeight,\n                            differenceBetweenSlotHeightAndBlockHeight: currentDifferenceBetweenSlotHeightAndBlockHeight,\n                        } = await getBlockHeightAndDifferenceBetweenSlotHeightAndBlockHeight();\n                        currentBlockHeight = recheckedBlockHeight;\n                        if (currentBlockHeight > lastValidBlockHeight) {\n                            // Verfied; the block height has been exceeded.\n                            break;\n                        } else {\n                            // The block height has not been exceeded, which implies that the\n                            // difference between the slot height and the block height has grown\n                            // (ie. some blocks have been skipped since we started). Recalibrate the\n                            // difference and keep waiting.\n                            lastKnownDifferenceBetweenSlotHeightAndBlockHeight =\n                                currentDifferenceBetweenSlotHeightAndBlockHeight;\n                        }\n                    }\n                }\n            }\n            throw new SolanaError(SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED, {\n                currentBlockHeight,\n                lastValidBlockHeight,\n            });\n        } finally {\n            abortController.abort();\n        }\n    };\n}\n","import type { Address } from '@solana/addresses';\nimport { getBase58Decoder, getBase64Encoder } from '@solana/codecs-strings';\nimport { SOLANA_ERROR__INVALID_NONCE, SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND, SolanaError } from '@solana/errors';\nimport type { GetAccountInfoApi, Rpc } from '@solana/rpc';\nimport type { AccountNotificationsApi, RpcSubscriptions } from '@solana/rpc-subscriptions';\nimport type { Base64EncodedDataResponse, Commitment } from '@solana/rpc-types';\nimport type { Nonce } from '@solana/transactions';\n\ntype GetNonceInvalidationPromiseFn = (config: {\n    abortSignal: AbortSignal;\n    commitment: Commitment;\n    currentNonceValue: Nonce;\n    nonceAccountAddress: Address;\n}) => Promise<void>;\n\nconst NONCE_VALUE_OFFSET =\n    4 + // version(u32)\n    4 + // state(u32)\n    32; // nonce authority(pubkey)\n// Then comes the nonce value.\n\nexport function createNonceInvalidationPromiseFactory(\n    rpc: Rpc<GetAccountInfoApi>,\n    rpcSubscriptions: RpcSubscriptions<AccountNotificationsApi>,\n): GetNonceInvalidationPromiseFn {\n    return async function getNonceInvalidationPromise({\n        abortSignal: callerAbortSignal,\n        commitment,\n        currentNonceValue: expectedNonceValue,\n        nonceAccountAddress,\n    }) {\n        const abortController = new AbortController();\n        function handleAbort() {\n            abortController.abort();\n        }\n        callerAbortSignal.addEventListener('abort', handleAbort, { signal: abortController.signal });\n        /**\n         * STEP 1: Set up a subscription for nonce account changes.\n         */\n        const accountNotifications = await rpcSubscriptions\n            .accountNotifications(nonceAccountAddress, { commitment, encoding: 'base64' })\n            .subscribe({ abortSignal: abortController.signal });\n        const base58Decoder = getBase58Decoder();\n        const base64Encoder = getBase64Encoder();\n        function getNonceFromAccountData([base64EncodedBytes]: Base64EncodedDataResponse): Nonce {\n            const data = base64Encoder.encode(base64EncodedBytes);\n            const nonceValueBytes = data.slice(NONCE_VALUE_OFFSET, NONCE_VALUE_OFFSET + 32);\n            return base58Decoder.decode(nonceValueBytes) as Nonce;\n        }\n        const nonceAccountDidAdvancePromise = (async () => {\n            for await (const accountNotification of accountNotifications) {\n                const nonceValue = getNonceFromAccountData(accountNotification.value.data);\n                if (nonceValue !== expectedNonceValue) {\n                    throw new SolanaError(SOLANA_ERROR__INVALID_NONCE, {\n                        actualNonceValue: nonceValue,\n                        expectedNonceValue,\n                    });\n                }\n            }\n        })();\n        /**\n         * STEP 2: Having subscribed for updates, make a one-shot request for the current nonce\n         *         value to check if it has already been advanced.\n         */\n        const nonceIsAlreadyInvalidPromise = (async () => {\n            const { value: nonceAccount } = await rpc\n                .getAccountInfo(nonceAccountAddress, {\n                    commitment,\n                    dataSlice: { length: 32, offset: NONCE_VALUE_OFFSET },\n                    encoding: 'base58',\n                })\n                .send({ abortSignal: abortController.signal });\n            if (!nonceAccount) {\n                throw new SolanaError(SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND, {\n                    nonceAccountAddress,\n                });\n            }\n            const nonceValue =\n                // This works because we asked for the exact slice of data representing the nonce\n                // value, and furthermore asked for it in `base58` encoding.\n                nonceAccount.data[0] as unknown as Nonce;\n            if (nonceValue !== expectedNonceValue) {\n                throw new SolanaError(SOLANA_ERROR__INVALID_NONCE, {\n                    actualNonceValue: nonceValue,\n                    expectedNonceValue,\n                });\n            } else {\n                await new Promise(() => {\n                    /* never resolve */\n                });\n            }\n        })();\n        try {\n            return await Promise.race([nonceAccountDidAdvancePromise, nonceIsAlreadyInvalidPromise]);\n        } finally {\n            abortController.abort();\n        }\n    };\n}\n","import { getSolanaErrorFromTransactionError } from '@solana/errors';\nimport type { Signature } from '@solana/keys';\nimport type { GetSignatureStatusesApi, Rpc } from '@solana/rpc';\nimport type { RpcSubscriptions, SignatureNotificationsApi } from '@solana/rpc-subscriptions';\nimport { type Commitment, commitmentComparator } from '@solana/rpc-types';\n\ntype GetRecentSignatureConfirmationPromiseFn = (config: {\n    abortSignal: AbortSignal;\n    commitment: Commitment;\n    signature: Signature;\n}) => Promise<void>;\n\nexport function createRecentSignatureConfirmationPromiseFactory(\n    rpc: Rpc<GetSignatureStatusesApi>,\n    rpcSubscriptions: RpcSubscriptions<SignatureNotificationsApi>,\n): GetRecentSignatureConfirmationPromiseFn {\n    return async function getRecentSignatureConfirmationPromise({\n        abortSignal: callerAbortSignal,\n        commitment,\n        signature,\n    }) {\n        const abortController = new AbortController();\n        function handleAbort() {\n            abortController.abort();\n        }\n        callerAbortSignal.addEventListener('abort', handleAbort, { signal: abortController.signal });\n        /**\n         * STEP 1: Set up a subscription for status changes to a signature.\n         */\n        const signatureStatusNotifications = await rpcSubscriptions\n            .signatureNotifications(signature, { commitment })\n            .subscribe({ abortSignal: abortController.signal });\n        const signatureDidCommitPromise = (async () => {\n            for await (const signatureStatusNotification of signatureStatusNotifications) {\n                if (signatureStatusNotification.value.err) {\n                    throw getSolanaErrorFromTransactionError(signatureStatusNotification.value.err);\n                } else {\n                    return;\n                }\n            }\n        })();\n        /**\n         * STEP 2: Having subscribed for updates, make a one-shot request for the current status.\n         *         This will only yield a result if the signature is still in the status cache.\n         */\n        const signatureStatusLookupPromise = (async () => {\n            const { value: signatureStatusResults } = await rpc\n                .getSignatureStatuses([signature])\n                .send({ abortSignal: abortController.signal });\n            const signatureStatus = signatureStatusResults[0];\n            if (\n                signatureStatus &&\n                signatureStatus.confirmationStatus &&\n                commitmentComparator(signatureStatus.confirmationStatus, commitment) >= 0\n            ) {\n                return;\n            } else {\n                await new Promise(() => {\n                    /* never resolve */\n                });\n            }\n        })();\n        try {\n            return await Promise.race([signatureDidCommitPromise, signatureStatusLookupPromise]);\n        } finally {\n            abortController.abort();\n        }\n    };\n}\n","import type { Commitment } from '@solana/rpc-types';\n\ntype Config = Readonly<{\n    abortSignal: AbortSignal;\n    commitment: Commitment;\n}>;\n\nexport async function getTimeoutPromise({ abortSignal: callerAbortSignal, commitment }: Config) {\n    return await new Promise((_, reject) => {\n        const handleAbort = (e: AbortSignalEventMap['abort']) => {\n            clearTimeout(timeoutId);\n            const abortError = new DOMException((e.target as AbortSignal).reason, 'AbortError');\n            reject(abortError);\n        };\n        callerAbortSignal.addEventListener('abort', handleAbort);\n        const timeoutMs = commitment === 'processed' ? 30_000 : 60_000;\n        const startMs = performance.now();\n        const timeoutId =\n            // We use `setTimeout` instead of `AbortSignal.timeout()` because we want to measure\n            // elapsed time instead of active time.\n            // See https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/timeout_static\n            setTimeout(() => {\n                const elapsedMs = performance.now() - startMs;\n                reject(new DOMException(`Timeout elapsed after ${elapsedMs} ms`, 'TimeoutError'));\n            }, timeoutMs);\n    });\n}\n","import { Signature } from '@solana/keys';\nimport type { Slot } from '@solana/rpc-types';\nimport {\n    getSignatureFromTransaction,\n    IDurableNonceTransaction,\n    ITransactionWithFeePayer,\n    ITransactionWithSignatures,\n} from '@solana/transactions';\n\nimport { createBlockHeightExceedencePromiseFactory } from './confirmation-strategy-blockheight';\nimport { createNonceInvalidationPromiseFactory } from './confirmation-strategy-nonce';\nimport { BaseTransactionConfirmationStrategyConfig, raceStrategies } from './confirmation-strategy-racer';\nimport { getTimeoutPromise } from './confirmation-strategy-timeout';\n\ninterface WaitForDurableNonceTransactionConfirmationConfig extends BaseTransactionConfirmationStrategyConfig {\n    getNonceInvalidationPromise: ReturnType<typeof createNonceInvalidationPromiseFactory>;\n    transaction: IDurableNonceTransaction & ITransactionWithFeePayer & ITransactionWithSignatures;\n}\n\ninterface WaitForRecentTransactionWithBlockhashLifetimeConfirmationConfig\n    extends BaseTransactionConfirmationStrategyConfig {\n    getBlockHeightExceedencePromise: ReturnType<typeof createBlockHeightExceedencePromiseFactory>;\n    transaction: ITransactionWithFeePayer &\n        ITransactionWithSignatures &\n        Readonly<{\n            lifetimeConstraint: {\n                lastValidBlockHeight: Slot;\n            };\n        }>;\n}\n\ninterface WaitForRecentTransactionWithTimeBasedLifetimeConfirmationConfig\n    extends BaseTransactionConfirmationStrategyConfig {\n    getTimeoutPromise: typeof getTimeoutPromise;\n    signature: Signature;\n}\n\nexport async function waitForDurableNonceTransactionConfirmation(\n    config: WaitForDurableNonceTransactionConfirmationConfig,\n): Promise<void> {\n    await raceStrategies(\n        getSignatureFromTransaction(config.transaction),\n        config,\n        function getSpecificStrategiesForRace({ abortSignal, commitment, getNonceInvalidationPromise, transaction }) {\n            return [\n                getNonceInvalidationPromise({\n                    abortSignal,\n                    commitment,\n                    currentNonceValue: transaction.lifetimeConstraint.nonce,\n                    nonceAccountAddress: transaction.instructions[0].accounts[0].address,\n                }),\n            ];\n        },\n    );\n}\n\nexport async function waitForRecentTransactionConfirmation(\n    config: WaitForRecentTransactionWithBlockhashLifetimeConfirmationConfig,\n): Promise<void> {\n    await raceStrategies(\n        getSignatureFromTransaction(config.transaction),\n        config,\n        function getSpecificStrategiesForRace({\n            abortSignal,\n            commitment,\n            getBlockHeightExceedencePromise,\n            transaction,\n        }) {\n            return [\n                getBlockHeightExceedencePromise({\n                    abortSignal,\n                    commitment,\n                    lastValidBlockHeight: transaction.lifetimeConstraint.lastValidBlockHeight,\n                }),\n            ];\n        },\n    );\n}\n\n/** @deprecated */\nexport async function waitForRecentTransactionConfirmationUntilTimeout(\n    config: WaitForRecentTransactionWithTimeBasedLifetimeConfirmationConfig,\n): Promise<void> {\n    await raceStrategies(\n        config.signature,\n        config,\n        function getSpecificStrategiesForRace({ abortSignal, commitment, getTimeoutPromise }) {\n            return [\n                getTimeoutPromise({\n                    abortSignal,\n                    commitment,\n                }),\n            ];\n        },\n    );\n}\n","import type { Signature } from '@solana/keys';\nimport type { Commitment } from '@solana/rpc-types';\n\nimport { createRecentSignatureConfirmationPromiseFactory } from './confirmation-strategy-recent-signature';\n\nexport interface BaseTransactionConfirmationStrategyConfig {\n    abortSignal?: AbortSignal;\n    commitment: Commitment;\n    getRecentSignatureConfirmationPromise: ReturnType<typeof createRecentSignatureConfirmationPromiseFactory>;\n}\n\ntype WithNonNullableAbortSignal<T> = Omit<T, 'abortSignal'> & Readonly<{ abortSignal: AbortSignal }>;\n\nexport async function raceStrategies<TConfig extends BaseTransactionConfirmationStrategyConfig>(\n    signature: Signature,\n    config: TConfig,\n    getSpecificStrategiesForRace: (config: WithNonNullableAbortSignal<TConfig>) => readonly Promise<unknown>[],\n) {\n    const { abortSignal: callerAbortSignal, commitment, getRecentSignatureConfirmationPromise } = config;\n    callerAbortSignal?.throwIfAborted();\n    const abortController = new AbortController();\n    if (callerAbortSignal) {\n        const handleAbort = () => {\n            abortController.abort();\n        };\n        callerAbortSignal.addEventListener('abort', handleAbort, { signal: abortController.signal });\n    }\n    try {\n        const specificStrategies = getSpecificStrategiesForRace({\n            ...config,\n            abortSignal: abortController.signal,\n        });\n        return await Promise.race([\n            getRecentSignatureConfirmationPromise({\n                abortSignal: abortController.signal,\n                commitment,\n                signature,\n            }),\n            ...specificStrategies,\n        ]);\n    } finally {\n        abortController.abort();\n    }\n}\n","import type { Address } from '@solana/addresses';\nimport type { Signature } from '@solana/keys';\nimport type { RequestAirdropApi, Rpc } from '@solana/rpc';\nimport type { Commitment, LamportsUnsafeBeyond2Pow53Minus1 } from '@solana/rpc-types';\nimport { waitForRecentTransactionConfirmationUntilTimeout } from '@solana/transaction-confirmation';\n\ntype RequestAndConfirmAirdropConfig = Readonly<{\n    abortSignal?: AbortSignal;\n    commitment: Commitment;\n    confirmSignatureOnlyTransaction: (\n        config: Omit<\n            Parameters<typeof waitForRecentTransactionConfirmationUntilTimeout>[0],\n            'getRecentSignatureConfirmationPromise' | 'getTimeoutPromise'\n        >,\n    ) => Promise<void>;\n    lamports: LamportsUnsafeBeyond2Pow53Minus1;\n    recipientAddress: Address;\n    rpc: Rpc<RequestAirdropApi>;\n}>;\n\nexport async function requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    commitment,\n    confirmSignatureOnlyTransaction,\n    lamports,\n    recipientAddress,\n    rpc,\n}: RequestAndConfirmAirdropConfig): Promise<Signature> {\n    const airdropTransactionSignature = await rpc\n        .requestAirdrop(recipientAddress, lamports, { commitment })\n        .send({ abortSignal });\n    await confirmSignatureOnlyTransaction({\n        abortSignal,\n        commitment,\n        signature: airdropTransactionSignature,\n    });\n    return airdropTransactionSignature;\n}\n","import {\n    assertAccountsDecoded,\n    assertAccountsExist,\n    type FetchAccountsConfig,\n    fetchJsonParsedAccounts,\n} from '@solana/accounts';\nimport type { Address } from '@solana/addresses';\nimport type { GetMultipleAccountsApi, Rpc } from '@solana/rpc';\nimport {\n    type AddressesByLookupTableAddress,\n    type CompilableTransaction,\n    decompileTransaction,\n    getCompiledTransactionDecoder,\n    type ITransactionWithSignatures,\n} from '@solana/transactions';\n\nlet compiledTransactionDecoder: ReturnType<typeof getCompiledTransactionDecoder> | undefined = undefined;\n\ntype FetchedAddressLookup = {\n    addresses: Address[];\n};\n\nasync function fetchLookupTables(\n    lookupTableAddresses: Address[],\n    rpc: Rpc<GetMultipleAccountsApi>,\n    config?: FetchAccountsConfig,\n): Promise<AddressesByLookupTableAddress> {\n    const fetchedLookupTables = await fetchJsonParsedAccounts<FetchedAddressLookup[]>(\n        rpc,\n        lookupTableAddresses,\n        config,\n    );\n    assertAccountsDecoded(fetchedLookupTables);\n    assertAccountsExist(fetchedLookupTables);\n\n    return fetchedLookupTables.reduce<AddressesByLookupTableAddress>((acc, lookup) => {\n        return {\n            ...acc,\n            [lookup.address]: lookup.data.addresses,\n        };\n    }, {});\n}\n\ntype DecodeTransactionConfig = FetchAccountsConfig & {\n    lastValidBlockHeight?: bigint;\n};\n\nexport async function decodeTransaction(\n    encodedTransaction: Uint8Array,\n    rpc: Rpc<GetMultipleAccountsApi>,\n    config?: DecodeTransactionConfig,\n): Promise<CompilableTransaction | (CompilableTransaction & ITransactionWithSignatures)> {\n    const { lastValidBlockHeight, ...fetchAccountsConfig } = config ?? {};\n\n    if (!compiledTransactionDecoder) compiledTransactionDecoder = getCompiledTransactionDecoder();\n    const compiledTransaction = compiledTransactionDecoder.decode(encodedTransaction);\n    const { compiledMessage } = compiledTransaction;\n\n    const lookupTables =\n        'addressTableLookups' in compiledMessage &&\n        compiledMessage.addressTableLookups !== undefined &&\n        compiledMessage.addressTableLookups.length > 0\n            ? compiledMessage.addressTableLookups\n            : [];\n    const lookupTableAddresses = lookupTables.map(l => l.lookupTableAddress);\n\n    const fetchedLookupTables =\n        lookupTableAddresses.length > 0 ? await fetchLookupTables(lookupTableAddresses, rpc, fetchAccountsConfig) : {};\n\n    return decompileTransaction(compiledTransaction, {\n        addressesByLookupTableAddress: fetchedLookupTables,\n        lastValidBlockHeight,\n    });\n}\n","import type { GetAccountInfoApi, GetEpochInfoApi, GetSignatureStatusesApi, Rpc, SendTransactionApi } from '@solana/rpc';\nimport type {\n    AccountNotificationsApi,\n    RpcSubscriptions,\n    SignatureNotificationsApi,\n    SlotNotificationsApi,\n} from '@solana/rpc-subscriptions';\nimport {\n    createBlockHeightExceedencePromiseFactory,\n    createNonceInvalidationPromiseFactory,\n    createRecentSignatureConfirmationPromiseFactory,\n    waitForDurableNonceTransactionConfirmation,\n    waitForRecentTransactionConfirmation,\n} from '@solana/transaction-confirmation';\nimport {\n    BaseTransaction,\n    IDurableNonceTransaction,\n    IFullySignedTransaction,\n    ITransactionWithBlockhashLifetime,\n    ITransactionWithFeePayer,\n} from '@solana/transactions';\n\nimport {\n    SendableTransaction,\n    sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT,\n    sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT,\n    sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT,\n} from './send-transaction-internal';\n\ninterface SendAndConfirmDurableNonceTransactionFactoryConfig {\n    rpc: Rpc<GetAccountInfoApi & GetSignatureStatusesApi & SendTransactionApi>;\n    rpcSubscriptions: RpcSubscriptions<AccountNotificationsApi & SignatureNotificationsApi>;\n}\n\ninterface SendAndConfirmTransactionWithBlockhashLifetimeFactoryConfig {\n    rpc: Rpc<GetEpochInfoApi & GetSignatureStatusesApi & SendTransactionApi>;\n    rpcSubscriptions: RpcSubscriptions<SignatureNotificationsApi & SlotNotificationsApi>;\n}\n\ninterface SendTransactionWithoutConfirmingFactoryConfig {\n    rpc: Rpc<SendTransactionApi>;\n}\n\ntype SendAndConfirmTransactionWithBlockhashLifetimeFunction = (\n    transaction: ITransactionWithBlockhashLifetime & SendableTransaction,\n    config: Omit<\n        Parameters<typeof sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT>[0],\n        'confirmRecentTransaction' | 'rpc' | 'transaction'\n    >,\n) => Promise<void>;\n\ntype SendAndConfirmDurableNonceTransactionFunction = (\n    transaction: BaseTransaction & IDurableNonceTransaction & IFullySignedTransaction & ITransactionWithFeePayer,\n    config: Omit<\n        Parameters<typeof sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT>[0],\n        'confirmDurableNonceTransaction' | 'rpc' | 'transaction'\n    >,\n) => Promise<void>;\n\ntype SendTransactionWithoutConfirmingFunction = (\n    transaction: SendableTransaction,\n    config: Omit<Parameters<typeof sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT>[0], 'rpc' | 'transaction'>,\n) => Promise<void>;\n\nexport function sendTransactionWithoutConfirmingFactory({\n    rpc,\n}: SendTransactionWithoutConfirmingFactoryConfig): SendTransactionWithoutConfirmingFunction {\n    return async function sendTransactionWithoutConfirming(transaction, config) {\n        await sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            rpc,\n            transaction,\n        });\n    };\n}\n\nexport function sendAndConfirmDurableNonceTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmDurableNonceTransactionFactoryConfig): SendAndConfirmDurableNonceTransactionFunction {\n    const getNonceInvalidationPromise = createNonceInvalidationPromiseFactory(rpc, rpcSubscriptions);\n    const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory(\n        rpc,\n        rpcSubscriptions,\n    );\n    async function confirmDurableNonceTransaction(\n        config: Omit<\n            Parameters<typeof waitForDurableNonceTransactionConfirmation>[0],\n            'getNonceInvalidationPromise' | 'getRecentSignatureConfirmationPromise'\n        >,\n    ) {\n        await waitForDurableNonceTransactionConfirmation({\n            ...config,\n            getNonceInvalidationPromise,\n            getRecentSignatureConfirmationPromise,\n        });\n    }\n    return async function sendAndConfirmDurableNonceTransaction(transaction, config) {\n        await sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            confirmDurableNonceTransaction,\n            rpc,\n            transaction,\n        });\n    };\n}\n\nexport function sendAndConfirmTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmTransactionWithBlockhashLifetimeFactoryConfig): SendAndConfirmTransactionWithBlockhashLifetimeFunction {\n    const getBlockHeightExceedencePromise = createBlockHeightExceedencePromiseFactory({\n        rpc,\n        rpcSubscriptions,\n    });\n    const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory(\n        rpc,\n        rpcSubscriptions,\n    );\n    async function confirmRecentTransaction(\n        config: Omit<\n            Parameters<typeof waitForRecentTransactionConfirmation>[0],\n            'getBlockHeightExceedencePromise' | 'getRecentSignatureConfirmationPromise'\n        >,\n    ) {\n        await waitForRecentTransactionConfirmation({\n            ...config,\n            getBlockHeightExceedencePromise,\n            getRecentSignatureConfirmationPromise,\n        });\n    }\n    return async function sendAndConfirmTransaction(transaction, config) {\n        await sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            confirmRecentTransaction,\n            rpc,\n            transaction,\n        });\n    };\n}\n","import type { Signature } from '@solana/keys';\nimport type { Rpc, SendTransactionApi } from '@solana/rpc';\nimport { Commitment, commitmentComparator } from '@solana/rpc-types';\nimport {\n    waitForDurableNonceTransactionConfirmation,\n    waitForRecentTransactionConfirmation,\n} from '@solana/transaction-confirmation';\nimport {\n    BaseTransaction,\n    getBase64EncodedWireTransaction,\n    IDurableNonceTransaction,\n    IFullySignedTransaction,\n    ITransactionWithBlockhashLifetime,\n    ITransactionWithFeePayer,\n} from '@solana/transactions';\n\ninterface SendAndConfirmDurableNonceTransactionConfig\n    extends SendTransactionBaseConfig,\n        SendTransactionConfigWithoutEncoding {\n    confirmDurableNonceTransaction: (\n        config: Omit<\n            Parameters<typeof waitForDurableNonceTransactionConfirmation>[0],\n            'getNonceInvalidationPromise' | 'getRecentSignatureConfirmationPromise'\n        >,\n    ) => Promise<void>;\n    transaction: IDurableNonceTransaction & SendableTransaction;\n}\n\ninterface SendAndConfirmTransactionWithBlockhashLifetimeConfig\n    extends SendTransactionBaseConfig,\n        SendTransactionConfigWithoutEncoding {\n    confirmRecentTransaction: (\n        config: Omit<\n            Parameters<typeof waitForRecentTransactionConfirmation>[0],\n            'getBlockHeightExceedencePromise' | 'getRecentSignatureConfirmationPromise'\n        >,\n    ) => Promise<void>;\n    transaction: ITransactionWithBlockhashLifetime & SendableTransaction;\n}\n\ninterface SendTransactionBaseConfig extends SendTransactionConfigWithoutEncoding {\n    abortSignal?: AbortSignal;\n    commitment: Commitment;\n    rpc: Rpc<SendTransactionApi>;\n    transaction: SendableTransaction;\n}\n\ninterface SendTransactionConfigWithoutEncoding\n    extends Omit<NonNullable<Parameters<SendTransactionApi['sendTransaction']>[1]>, 'encoding'> {}\n\nexport type SendableTransaction = BaseTransaction &\n    IFullySignedTransaction &\n    ITransactionWithFeePayer &\n    (IDurableNonceTransaction | ITransactionWithBlockhashLifetime);\n\nfunction getSendTransactionConfigWithAdjustedPreflightCommitment(\n    commitment: Commitment,\n    config?: SendTransactionConfigWithoutEncoding,\n): SendTransactionConfigWithoutEncoding | void {\n    if (\n        // The developer has supplied no value for `preflightCommitment`.\n        !config?.preflightCommitment &&\n        // The value of `commitment` is lower than the server default of `preflightCommitment`.\n        commitmentComparator(commitment, 'finalized' /* default value of `preflightCommitment` */) < 0\n    ) {\n        return {\n            ...config,\n            // In the common case, it is unlikely that you want to simulate a transaction at\n            // `finalized` commitment when your standard of commitment for confirming the\n            // transaction is lower. Cap the simulation commitment level to the level of the\n            // confirmation commitment.\n            preflightCommitment: commitment,\n        };\n    }\n    // The commitment at which the developer wishes to confirm the transaction is at least as\n    // high as the commitment at which they want to simulate it. Honour the config as-is.\n    return config;\n}\n\nexport async function sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    commitment,\n    rpc,\n    transaction,\n    ...sendTransactionConfig\n}: SendTransactionBaseConfig): Promise<Signature> {\n    const base64EncodedWireTransaction = getBase64EncodedWireTransaction(transaction);\n    return await rpc\n        .sendTransaction(base64EncodedWireTransaction, {\n            ...getSendTransactionConfigWithAdjustedPreflightCommitment(commitment, sendTransactionConfig),\n            encoding: 'base64',\n        })\n        .send({ abortSignal });\n}\n\nexport async function sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    commitment,\n    confirmDurableNonceTransaction,\n    rpc,\n    transaction,\n    ...sendTransactionConfig\n}: SendAndConfirmDurableNonceTransactionConfig): Promise<Signature> {\n    const transactionSignature = await sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n        ...sendTransactionConfig,\n        abortSignal,\n        commitment,\n        rpc,\n        transaction,\n    });\n    await confirmDurableNonceTransaction({\n        abortSignal,\n        commitment,\n        transaction,\n    });\n    return transactionSignature;\n}\n\nexport async function sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    commitment,\n    confirmRecentTransaction,\n    rpc,\n    transaction,\n    ...sendTransactionConfig\n}: SendAndConfirmTransactionWithBlockhashLifetimeConfig): Promise<Signature> {\n    const transactionSignature = await sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n        ...sendTransactionConfig,\n        abortSignal,\n        commitment,\n        rpc,\n        transaction,\n    });\n    await confirmRecentTransaction({\n        abortSignal,\n        commitment,\n        transaction,\n    });\n    return transactionSignature;\n}\n"]}