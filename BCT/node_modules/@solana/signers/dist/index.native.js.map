{"version":3,"sources":["../src/deduplicate-signers.ts","../src/account-signer-meta.ts","../src/add-signers.ts","../src/fee-payer-signer.ts","../src/keypair-signer.ts","../src/message-partial-signer.ts","../src/transaction-partial-signer.ts","../src/message-modifying-signer.ts","../src/message-signer.ts","../src/noop-signer.ts","../src/sign-transaction.ts","../src/transaction-modifying-signer.ts","../src/transaction-sending-signer.ts","../src/transaction-signer.ts","../../text-encoding-impl/src/index.browser.ts","../src/signable-message.ts","../src/transaction-with-single-sending-signer.ts"],"names":["out","SolanaError","transaction","TextDecoder","TextEncoder","SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING"],"mappings":"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","sourcesContent":["import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, SolanaError } from '@solana/errors';\n\nimport { MessageSigner } from './message-signer';\nimport { TransactionSigner } from './transaction-signer';\n\n/** Removes all duplicated signers from a provided array by comparing their addresses. */\nexport function deduplicateSigners<TSigner extends MessageSigner | TransactionSigner>(\n    signers: readonly TSigner[],\n): readonly TSigner[] {\n    const deduplicated: Record<Address, TSigner> = {};\n    signers.forEach(signer => {\n        if (!deduplicated[signer.address]) {\n            deduplicated[signer.address] = signer;\n        } else if (deduplicated[signer.address] !== signer) {\n            throw new SolanaError(SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, {\n                address: signer.address,\n            });\n        }\n    });\n    return Object.values(deduplicated);\n}\n","import { AccountRole, IAccountLookupMeta, IAccountMeta, IInstruction } from '@solana/instructions';\nimport { BaseTransaction, TransactionVersion } from '@solana/transactions';\n\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { TransactionSigner } from './transaction-signer';\n\n/** An extension of the IAccountMeta type that keeps track of its transaction signer. */\nexport interface IAccountSignerMeta<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n> extends IAccountMeta<TAddress> {\n    readonly role: AccountRole.READONLY_SIGNER | AccountRole.WRITABLE_SIGNER;\n    readonly signer: TSigner;\n}\n\ntype IAccountMetaWithSigner<TSigner extends TransactionSigner = TransactionSigner> =\n    | IAccountLookupMeta\n    | IAccountMeta\n    | IAccountSignerMeta<string, TSigner>;\n\n/** A variation of the instruction type that allows IAccountSignerMeta in its account metas. */\nexport type IInstructionWithSigners<\n    TSigner extends TransactionSigner = TransactionSigner,\n    TAccounts extends readonly IAccountMetaWithSigner<TSigner>[] = readonly IAccountMetaWithSigner<TSigner>[],\n> = Pick<IInstruction<string, TAccounts>, 'accounts'>;\n\n/** A variation of the transaction type that allows IAccountSignerMeta in its account metas. */\nexport type ITransactionWithSigners<\n    TSigner extends TransactionSigner = TransactionSigner,\n    TAccounts extends readonly IAccountMetaWithSigner<TSigner>[] = readonly IAccountMetaWithSigner<TSigner>[],\n> = Pick<\n    BaseTransaction<TransactionVersion, IInstruction & IInstructionWithSigners<TSigner, TAccounts>>,\n    'instructions'\n> & { feePayerSigner?: TSigner };\n\n/** Extract all signers from an instruction that may contain IAccountSignerMeta accounts. */\nexport function getSignersFromInstruction<TSigner extends TransactionSigner = TransactionSigner>(\n    instruction: IInstructionWithSigners<TSigner>,\n): readonly TSigner[] {\n    return deduplicateSigners(\n        (instruction.accounts ?? []).flatMap(account => ('signer' in account ? account.signer : [])),\n    );\n}\n\n/** Extract all signers from a transaction that may contain IAccountSignerMeta accounts. */\nexport function getSignersFromTransaction<\n    TSigner extends TransactionSigner = TransactionSigner,\n    TTransaction extends ITransactionWithSigners<TSigner> = ITransactionWithSigners<TSigner>,\n>(transaction: TTransaction): readonly TSigner[] {\n    return deduplicateSigners([\n        ...(transaction.feePayerSigner ? [transaction.feePayerSigner] : []),\n        ...transaction.instructions.flatMap(getSignersFromInstruction),\n    ]);\n}\n","import { IInstruction, isSignerRole } from '@solana/instructions';\nimport { BaseTransaction } from '@solana/transactions';\n\nimport { IAccountSignerMeta, IInstructionWithSigners, ITransactionWithSigners } from './account-signer-meta';\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { TransactionSigner } from './transaction-signer';\n\n/** Attaches the provided signers to the account metas of an instruction when applicable. */\nexport function addSignersToInstruction<TInstruction extends IInstruction>(\n    signers: TransactionSigner[],\n    instruction: TInstruction | (IInstructionWithSigners & TInstruction),\n): IInstructionWithSigners & TInstruction {\n    if (!instruction.accounts || instruction.accounts.length === 0) {\n        return instruction as IInstructionWithSigners & TInstruction;\n    }\n\n    const signerByAddress = new Map(deduplicateSigners(signers).map(signer => [signer.address, signer]));\n    return Object.freeze({\n        ...instruction,\n        accounts: instruction.accounts.map(account => {\n            const signer = signerByAddress.get(account.address);\n            if (!isSignerRole(account.role) || 'signer' in account || !signer) {\n                return account;\n            }\n            return Object.freeze({ ...account, signer } as IAccountSignerMeta);\n        }),\n    });\n}\n\n/** Attaches the provided signers to the account metas of a transaction when applicable. */\nexport function addSignersToTransaction<TTransaction extends BaseTransaction>(\n    signers: TransactionSigner[],\n    transaction: TTransaction | (ITransactionWithSigners & TTransaction),\n): ITransactionWithSigners & TTransaction {\n    if (transaction.instructions.length === 0) {\n        return transaction as ITransactionWithSigners & TTransaction;\n    }\n\n    return Object.freeze({\n        ...transaction,\n        instructions: transaction.instructions.map(instruction => addSignersToInstruction(signers, instruction)),\n    });\n}\n","import { Address } from '@solana/addresses';\nimport {\n    BaseTransaction,\n    getUnsignedTransaction,\n    ITransactionWithFeePayer,\n    ITransactionWithSignatures,\n} from '@solana/transactions';\n\nimport { TransactionSigner } from './transaction-signer';\n\nexport interface ITransactionWithFeePayerSigner<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n> {\n    readonly feePayer: Address<TAddress>;\n    readonly feePayerSigner: TSigner;\n}\n\nexport function setTransactionFeePayerSigner<TFeePayerAddress extends string, TTransaction extends BaseTransaction>(\n    feePayerSigner: TransactionSigner<TFeePayerAddress>,\n    transaction:\n        | (ITransactionWithFeePayer<string> & ITransactionWithSignatures & TTransaction)\n        | (ITransactionWithSignatures & TTransaction),\n): ITransactionWithFeePayerSigner<TFeePayerAddress> & Omit<TTransaction, keyof ITransactionWithSignatures>;\n\nexport function setTransactionFeePayerSigner<TFeePayerAddress extends string, TTransaction extends BaseTransaction>(\n    feePayerSigner: TransactionSigner<TFeePayerAddress>,\n    transaction: TTransaction | (ITransactionWithFeePayer<string> & TTransaction),\n): ITransactionWithFeePayerSigner<TFeePayerAddress> & TTransaction;\n\nexport function setTransactionFeePayerSigner<TFeePayerAddress extends string, TTransaction extends BaseTransaction>(\n    feePayerSigner: TransactionSigner<TFeePayerAddress>,\n    transaction:\n        | TTransaction\n        | (ITransactionWithFeePayer<string> & ITransactionWithSignatures & TTransaction)\n        | (ITransactionWithFeePayer<string> & TTransaction)\n        | (ITransactionWithSignatures & TTransaction),\n) {\n    if ('feePayer' in transaction && feePayerSigner.address === transaction.feePayer) {\n        if ('feePayerSigner' in transaction) return transaction;\n        const out = { ...transaction, feePayerSigner };\n        Object.freeze(out);\n        return out;\n    }\n    const out = {\n        ...getUnsignedTransaction(transaction),\n        feePayer: feePayerSigner.address,\n        feePayerSigner,\n    };\n    Object.freeze(out);\n    return out;\n}\n","import { Address, getAddressFromPublicKey } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, SolanaError } from '@solana/errors';\nimport { createKeyPairFromBytes, generateKeyPair, signBytes } from '@solana/keys';\nimport { partiallySignTransaction } from '@solana/transactions';\n\nimport { isMessagePartialSigner, MessagePartialSigner } from './message-partial-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\n\n/** Defines a signer capable of signing messages and transactions using a CryptoKeyPair. */\nexport type KeyPairSigner<TAddress extends string = string> = MessagePartialSigner<TAddress> &\n    TransactionPartialSigner<TAddress> & { keyPair: CryptoKeyPair };\n\n/** Checks whether the provided value implements the {@link KeyPairSigner} interface. */\nexport function isKeyPairSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is KeyPairSigner<TAddress> {\n    return (\n        'keyPair' in value &&\n        typeof value.keyPair === 'object' &&\n        isMessagePartialSigner(value) &&\n        isTransactionPartialSigner(value)\n    );\n}\n\n/** Asserts that the provided value implements the {@link KeyPairSigner} interface. */\nexport function assertIsKeyPairSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is KeyPairSigner<TAddress> {\n    if (!isKeyPairSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n\n/** Creates a KeyPairSigner from the provided Crypto KeyPair. */\nexport async function createSignerFromKeyPair(keyPair: CryptoKeyPair): Promise<KeyPairSigner> {\n    const address = await getAddressFromPublicKey(keyPair.publicKey);\n    const out: KeyPairSigner = {\n        address,\n        keyPair,\n        signMessages: messages =>\n            Promise.all(\n                messages.map(async message =>\n                    Object.freeze({ [address]: await signBytes(keyPair.privateKey, message.content) }),\n                ),\n            ),\n        signTransactions: transactions =>\n            Promise.all(\n                transactions.map(async transaction => {\n                    const signedTransaction = await partiallySignTransaction([keyPair], transaction);\n                    return Object.freeze({ [address]: signedTransaction.signatures[address] });\n                }),\n            ),\n    };\n\n    return Object.freeze(out);\n}\n\n/** Securely generates a signer capable of signing messages and transactions using a Crypto KeyPair. */\nexport async function generateKeyPairSigner(): Promise<KeyPairSigner> {\n    return createSignerFromKeyPair(await generateKeyPair());\n}\n\n/** Creates a signer capable of signing messages and transactions using the 64 bytes of a KeyPair. */\nexport async function createKeyPairSignerFromBytes(bytes: Uint8Array, extractable?: boolean): Promise<KeyPairSigner> {\n    return createSignerFromKeyPair(await createKeyPairFromBytes(bytes, extractable));\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, SolanaError } from '@solana/errors';\n\nimport { SignableMessage } from './signable-message';\nimport { BaseSignerConfig, SignatureDictionary } from './types';\n\nexport type MessagePartialSignerConfig = BaseSignerConfig;\n\n/** Defines a signer capable of signing messages. */\nexport type MessagePartialSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signMessages(\n        messages: readonly SignableMessage[],\n        config?: MessagePartialSignerConfig,\n    ): Promise<readonly SignatureDictionary[]>;\n}>;\n\n/** Checks whether the provided value implements the {@link MessagePartialSigner} interface. */\nexport function isMessagePartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessagePartialSigner<TAddress> {\n    return 'signMessages' in value && typeof value.signMessages === 'function';\n}\n\n/** Asserts that the provided value implements the {@link MessagePartialSigner} interface. */\nexport function assertIsMessagePartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessagePartialSigner<TAddress> {\n    if (!isMessagePartialSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, SolanaError } from '@solana/errors';\nimport { CompilableTransaction } from '@solana/transactions';\n\nimport { BaseSignerConfig, SignatureDictionary } from './types';\n\nexport type TransactionPartialSignerConfig = BaseSignerConfig;\n\n/** Defines a signer capable of signing transactions. */\nexport type TransactionPartialSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signTransactions(\n        transactions: readonly CompilableTransaction[],\n        config?: TransactionPartialSignerConfig,\n    ): Promise<readonly SignatureDictionary[]>;\n}>;\n\n/** Checks whether the provided value implements the {@link TransactionPartialSigner} interface. */\nexport function isTransactionPartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionPartialSigner<TAddress> {\n    return 'signTransactions' in value && typeof value.signTransactions === 'function';\n}\n\n/** Asserts that the provided value implements the {@link TransactionPartialSigner} interface. */\nexport function assertIsTransactionPartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionPartialSigner<TAddress> {\n    if (!isTransactionPartialSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address, isAddress } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, SolanaError } from '@solana/errors';\n\nimport { SignableMessage } from './signable-message';\nimport { BaseSignerConfig } from './types';\n\nexport type MessageModifyingSignerConfig = BaseSignerConfig;\n\n/** Defines a signer capable of signing messages. */\nexport type MessageModifyingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    modifyAndSignMessages(\n        messages: readonly SignableMessage[],\n        config?: MessageModifyingSignerConfig,\n    ): Promise<readonly SignableMessage[]>;\n}>;\n\n/** Checks whether the provided value implements the {@link MessageModifyingSigner} interface. */\nexport function isMessageModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessageModifyingSigner<TAddress> {\n    return (\n        isAddress(value.address) &&\n        'modifyAndSignMessages' in value &&\n        typeof value.modifyAndSignMessages === 'function'\n    );\n}\n\n/** Asserts that the provided value implements the {@link MessageModifyingSigner} interface. */\nexport function assertIsMessageModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessageModifyingSigner<TAddress> {\n    if (!isMessageModifyingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, SolanaError } from '@solana/errors';\n\nimport { isMessageModifyingSigner, MessageModifyingSigner } from './message-modifying-signer';\nimport { isMessagePartialSigner, MessagePartialSigner } from './message-partial-signer';\n\n/** Defines a signer capable of signing messages. */\nexport type MessageSigner<TAddress extends string = string> =\n    | MessageModifyingSigner<TAddress>\n    | MessagePartialSigner<TAddress>;\n\n/** Checks whether the provided value implements the {@link MessageSigner} interface. */\nexport function isMessageSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessageSigner<TAddress> {\n    return isMessagePartialSigner(value) || isMessageModifyingSigner(value);\n}\n\n/** Asserts that the provided value implements the {@link MessageSigner} interface. */\nexport function assertIsMessageSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessageSigner<TAddress> {\n    if (!isMessageSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\n\nimport { MessagePartialSigner } from './message-partial-signer';\nimport { TransactionPartialSigner } from './transaction-partial-signer';\n\n/** Defines a no-operation signer that pretends to partially sign messages and transactions. */\nexport type NoopSigner<TAddress extends string = string> = MessagePartialSigner<TAddress> &\n    TransactionPartialSigner<TAddress>;\n\n/** Creates a NoopSigner from the provided Address. */\nexport function createNoopSigner(address: Address): NoopSigner {\n    const out: NoopSigner = {\n        address,\n        signMessages: async messages => messages.map(() => Object.freeze({})),\n        signTransactions: async transactions => transactions.map(() => Object.freeze({})),\n    };\n\n    return Object.freeze(out);\n}\n","import { SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport {\n    assertTransactionIsFullySigned,\n    CompilableTransaction,\n    IFullySignedTransaction,\n    ITransactionWithSignatures,\n} from '@solana/transactions';\n\nimport { getSignersFromTransaction, ITransactionWithSigners } from './account-signer-meta';\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { isTransactionModifyingSigner, TransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner, TransactionSendingSigner } from './transaction-sending-signer';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\nimport { ITransactionWithSingleSendingSigner } from './transaction-with-single-sending-signer';\n\ntype CompilableTransactionWithSigners = CompilableTransaction &\n    ITransactionWithSigners &\n    Partial<ITransactionWithSignatures>;\n\n/**\n * Signs a transaction using any signers that may be stored in IAccountSignerMeta instruction accounts\n * as well as any signers provided explicitly to this function.\n * It will ignore TransactionSendingSigners since this function does not send the transaction.\n */\nexport async function partiallySignTransactionWithSigners<\n    TTransaction extends CompilableTransactionWithSigners = CompilableTransactionWithSigners,\n>(\n    transaction: TTransaction,\n    config: { abortSignal?: AbortSignal } = {},\n): Promise<ITransactionWithSignatures & TTransaction> {\n    const { partialSigners, modifyingSigners } = categorizeTransactionSigners(\n        deduplicateSigners(getSignersFromTransaction(transaction).filter(isTransactionSigner)),\n        { identifySendingSigner: false },\n    );\n\n    return signModifyingAndPartialTransactionSigners(transaction, modifyingSigners, partialSigners, config.abortSignal);\n}\n\n/**\n * Signs a transaction using any signers that may be stored in IAccountSignerMeta instruction accounts\n * as well as any signers provided explicitly to this function.\n * It will assert that the transaction is fully signed before returning.\n * It will ignore TransactionSendingSigners since this function does not send the transaction.\n */\nexport async function signTransactionWithSigners<\n    TTransaction extends CompilableTransactionWithSigners = CompilableTransactionWithSigners,\n>(\n    transaction: TTransaction,\n    config: { abortSignal?: AbortSignal } = {},\n): Promise<IFullySignedTransaction & TTransaction> {\n    const signedTransaction = await partiallySignTransactionWithSigners(transaction, config);\n    assertTransactionIsFullySigned(signedTransaction);\n    return signedTransaction;\n}\n\n/**\n * Signs and sends a transaction using any signers that may be stored in IAccountSignerMeta\n * instruction accounts as well as any signers provided explicitly to this function.\n * It will identify a single TransactionSendingSigners to use for sending the transaction, if any.\n * Otherwise, it will send the transaction using the provided fallbackSender.\n */\nexport async function signAndSendTransactionWithSigners<\n    TTransaction extends CompilableTransactionWithSigners &\n        ITransactionWithSingleSendingSigner = CompilableTransactionWithSigners & ITransactionWithSingleSendingSigner,\n>(transaction: TTransaction, config: { abortSignal?: AbortSignal } = {}): Promise<SignatureBytes> {\n    const abortSignal = config.abortSignal;\n    const { partialSigners, modifyingSigners, sendingSigner } = categorizeTransactionSigners(\n        deduplicateSigners(getSignersFromTransaction(transaction).filter(isTransactionSigner)),\n    );\n\n    abortSignal?.throwIfAborted();\n    const signedTransaction = await signModifyingAndPartialTransactionSigners(\n        transaction,\n        modifyingSigners,\n        partialSigners,\n        abortSignal,\n    );\n\n    if (!sendingSigner) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n\n    abortSignal?.throwIfAborted();\n    const [signature] = await sendingSigner.signAndSendTransactions([signedTransaction], { abortSignal });\n    abortSignal?.throwIfAborted();\n\n    return signature;\n}\n\n/**\n * Identifies each provided TransactionSigner and categorizes them into their respective types.\n * When a signer implements multiple interface, it will try to used to most powerful interface\n * but fallback to the least powerful interface when necessary.\n * For instance, if a signer implements TransactionSendingSigner and TransactionModifyingSigner,\n * it will be categorized as a TransactionSendingSigner if and only if no other signers implement\n * the TransactionSendingSigner interface.\n */\nfunction categorizeTransactionSigners(\n    signers: readonly TransactionSigner[],\n    config: { identifySendingSigner?: boolean } = {},\n): Readonly<{\n    modifyingSigners: readonly TransactionModifyingSigner[];\n    partialSigners: readonly TransactionPartialSigner[];\n    sendingSigner: TransactionSendingSigner | null;\n}> {\n    // Identify the unique sending signer that should be used.\n    const identifySendingSigner = config.identifySendingSigner ?? true;\n    const sendingSigner = identifySendingSigner ? identifyTransactionSendingSigner(signers) : null;\n\n    // Now, focus on the other signers.\n    // I.e. the modifying or partial signers that are not the identified sending signer.\n    // Note that any other sending only signers will be discarded.\n    const otherSigners = signers.filter(\n        (signer): signer is TransactionModifyingSigner | TransactionPartialSigner =>\n            signer !== sendingSigner && (isTransactionModifyingSigner(signer) || isTransactionPartialSigner(signer)),\n    );\n\n    // Identify the modifying signers from the other signers.\n    const modifyingSigners = identifyTransactionModifyingSigners(otherSigners);\n\n    // Use any remaining signers as partial signers.\n    const partialSigners = otherSigners\n        .filter(isTransactionPartialSigner)\n        .filter(signer => !(modifyingSigners as typeof otherSigners).includes(signer));\n\n    return Object.freeze({ modifyingSigners, partialSigners, sendingSigner });\n}\n\n/** Identifies the best signer to use as a TransactionSendingSigner, if any */\nfunction identifyTransactionSendingSigner(signers: readonly TransactionSigner[]): TransactionSendingSigner | null {\n    // Ensure there are any TransactionSendingSigners in the first place.\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n    if (sendingSigners.length === 0) return null;\n\n    // Prefer sending signers that do not offer other interfaces.\n    const sendingOnlySigners = sendingSigners.filter(\n        signer => !isTransactionModifyingSigner(signer) && !isTransactionPartialSigner(signer),\n    );\n    if (sendingOnlySigners.length > 0) {\n        return sendingOnlySigners[0];\n    }\n\n    // Otherwise, choose any sending signer.\n    return sendingSigners[0];\n}\n\n/** Identifies the best signers to use as TransactionModifyingSigners, if any */\nfunction identifyTransactionModifyingSigners(\n    signers: readonly (TransactionModifyingSigner | TransactionPartialSigner)[],\n): readonly TransactionModifyingSigner[] {\n    // Ensure there are any TransactionModifyingSigner in the first place.\n    const modifyingSigners = signers.filter(isTransactionModifyingSigner);\n    if (modifyingSigners.length === 0) return [];\n\n    // Prefer modifying signers that do not offer partial signing.\n    const nonPartialSigners = modifyingSigners.filter(signer => !isTransactionPartialSigner(signer));\n    if (nonPartialSigners.length > 0) return nonPartialSigners;\n\n    // Otherwise, choose only one modifying signer (whichever).\n    return [modifyingSigners[0]];\n}\n\n/**\n * Signs a transaction using the provided TransactionModifyingSigners\n * sequentially followed by the TransactionPartialSigners in parallel.\n */\nasync function signModifyingAndPartialTransactionSigners<\n    TTransaction extends CompilableTransactionWithSigners = CompilableTransactionWithSigners,\n>(\n    transaction: TTransaction,\n    modifyingSigners: readonly TransactionModifyingSigner[] = [],\n    partialSigners: readonly TransactionPartialSigner[] = [],\n    abortSignal?: AbortSignal,\n): Promise<ITransactionWithSignatures & TTransaction> {\n    // Handle modifying signers sequentially.\n    const modifiedTransaction = await modifyingSigners.reduce(\n        async (transaction, modifyingSigner) => {\n            abortSignal?.throwIfAborted();\n            const [tx] = await modifyingSigner.modifyAndSignTransactions([await transaction], { abortSignal });\n            return Object.freeze(tx);\n        },\n        Promise.resolve(transaction) as Promise<TTransaction>,\n    );\n\n    // Handle partial signers in parallel.\n    abortSignal?.throwIfAborted();\n    const signatureDictionaries = await Promise.all(\n        partialSigners.map(async partialSigner => {\n            const [signatures] = await partialSigner.signTransactions([modifiedTransaction], { abortSignal });\n            return signatures;\n        }),\n    );\n    const signedTransaction: ITransactionWithSignatures & TTransaction = {\n        ...modifiedTransaction,\n        signatures: Object.freeze(\n            signatureDictionaries.reduce((signatures, signatureDictionary) => {\n                return { ...signatures, ...signatureDictionary };\n            }, modifiedTransaction.signatures ?? {}),\n        ),\n    };\n\n    return Object.freeze(signedTransaction);\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, SolanaError } from '@solana/errors';\nimport { CompilableTransaction } from '@solana/transactions';\n\nimport { BaseSignerConfig } from './types';\n\nexport type TransactionModifyingSignerConfig = BaseSignerConfig;\n\n/** Defines a signer capable of signing transactions. */\nexport type TransactionModifyingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    modifyAndSignTransactions<TTransaction extends CompilableTransaction>(\n        transactions: readonly TTransaction[],\n        config?: TransactionModifyingSignerConfig,\n    ): Promise<readonly TTransaction[]>;\n}>;\n\n/** Checks whether the provided value implements the {@link TransactionModifyingSigner} interface. */\nexport function isTransactionModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionModifyingSigner<TAddress> {\n    return 'modifyAndSignTransactions' in value && typeof value.modifyAndSignTransactions === 'function';\n}\n\n/** Asserts that the provided value implements the {@link TransactionModifyingSigner} interface. */\nexport function assertIsTransactionModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionModifyingSigner<TAddress> {\n    if (!isTransactionModifyingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { CompilableTransaction } from '@solana/transactions';\n\nimport { BaseSignerConfig } from './types';\n\nexport type TransactionSendingSignerConfig = BaseSignerConfig;\n\n/** Defines a signer capable of signing and sending transactions simultaneously. */\nexport type TransactionSendingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signAndSendTransactions(\n        transactions: readonly CompilableTransaction[],\n        config?: TransactionSendingSignerConfig,\n    ): Promise<readonly SignatureBytes[]>;\n}>;\n\n/** Checks whether the provided value implements the {@link TransactionSendingSigner} interface. */\nexport function isTransactionSendingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionSendingSigner<TAddress> {\n    return 'signAndSendTransactions' in value && typeof value.signAndSendTransactions === 'function';\n}\n\n/** Asserts that the provided value implements the {@link TransactionSendingSigner} interface. */\nexport function assertIsTransactionSendingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionSendingSigner<TAddress> {\n    if (!isTransactionSendingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, SolanaError } from '@solana/errors';\n\nimport { isTransactionModifyingSigner, TransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner, TransactionSendingSigner } from './transaction-sending-signer';\n\n/** Defines a signer capable of signing transactions. */\nexport type TransactionSigner<TAddress extends string = string> =\n    | TransactionModifyingSigner<TAddress>\n    | TransactionPartialSigner<TAddress>\n    | TransactionSendingSigner<TAddress>;\n\n/** Checks whether the provided value implements the {@link TransactionSigner} interface. */\nexport function isTransactionSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionSigner<TAddress> {\n    return (\n        isTransactionPartialSigner(value) || isTransactionModifyingSigner(value) || isTransactionSendingSigner(value)\n    );\n}\n\n/** Asserts that the provided value implements the {@link TransactionSigner} interface. */\nexport function assertIsTransactionSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionSigner<TAddress> {\n    if (!isTransactionSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import { TextEncoder } from '@solana/text-encoding-impl';\n\nimport { SignatureDictionary } from './types';\n\n/** Defines a message that needs signing and its current set of signatures if any. */\nexport type SignableMessage = Readonly<{\n    content: Uint8Array;\n    signatures: SignatureDictionary;\n}>;\n\n/**\n * Creates a signable message from a provided content.\n * If a string is provided, it will be UTF-8 encoded.\n */\nexport function createSignableMessage(\n    content: Uint8Array | string,\n    signatures: SignatureDictionary = {},\n): SignableMessage {\n    return Object.freeze({\n        content: typeof content === 'string' ? new TextEncoder().encode(content) : content,\n        signatures: Object.freeze({ ...signatures }),\n    });\n}\n","import {\n    SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS,\n    SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { CompilableTransaction } from '@solana/transactions';\n\nimport { getSignersFromTransaction, ITransactionWithSigners } from './account-signer-meta';\nimport { isTransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner } from './transaction-sending-signer';\n\n/** Defines a transaction with exactly one {@link TransactionSendingSigner}. */\nexport type ITransactionWithSingleSendingSigner = ITransactionWithSigners & {\n    readonly __transactionWithSingleSendingSigner: unique symbol;\n};\n\n/** Checks whether the provided transaction has exactly one {@link TransactionSendingSigner}. */\nexport function isTransactionWithSingleSendingSigner<TTransaction extends CompilableTransaction>(\n    transaction: TTransaction,\n): transaction is ITransactionWithSingleSendingSigner & TTransaction {\n    try {\n        assertIsTransactionWithSingleSendingSigner(transaction);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/** Asserts that the provided transaction has exactly one {@link TransactionSendingSigner}. */\nexport function assertIsTransactionWithSingleSendingSigner<TTransaction extends CompilableTransaction>(\n    transaction: TTransaction,\n): asserts transaction is ITransactionWithSingleSendingSigner & TTransaction {\n    const signers = getSignersFromTransaction(transaction);\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n\n    if (sendingSigners.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n\n    // When identifying if there are multiple sending signers, we only need to check for\n    // sending signers that do not implement other transaction signer interfaces as\n    // they will be used as these other signer interfaces in case of a conflict.\n    const sendingOnlySigners = sendingSigners.filter(\n        signer => !isTransactionPartialSigner(signer) && !isTransactionModifyingSigner(signer),\n    );\n\n    if (sendingOnlySigners.length > 1) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS);\n    }\n}\n"]}